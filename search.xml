<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>InnoDB缓存机制和底层数据结构</title>
    <url>/2019/11/26/InnoDB%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E5%92%8C%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="InnoDB缓存方案和底层存储结构"><a href="#InnoDB缓存方案和底层存储结构" class="headerlink" title="InnoDB缓存方案和底层存储结构"></a>InnoDB缓存方案和底层存储结构</h1><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><table>
<thead>
<tr>
<th>资料名称</th>
<th>来源地址</th>
</tr>
</thead>
<tbody>
<tr>
<td>《MySQL王者晋级之路》</td>
<td>图书</td>
</tr>
<tr>
<td>《MySQL技术内幕 InnoDB存储引擎》</td>
<td>图书</td>
</tr>
<tr>
<td>MySQL 5.7官方文档</td>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/</a></td>
</tr>
</tbody>
</table><h2 id="InnoDB引擎概述"><a href="#InnoDB引擎概述" class="headerlink" title="InnoDB引擎概述"></a>InnoDB引擎概述</h2><a id="more"></a>
<p>InnoDB是事务安全的MySQL存储引擎。最早由Innobase Oy公司开发，从MySQL 5.5版本开始是默认的表存储引擎（之前版本InnoDB存储引擎仅在Windows下为默认的存储引擎）。该存储引擎是第一个完整支持ACID事务的MySQL存储引擎，其特点是行锁设计、支持MVCC、支持外键、提供一致性非锁定读，同时被设计用来最有效地利用以及使用内存和CPU。</p>
<h2 id="InnoDB体系架构"><a href="#InnoDB体系架构" class="headerlink" title="InnoDB体系架构"></a>InnoDB体系架构</h2><p><img src="InnoDB%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E5%92%8C%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/innodb-architecture.png" alt="InnoDB architecture diagram showing in-memory and on-disk structures."></p>
<p>InnoDB存储引擎有多个内存块，这些内存块组成一个内存池，主要负责如下工作：</p>
<ul>
<li>维护所有进程、线程需要访问的多个内部数据结构</li>
<li>缓存磁盘上的数据，方便快速读取，同时在对磁盘文件的数据修改之前在这里缓存</li>
<li>重做日志（redo log）缓冲</li>
</ul>
<p>后台线程的主要作用：</p>
<ul>
<li>负责刷新内存池中的数据，保证缓冲池中的内存缓存的是最近的数据</li>
<li>将已修改的数据文件刷新到磁盘文件</li>
</ul>
<h2 id="InnoDB缓存机制"><a href="#InnoDB缓存机制" class="headerlink" title="InnoDB缓存机制"></a>InnoDB缓存机制</h2><h3 id="缓冲池（Buffer-Pool）"><a href="#缓冲池（Buffer-Pool）" class="headerlink" title="缓冲池（Buffer Pool）"></a>缓冲池（Buffer Pool）</h3><p>Buffer Pool是InnoDB在主内存中用于缓存查询到的表和索引数据的区域，它能够使InnoDB直接从内存中处理经常使用的数据，从而加快处理速度。在专用MySQL服务器上，多达80%的物理内存通常分配给缓冲池。</p>
<p>为提高大批量数据的读取效率，Buffer Pool被划分为多个页，每个页包可以含多条行记录。为了提高缓存管理的效率，Buffer Pool被实现为页面的列表，很少使用的数据页使用变种的LRU算法从缓存中老化。</p>
<h4 id="缓冲池的-LRU-算法"><a href="#缓冲池的-LRU-算法" class="headerlink" title="缓冲池的 LRU 算法"></a>缓冲池的 LRU 算法</h4><p>普通的LRU算法实现的是末尾淘汰制，当整个链表已满时，淘汰尾部，将新的数据页加入头部；</p>
<p>Buffer Pool的LRU算法与普通的LRU算法不一样，新数据页插入时并不从头部插入，而是从中间位置插入（默认配置下，该位置从表头计算为列表5/8的位置)，在该位置，列表被分成了如下两个子列表：</p>
<ul>
<li>在头部是最近被访问的新页列表</li>
<li>在尾部是很少被访问的旧页列表</li>
</ul>
<p> <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9kZXYubXlzcWwuY29tL2RvYy9yZWZtYW4vNS43L2VuL2ltYWdlcy9pbm5vZGItYnVmZmVyLXBvb2wtbGlzdC5wbmc?x-oss-process=image/format,png" alt="Content is described in the surrounding text."> </p>
<p>默认情况下，该变种的LRU算法特点如下：</p>
<ul>
<li>Buffer Pool的3/8用于旧页列表</li>
<li>列表的中点事新页列表的尾部和旧页列表的头部相交的边界</li>
<li>当 InnoDB从磁盘读一页数据并放入缓冲池中时，它会将此页插入到列表的中间位置（也就是旧页列表的头部）。发生读页一般是因为用户查询数据，或者InnoDB自动触发的预读（read-ahead）操作。 </li>
<li>读取旧页列表中的数据会让该页变年轻，并将其移动到新页列表的头部。如果是因为用户查询读造成该页被读取，则该页会立即被标识为年轻，并直接移动到新页列表头部。如果该页因为预读被读取，则首次读取该页并放入缓冲池时不会将该页放入新页列表头部，而是放入列表中点，需要再次读取才能使该页被标识为年轻状态，这样是为了避免预读导致的<strong>缓冲池搅动</strong></li>
<li>数据库运行过程中，Buffer Pool中不被访问的页因其他被访问的页的移动或新插入的页而老化向尾部移动，最后到达旧页列表尾部并被移出</li>
</ul>
<h5 id="缓冲池搅动"><a href="#缓冲池搅动" class="headerlink" title="缓冲池搅动"></a>缓冲池搅动</h5><p>预读或者表、索引的扫描都会造成大量数据页被读入缓冲池，这些页可能会在短时间内被读取若干次，然后从此不再访问，因此，数据页的大量插入到新页头部可能会将热点数据迅速老化移除出缓冲池。这种情况叫做缓冲池搅动。为解决该问题，MySQL提供了配置参数<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_old_blocks_time" target="_blank" rel="noopener"><code>innodb_old_blocks_time</code></a>  用来指定该页在放入缓冲池后第一次读之后一定时间内（时间窗口，单位毫秒）读取不会被标识为年轻，也就是不会被移动到列表头部 。</p>
<h5 id="相关参数"><a href="#相关参数" class="headerlink" title="相关参数"></a>相关参数</h5><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_old_blocks_pct" target="_blank" rel="noopener"><code>innodb_old_blocks_pct</code></a> 该参数为旧页列表占LRU列表的百分比，默认为37即3/8，取值范围为[5,95]。</p>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_old_blocks_time" target="_blank" rel="noopener"><code>innodb_old_blocks_time</code></a> 指定第一次访问页面之后的时间窗口（以毫秒为单位），在此期间，可以访问页面，而无需移动页到LRU新页列表的前端。innodb_old_blocks_time的默认值是1000。增加这个值会使越来越多的块从缓冲池中老化得更快。</p>
<h4 id="缓冲池状态监控"><a href="#缓冲池状态监控" class="headerlink" title="缓冲池状态监控"></a>缓冲池状态监控</h4><p>使用InnoDB标准监视器可以监视缓冲池的状态：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW ENGINE INNODB STATUS\G</span><br><span class="line">----------------------</span><br><span class="line">BUFFER POOL AND MEMORY</span><br><span class="line">----------------------</span><br><span class="line">Total large memory allocated 17170432 #分配给缓冲池的内存大小（bytes）</span><br><span class="line">Dictionary memory allocated 352153    #分配给InnoDB数据字典的内存大小（bytes）</span><br><span class="line">Buffer pool size   1024				  #分配给缓冲池的总页数</span><br><span class="line">Free buffers       761				  #缓冲池可用列表的总页数</span><br><span class="line">Database pages     256				  #缓冲池LRU列表的总页数</span><br><span class="line">Old database pages 0				  #缓冲池LRU旧页列表的总页数</span><br><span class="line">Modified db pages  0			 	  #缓冲池中当前修改的页数</span><br><span class="line">Pending reads      0				  #等待读入缓冲池的缓冲池页数</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0 #等待写入磁盘的脏页数</span><br><span class="line">Pages made young 0, not young 0</span><br><span class="line">0.00 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 8439, created 1241, written 34441</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">No buffer pool page gets since the last printout</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 256, unzip_LRU len: 0</span><br><span class="line">I/O sum[0]:cur[0], unzip sum[0]:cur[0]</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Total memory allocated</td>
<td>The total memory allocated for the buffer pool in bytes.</td>
</tr>
<tr>
<td>Dictionary memory allocated</td>
<td>The total memory allocated for the <code>InnoDB</code> data dictionary in bytes.</td>
</tr>
<tr>
<td>Buffer pool size</td>
<td>The total size in pages allocated to the buffer pool.</td>
</tr>
<tr>
<td>Free buffers</td>
<td>The total size in pages of the buffer pool free list.</td>
</tr>
<tr>
<td>Database pages</td>
<td>The total size in pages of the buffer pool LRU list.</td>
</tr>
<tr>
<td>Old database pages</td>
<td>The total size in pages of the buffer pool old LRU sublist.</td>
</tr>
<tr>
<td>Modified db pages</td>
<td>The current number of pages modified in the buffer pool.</td>
</tr>
<tr>
<td>Pending reads</td>
<td>The number of buffer pool pages waiting to be read into the buffer pool.</td>
</tr>
<tr>
<td>Pending writes LRU</td>
<td>The number of old dirty pages within the buffer pool to be written from the bottom of the LRU list.</td>
</tr>
<tr>
<td>Pending writes flush list</td>
<td>The number of buffer pool pages to be flushed during checkpointing.</td>
</tr>
<tr>
<td>Pending writes single page</td>
<td>The number of pending independent page writes within the buffer pool.</td>
</tr>
<tr>
<td>Pages made young</td>
<td>The total number of pages made young in the buffer pool LRU list (moved to the head of sublist of “new” pages).</td>
</tr>
<tr>
<td>Pages made not young</td>
<td>The total number of pages not made young in the buffer pool LRU list (pages that have remained in the “old” sublist without being made young).</td>
</tr>
<tr>
<td>youngs/s</td>
<td>The per second average of accesses to old pages in the buffer pool LRU list that have resulted in making pages young. See the notes that follow this table for more information.</td>
</tr>
<tr>
<td>non-youngs/s</td>
<td>The per second average of accesses to old pages in the buffer pool LRU list that have resulted in not making pages young. See the notes that follow this table for more information.</td>
</tr>
<tr>
<td>Pages read</td>
<td>The total number of pages read from the buffer pool.</td>
</tr>
<tr>
<td>Pages created</td>
<td>The total number of pages created within the buffer pool.</td>
</tr>
<tr>
<td>Pages written</td>
<td>The total number of pages written from the buffer pool.</td>
</tr>
<tr>
<td>reads/s</td>
<td>The per second average number of buffer pool page reads per second.</td>
</tr>
<tr>
<td>creates/s</td>
<td>The per second average number of buffer pool pages created per second.</td>
</tr>
<tr>
<td>writes/s</td>
<td>The per second average number of buffer pool page writes per second.</td>
</tr>
<tr>
<td>Buffer pool hit rate</td>
<td>The buffer pool page hit rate for pages read from the buffer pool memory vs from disk storage.</td>
</tr>
<tr>
<td>young-making rate</td>
<td>The average hit rate at which page accesses have resulted in making pages young. See the notes that follow this table for more information.</td>
</tr>
<tr>
<td>not (young-making rate)</td>
<td>The average hit rate at which page accesses have not resulted in making pages young. See the notes that follow this table for more information.</td>
</tr>
<tr>
<td>Pages read ahead</td>
<td>The per second average of read ahead operations.</td>
</tr>
<tr>
<td>Pages evicted without access</td>
<td>The per second average of the pages evicted without being accessed from the buffer pool.</td>
</tr>
<tr>
<td>Random read ahead</td>
<td>The per second average of random read ahead operations.</td>
</tr>
<tr>
<td>LRU len</td>
<td>The total size in pages of the buffer pool LRU list.</td>
</tr>
<tr>
<td>unzip_LRU len</td>
<td>The total size in pages of the buffer pool unzip_LRU list.</td>
</tr>
<tr>
<td>I/O sum</td>
<td>The total number of buffer pool LRU list pages accessed, for the last 50 seconds.</td>
</tr>
<tr>
<td>I/O cur</td>
<td>The total number of buffer pool LRU list pages accessed.</td>
</tr>
<tr>
<td>I/O unzip sum</td>
<td>The total number of buffer pool unzip_LRU list pages accessed.</td>
</tr>
<tr>
<td>I/O unzip cur</td>
<td>The total number of buffer pool unzip_LRU list pages accessed.</td>
</tr>
</tbody>
</table>
<h4 id="缓冲池配置"><a href="#缓冲池配置" class="headerlink" title="缓冲池配置"></a>缓冲池配置</h4><p>MySQL 官方文档对于缓冲池的相关配置参考：</p>
<p>You can configure the various aspects of the buffer pool to improve performance.</p>
<ul>
<li>Ideally, you set the size of the buffer pool to as large a value as practical, leaving enough memory for other processes on the server to run without excessive paging. The larger the buffer pool, the more <code>InnoDB</code> acts like an in-memory database, reading data from disk once and then accessing the data from memory during subsequent reads. See <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-buffer-pool-resize.html" target="_blank" rel="noopener">Section 14.8.3.1, “Configuring InnoDB Buffer Pool Size”</a>.</li>
<li>On 64-bit systems with sufficient memory, you can split the buffer pool into multiple parts to minimize contention for memory structures among concurrent operations. For details, see <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-multiple-buffer-pools.html" target="_blank" rel="noopener">Section 14.8.3.2, “Configuring Multiple Buffer Pool Instances”</a>.</li>
<li>You can keep frequently accessed data in memory regardless of sudden spikes of activity from operations that would bring large amounts of infrequently accessed data into the buffer pool. For details, see <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-midpoint_insertion.html" target="_blank" rel="noopener">Section 14.8.3.3, “Making the Buffer Pool Scan Resistant”</a>.</li>
<li>You can control when and how to perform read-ahead requests to prefetch pages into the buffer pool asynchronously in anticipation that the pages will be needed soon. For details, see <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-read_ahead.html" target="_blank" rel="noopener">Section 14.8.3.4, “Configuring InnoDB Buffer Pool Prefetching (Read-Ahead)”</a>.</li>
<li>You can control when background flushing occurs and whether or not the rate of flushing is dynamically adjusted based on workload. For details, see <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-buffer-pool-flushing.html" target="_blank" rel="noopener">Section 14.8.3.5, “Configuring Buffer Pool Flushing”</a>.</li>
<li>You can configure how <code>InnoDB</code> preserves the current buffer pool state to avoid a lengthy warmup period after a server restart. For details, see <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-preload-buffer-pool.html" target="_blank" rel="noopener">Section 14.8.3.6, “Saving and Restoring the Buffer Pool State”</a>.</li>
</ul>
<h3 id="变更缓冲（Change-Buffer）"><a href="#变更缓冲（Change-Buffer）" class="headerlink" title="变更缓冲（Change Buffer）"></a>变更缓冲（Change Buffer）</h3><p> [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-IIXmsOIv-1574392220787)(innodb缓存方案和底层存储结构.assets/innodb-change-buffer.png)] </p>
<p>Change buffer的主要目的是将对二级索引的数据操作缓存下来，以此减少二级索引的随机IO，并达到操作合并的效果。 在MySQL5.5之前的版本中，由于只支持缓存insert操作，所以最初叫做insert buffer，只是后来的版本中支持了更多的操作类型缓存，才改叫change buffer 。</p>
<p>当执行插入、更新或删除操作时，会触发与表有关的索引的操作，表的索引也会进行相应的插入、更新或删除，这样会影响到对源表的数据的操作速度。当对表进行DML操作时，非聚集索引的值通常是无序的，如果索引所在的页不在缓冲池中，就需要从磁盘中读取该页到缓冲池中进行更新，然后刷新到磁盘，如果有大量的DML操作，就会产生大量的磁盘随机读取，影响性能。</p>
<p>Change Buffer的作用，就是当变更的二级索引的相关页不在缓冲池中时，将二级索引的更改缓存到Change Buffer区，当该索引的页被加载到缓冲池中时，根据Change Buffer区中的更改对其进行更新合并，更新的页之后被刷新到磁盘。InnoDB主线程在服务器接近空闲时以及在缓慢关闭期间合并缓冲的更改。</p>
<p>通过Change Buffer，可以减少磁盘读写，对于具有大量DML操作的应用程序来说该功能很有用。不过Change Buffer也有弊端，那就是它占用了Buffer Pool的空间，从而减少了缓存数据页的可用内存。</p>
<p><strong>相关配置参数</strong>：</p>
<p> <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_change_buffering" target="_blank" rel="noopener"><code>innodb_change_buffering</code></a> 该参数可以指定哪些操作可以使用change buffer</p>
<p>可选值包含如下：</p>
<ul>
<li><p><strong><code>all</code></strong></p>
<p>缓冲全部操作</p>
</li>
<li><p><strong><code>none</code></strong></p>
<p>不缓存任何操作</p>
</li>
<li><p><strong><code>inserts</code></strong></p>
<p>仅insert操作</p>
</li>
<li><p><strong><code>deletes</code></strong></p>
<p>包含delete标记和update操作（update分两步，删除原有记录，插入新的记录）</p>
</li>
<li><p><strong><code>changes</code></strong></p>
<p>insert和delete标记操作</p>
</li>
<li><p><strong><code>purges</code></strong></p>
<p>缓冲后台进程的物理删除操作</p>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_change_buffer_max_size" target="_blank" rel="noopener"><code>innodb_change_buffer_max_size</code></a>  该参数可以设定change buffer占用缓冲池的百分比最大值，默认值为25，最大可以设置为50。innodb_change_buffer_max_size设置是动态的，允许在不重新启动服务器的情况下修改设置。</p>
</li>
</ul>
<p><strong>Change buffer监控</strong>：</p>
<p>通过以下指令可以监控Change Buffer状态：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW ENGINE INNODB STATUS\G</span><br></pre></td></tr></table></figure>
<p>本地使用MySQL 5.7.19版本，以“ INSERT BUFFER AND ADAPTIVE HASH INDEX ”为标题的输出如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-------------------------------------</span><br><span class="line">INSERT BUFFER AND ADAPTIVE HASH INDEX</span><br><span class="line">-------------------------------------</span><br><span class="line">Ibuf: size 1, free list len 389, seg size 391, 18 merges</span><br><span class="line">merged operations:</span><br><span class="line"> insert 26, delete mark 0, delete 0</span><br><span class="line">discarded operations:</span><br><span class="line"> insert 0, delete mark 0, delete 0</span><br><span class="line">Hash table size 4441, node heap has 1 buffer(s)</span><br><span class="line">Hash table size 4441, node heap has 1 buffer(s)</span><br><span class="line">Hash table size 4441, node heap has 1 buffer(s)</span><br><span class="line">Hash table size 4441, node heap has 1 buffer(s)</span><br><span class="line">Hash table size 4441, node heap has 2 buffer(s)</span><br><span class="line">Hash table size 4441, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 4441, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 4441, node heap has 1 buffer(s)</span><br><span class="line">0.00 hash searches/s, 0.00 non-hash searches/s</span><br></pre></td></tr></table></figure>
<p>seg size显示了当前Change Buffer的大小为391x16KB，约为6.1MB；free list len表示空闲列表的长度；size表示已合并记录页的数量。</p>
<p>可以看到这里显示了merged operations和discarded operations，并且下面具体显示了Change Buffer中每个操作的次数。insert表示insert buffer，delete mark表示delete buffer，delete表示purge buffer；discarded operations表示当Change Buffer发生merge时，表已经被删除，此时就无需将记录合并到二级索引。</p>
<h3 id="日志缓冲（Log-Buffer）"><a href="#日志缓冲（Log-Buffer）" class="headerlink" title="日志缓冲（Log Buffer）"></a>日志缓冲（Log Buffer）</h3><p>日志缓冲是存储要写入磁盘日志文件的数据的内存区域。日志缓冲的数据会定期刷新到磁盘。大的日志缓冲区可以确保大事务无需在事务提交前将重做日志写入磁盘。因此如果应用程序的事务较多，增加日志缓冲区的大小可以减少磁盘的I/O。</p>
<p>相关参数：</p>
<p> <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_log_buffer_size" target="_blank" rel="noopener"><code>innodb_log_buffer_size</code></a> 日志缓冲区大小，默认为16MB，单位是byte</p>
<p> <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_flush_log_at_trx_commit" target="_blank" rel="noopener"><code>innodb_flush_log_at_trx_commit</code></a> 控制如何将日志缓冲区的内容写入并刷新到磁盘</p>
<table>
<thead>
<tr>
<th>value</th>
<th>remark</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>每秒将日志写入并刷新到磁盘一次。未刷新日志的事务可能在崩溃中丢失。</td>
</tr>
<tr>
<td>1（default）</td>
<td>每次事务提交时，日志都会写入并刷新到磁盘。</td>
</tr>
<tr>
<td>2</td>
<td>每次事务提交后都会写入日志，并每秒刷新一次到磁盘。未刷新日志的事务可能在崩溃中丢失。</td>
</tr>
</tbody>
</table>
<p> <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_flush_log_at_timeout" target="_blank" rel="noopener"><code>innodb_flush_log_at_timeout</code></a> 每隔N秒写入并刷新日志。innodb_flush_log_at_timeout允许增加刷新之间的超时时间，以减少刷新频率并避免影响binlog提交的性能。innodb_flush_log_at_timeout的默认设置是每秒一次。取值范围[1,2700]。</p>
<h3 id="查询缓存（-Query-Cache-）"><a href="#查询缓存（-Query-Cache-）" class="headerlink" title="查询缓存（ Query Cache ）"></a>查询缓存（ Query Cache ）</h3><p>【注】从MySQL 5.7.20开始，查询缓存已被弃用，并在MySQL 8.0中被删除。 </p>
<p>查询缓存就是将SELECT语句作为Key（select语句的字节不同则被认为是不同的key），查询结果作为VALUE的形式进行缓存。 如果服务器收到相同的语句，则服务器从查询缓存中检索结果，而不是再次解析并执行该语句。查询缓存在会话之间共享，因此可以响应另一个客户端发出的同一查询。 </p>
<p><strong>缺点：</strong></p>
<ul>
<li>hash性能问题和命中率问题</li>
<li>查询缓存容易失效：当表内容发生变化或者表结构发生变化，INSERT, UPDATE, DELETE, TRUNCATE, ALTER TABLE, DROP TABLE, or DROP DATABASE等操作都会导致表的查询缓存失效</li>
<li>查询缓存中的结果容易产生重复；因为查询缓存中缓存的是查询结果，所以不同的查询的结果很容易重复</li>
<li>查询缓存会增加检查和清理缓存中记录集的开销</li>
<li>SELECT语句不能被缓存的情况<ul>
<li>查询语句中加了SQL_NO_CACHE参数；</li>
<li>查询语句中含有获得值的函数，包涵自定义函数，如：CURDATE()、GET_LOCK()、RAND()、CONVERT_TZ等；</li>
<li>对系统数据库的查询：mysql、information_schema</li>
<li>查询语句中使用SESSION级别变量或存储过程中的局部变量；</li>
<li>查询语句中使用了LOCK IN SHARE MODE、FOR UPDATE的语句</li>
<li>查询语句中类似SELECT …INTO 导出数据的语句；</li>
<li>事务隔离级别为：Serializable情况下，所有查询语句都不能缓存；</li>
<li>对临时表的查询操作；</li>
<li>存在警告信息的查询语句；</li>
<li>不涉及任何表或视图的查询语句；</li>
<li>某用户只有列级别权限的查询语句；</li>
</ul>
</li>
</ul>
<p><strong>适合使用场景：</strong><br>表的读操作非常频繁,而且数据不常更新。 </p>
<h4 id="指定SELECT缓存"><a href="#指定SELECT缓存" class="headerlink" title="指定SELECT缓存"></a>指定SELECT缓存</h4><p>select语句中可以通过 SQL_CACHE 和 SQL_NO_CACHE 指定缓存或不缓存该查询结果</p>
<ul>
<li><p>SQL_CACHE </p>
<p>如果查询结果是可缓存的，并且 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_query_cache_type" target="_blank" rel="noopener"><code>query_cache_type</code></a> 的值是ON或DEMAND，则查询结果将被缓存。</p>
</li>
<li><p>SQL_NO_CACHE </p>
<p>服务器不使用查询缓存。它既不检查查询缓存以查看结果是否已缓存，也不缓存查询结果。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT SQL_CACHE id, name FROM customer;</span><br><span class="line">SELECT SQL_NO_CACHE id, name FROM customer;</span><br></pre></td></tr></table></figure>
<h4 id="相关参数-1"><a href="#相关参数-1" class="headerlink" title="相关参数"></a>相关参数</h4><p> <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_have_query_cache" target="_blank" rel="noopener"><code>have_query_cache</code></a> 查询缓存是否可用</p>
<p> <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_query_cache_size" target="_blank" rel="noopener"><code>query_cache_size</code></a> 查询缓存的大小，默认为1048576bytes，即1MB</p>
<p> <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_query_cache_type" target="_blank" rel="noopener"><code>query_cache_type</code></a> 查询缓存的类型</p>
<table>
<thead>
<tr>
<th>value</th>
<th>remark</th>
</tr>
</thead>
<tbody>
<tr>
<td>OFF</td>
<td>关闭缓存</td>
</tr>
<tr>
<td>ON</td>
<td>启用缓存，但以SELECT SQL_NO_CACHE开头的语句除外</td>
</tr>
<tr>
<td>DEMAND</td>
<td>启用缓存，只缓存以SELECT SQL_CACHE开头的语句</td>
</tr>
</tbody>
</table>
<h4 id="状态监控"><a href="#状态监控" class="headerlink" title="状态监控"></a>状态监控</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW STATUS LIKE &apos;Qcache%&apos;;</span><br><span class="line">+-------------------------+---------+</span><br><span class="line">| Variable_name           | Value   |</span><br><span class="line">+-------------------------+---------+</span><br><span class="line">| Qcache_free_blocks      | 1       | #缓存中相邻内存块的个数</span><br><span class="line">| Qcache_free_memory      | 1031872 | #缓存中的空闲内存</span><br><span class="line">| Qcache_hits             | 0       | #查询在缓存中命中次数</span><br><span class="line">| Qcache_inserts          | 0       | #插入查询缓存次数</span><br><span class="line">| Qcache_lowmem_prunes    | 0       | #内存不足并且必须要进行清理以便为更多查询缓存提供空间的次数</span><br><span class="line">| Qcache_not_cached       | 14188   | #不适合进行缓存的查询的数量</span><br><span class="line">| Qcache_queries_in_cache | 0       | #当前缓存的查询的数量</span><br><span class="line">| Qcache_total_blocks     | 1       | #缓存中块的数量</span><br><span class="line">+-------------------------+---------+</span><br></pre></td></tr></table></figure>
<h2 id="InnoDB存储结构"><a href="#InnoDB存储结构" class="headerlink" title="InnoDB存储结构"></a>InnoDB存储结构</h2><h3 id="逻辑存储结构"><a href="#逻辑存储结构" class="headerlink" title="逻辑存储结构"></a>逻辑存储结构</h3><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-pzoix7WO-1574392220792)(innodb缓存方案和底层存储结构.assets/image-20191120111018106.png)]</p>
<p>InnoDB的逻辑存储结构如上，所有数据都被逻辑地存储在表空间中，其中表空间又由段（segment）、区（extent）、页（page）组成，在一些文档中页也被称为块（block）。</p>
<h4 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h4><p>InnoDB存储引擎中所有数据都是存储在表空间中</p>
<p><strong>系统表空间</strong></p>
<p>系统表空间以ibdata1命名，在安装数据库初始化数据时就是系统在创建一个ibdata1的表空间文件，它会存储所有数据的信息以及回滚段（undo）的信息。MySQL5.6之后，undo表空间可以通过参数单独设置存储位置。</p>
<p><strong>独立表空间</strong></p>
<p>设置参数innodb_file_per_table=1可以使每张表都有一个独立的表空间文件，而不用存储在ibdata1中。值得注意的是独立表空间存放的是B+树数据、索引和插入缓冲等信息，其他数据还是存放在ibdata1中。目前默认使用的就是独立表空间的存储方式。</p>
<p><strong>临时表空间</strong></p>
<p>MySQL5.7把临时表的数据从系统表空间中抽离出来，形成自己的独立表空间，并把临时表的相关检索信息保存在系统信息表的information_schema库下的innodb_temp_table_info表中。</p>
<p><strong>通用表空间</strong></p>
<p>与系统表空间类似，通用表空间是可以存储多个表的数据的共享表空间。多个表放在同一个表空间中，可以减少存储开销。</p>
<h4 id="段"><a href="#段" class="headerlink" title="段"></a>段</h4><p>表空间由段组成，常见的段有数据段，回滚段，索引段等。因为InnoDB表是索引组织的，所以索引即数据，数据即索引，数据段就是B+树的叶子节点（Leaf node segment），索引段即B+树的非叶子节点（Non-leaf node segment）。</p>
<h4 id="区"><a href="#区" class="headerlink" title="区"></a>区</h4><p>区由连续的页组成，是物理上连续的一块空间，每个区的大小固定是1MB。</p>
<h4 id="页"><a href="#页" class="headerlink" title="页"></a>页</h4><p>页是InnoDB最小的的物理存储分配单位，有数据页和回滚页等。一般情况下，一个区由64个页组成，页的默认大小是16KB。从MySQL5.6开始可以自定义调低页的大小为8KB、4KB，MySQL5.7开始可以调高页的大小为32KB或64KB。 </p>
<h4 id="行"><a href="#行" class="headerlink" title="行"></a>行</h4><p>InnoDB引擎是面向列的（row-oriented），也就是说数据是按行进行存储的。每个页存放的行记录按照行格式进行存放。</p>
<h3 id="行记录格式"><a href="#行记录格式" class="headerlink" title="行记录格式"></a>行记录格式</h3><p>在InnoDB 1.0.X之前，InnoDB存储引擎提供了Compact和Redundant两种格式来存放行记录数据。Redundant是mysql5.0版本之前的行记录存储方式，之后仍然支持这个格式是为了兼容之前版本的格式，5.1之后很少用到了，因为Compact的结构设计比它好，因为compact格式消耗的磁盘空间和备份耗时更小，Redundant相比之下大了一些。compact格式更适用于大多数的业务场景。</p>
<p>在InnoDB 1.0.X版本开始又引入了新的文件格式(file format)，以前支持Compact和Redundant格式称为Antelope文件格式，新引入的文件格式称为Barracuda文件格式。Barracuda文件格式下拥有两种新的行记录格式：Compressed和Dynamic，同时，Barracuda文件格式也包括了Antelope所有的文件格式。</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-qaxXMUuQ-1574392220797)(innodb缓存方案和底层存储结构.assets/image-20191120150117896.png)]</p>
<p>可以通过如下命令查看表的行格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show table status like &apos;%iot_linkage_info%&apos;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           Name: iot_linkage_info</span><br><span class="line">         Engine: InnoDB</span><br><span class="line">        Version: 10</span><br><span class="line">     Row_format: Dynamic # 这行Row_format表示的就是行记录的格式</span><br><span class="line">           Rows: 22</span><br><span class="line"> Avg_row_length: 744</span><br><span class="line">    Data_length: 16384</span><br><span class="line">Max_data_length: 0</span><br><span class="line">   Index_length: 65536</span><br><span class="line">      Data_free: 0</span><br><span class="line"> Auto_increment: 77</span><br><span class="line">    Create_time: 2019-11-11 15:41:51</span><br><span class="line">    Update_time: 2019-11-15 15:12:52</span><br><span class="line">     Check_time: NULL</span><br><span class="line">      Collation: utf8mb4_general_ci</span><br><span class="line">       Checksum: NULL</span><br><span class="line"> Create_options: row_format=DYNAMIC</span><br><span class="line">        Comment:</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>MySQL5.7默认使用dynamic行记录格式和Barracuda文件格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;%innodb_file%&apos;;</span><br><span class="line">+--------------------------+-----------+</span><br><span class="line">| Variable_name            | Value     |</span><br><span class="line">+--------------------------+-----------+</span><br><span class="line">| innodb_file_format       | Barracuda |</span><br><span class="line">| innodb_file_format_check | ON        |</span><br><span class="line">| innodb_file_format_max   | Barracuda |</span><br><span class="line">| innodb_file_per_table    | ON        |</span><br><span class="line">+--------------------------+-----------+</span><br><span class="line">4 rows in set, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &apos;%row_format%&apos;;</span><br><span class="line">+---------------------------+---------+</span><br><span class="line">| Variable_name             | Value   |</span><br><span class="line">+---------------------------+---------+</span><br><span class="line">| innodb_default_row_format | dynamic |</span><br><span class="line">+---------------------------+---------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>Dynamic和Compact基本是类似的，但是它们在行溢出数据的处理上却完全不同，这里我们需要先了解一下行溢出的概念。行溢出就是将需要存储的数据存储在当前页面之外，拆分到多个页进行存储，针对大数据类型text或blob字段类型的数据。</p>
<p>dynamic将数据都存放在溢出的页中（off-page），而数据页只存储前20个字节的指针。在Compact格式下，溢出的列只存放768个前缀字节。dynamic这种行格式模式针对溢出列所在的新页利用率会更高，所以生产环境中建议使用dynamic。</p>
<p>Dynamic格式的行溢出处理：</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-MBmqC6eY-1574392220801)(innodb缓存方案和底层存储结构.assets/image-20191120173440319.png)]</p>
<p>Compact格式的行溢出处理：</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-xjaamQy1-1574392220805)(innodb缓存方案和底层存储结构.assets/image-20191120173351771.png)]</p>
<p>Redundant是最早的行记录格式，相比compact要消耗更多空间，不建议使用；Compressed是压缩行格式，对数据和索引页进行压缩，但只是针对物理存储层面的压缩，在内存中是不压缩的，所以当数据读取内存中就需要转换，会增加了CPU消耗，而且效率也低，压缩比例只接近1/2，压缩带来的负面影响也大，数据库的TPS会下降，影响线上业务。</p>
<h3 id="数据页结构"><a href="#数据页结构" class="headerlink" title="数据页结构"></a>数据页结构</h3><p>页是InnoDB存储引擎管理数据库的最小磁盘单位。页类型为B-tree Node的页存放的就是表中行的实际数据，下图为页的结构：</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-QSi3BukE-1574392220807)(innodb缓存方案和底层存储结构.assets/image-20191120152625275.png)]</p>
<p>InnoDB数据页由七个部分组成，其中File Header、Page Header、File Trailer的大小是固定的，这些空间用来标记页的一些信息。User Records、Free Space和Page Directory为实际的行记录存储空间，因此大小是动态的。</p>
<h4 id="File-Header"><a href="#File-Header" class="headerlink" title="File Header"></a>File Header</h4><p>File Header用于记录页的头信息，大小为38个字节，组成部分如下：</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-g2Cpdd9t-1574392220809)(innodb缓存方案和底层存储结构.assets/image-20191120153417851.png)]</p>
<p>InnoDB存储引擎中页的类型：</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-RLCBjRNR-1574392220811)(innodb缓存方案和底层存储结构.assets/image-20191120153750560.png)]</p>
<h4 id="Page-Header"><a href="#Page-Header" class="headerlink" title="Page Header"></a>Page Header</h4><p>Page Header用来记录数据页的状态信息，由14个部分组成，共占用56个字节：</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-TTMx91UL-1574392220813)(innodb缓存方案和底层存储结构.assets/image-20191120154133018.png)]</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-4wKw1slx-1574392220818)(innodb缓存方案和底层存储结构.assets/image-20191120154150903.png)]</p>
<h4 id="Infimum和Suprenum-Record"><a href="#Infimum和Suprenum-Record" class="headerlink" title="Infimum和Suprenum Record"></a>Infimum和Suprenum Record</h4><p>InnoDB的每个数据页都有两个虚拟的行记录虚拟最小行（Infimum records）和虚拟最大行（Supremum records），用来限定记录的边界：</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-M6qk3xnn-1574392220820)(innodb缓存方案和底层存储结构.assets/image-20191120154754662.png)]</p>
<h4 id="User-Record和Free-Space"><a href="#User-Record和Free-Space" class="headerlink" title="User Record和Free Space"></a>User Record和Free Space</h4><p>User Record是实际存储行记录的内容。Free Space是空闲空间，是链表的数据结构。在一条记录被删除后，该空间会被加入到空闲链表中。</p>
<h4 id="Page-Directory"><a href="#Page-Directory" class="headerlink" title="Page Directory"></a>Page Directory</h4><p>Page Directory存放了记录的相对位置。</p>
<h4 id="File-Trailer"><a href="#File-Trailer" class="headerlink" title="File Trailer"></a>File Trailer</h4><p>InnoDB利用File Trailer来保证页完整地写入磁盘。File Trailer只有一个FIL_PAGE_END_LSN部分，占用8个字节，前4个字节代表该页的checksum值，后4个字节和File Header中的FIL_PAGE_LSN相同。通过将这两个值与File Header中的FIL_PAGE_SPACE_OR_CHECKSUM和FIL_PAGE_LSN值进行比较是否一致来保证页的完整性（checksum不是等值比较，需要用到InnoDB的checksum函数进行比较）。</p>
<h2 id="会议疑问点"><a href="#会议疑问点" class="headerlink" title="会议疑问点"></a>会议疑问点</h2><ol>
<li><p>Infimum和Suprenum Record怎么保证B+tree节点是双向链表结构？</p>
<p>关于这两个概念，官网有做介绍 <a href="https://dev.mysql.com/doc/internals/en/innodb-infimum-and-supremum-records.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/internals/en/innodb-infimum-and-supremum-records.html</a> 。Infimum和Suprenum Record用来限定记录的边界，Infimum是比页中任何主键值都要小的值，Suprenum 是指比任何可能大值还要大的值，这两个值在页创建时被建立，并且在任何情况下都不会被删除。Infimum和Suprenum与行记录组成单链表结构，查询记录时，从Infimum开始查找，如果找不到结果会直到查到最后的suprenum为止，然后通过Page Header中的FIL_PAGE_NEXT指针跳转到下一个page继续从Infimum开始逐个查找 </p>
<p> <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2ltZy9iVkoxaFM?x-oss-process=image/format,png" alt="clipboard.png"> </p>
</li>
</ol>
<p>所以原文档说的Infimum和Suprenum Record保证B+tree节点是双向链表结构应该是不对的，应该是保证节点内部记录的结构是单链表结构</p>
<ol start="2">
<li>关于脏页的刷新机制Checkpoint</li>
</ol>
<p>缓冲池设计目的是为了协调CPU速度和磁盘速度的鸿沟，页的操作首先都是在缓冲池中完成的，如果一条DML语句改变了页中的记录，那么此时页是脏的，即缓冲池中的页的版本要比磁盘的新，数据库需要将新版本的页从缓冲池刷新到磁盘，如果页每次发生改变都要将其刷新到磁盘，并且热点数据集中在几个页中，那么数据库的性能就会变得很差，InnoDB使用了一些机制来避免这种问题。</p>
<p>InnoDB采用Write Ahead Log策略来防止宕机数据丢失，即事务提交时，先写重做日志，再修改内存数据页，这样就产生了脏页，由于重做日志不可能无限大，缓冲池也不可能无限大，所以脏页需要刷新到磁盘，另外如果重做日志太大，宕机的时候也会使重做全部日志恢复的时间过长。InnoDB为了避免这些问题，使用checkpoint技术来使数据库宕机时只需要重做上次checkpiont之后的日志。</p>
<p>checkpoint主要解决以下问题：</p>
<ul>
<li>缩短数据库恢复时间</li>
<li>缓冲池不可用时，将脏页刷新到磁盘</li>
<li>重做日志不可用时，将脏页刷新到磁盘</li>
</ul>
<p>Checkpoint分为两种：</p>
<ul>
<li><p><strong>Sharp Checkpoint</strong></p>
<p>发生在数据库关闭的时候将所有脏页刷新到磁盘，这是默认的工作方式，即参数innodb_fast_shutdown=1</p>
</li>
<li><p><strong>Fuzzy Checkpoint</strong></p>
<p>数据库运行过程中使用的是Fuzzy checkpoint进行页的刷新，即只刷新一部分脏页，而不是刷新所有脏页。</p>
<p>Fuzzy Checkpoint中包含几种情况：</p>
<ul>
<li><p><strong>Master Thread Checkpoint</strong></p>
<p>master thread是后台线程中的主线程，内部的flush loop刷新循环中会执行每秒或每十秒将缓冲池中的脏页列表中刷新一定比例的页回磁盘，这个过程是异步的，不会阻塞用户的查询线程。</p>
</li>
<li><p><strong>FLUSH_LRU_LIST Checkpoint</strong></p>
<p>因为InnoDB存储引擎需要保证LRU列表中需要有差不多100个空闲页可供使用。在InnoDB1.1.x版本之前，需要检查LRU列表中是否有足够的可用空间操作发生在用户查询线程中，显然这会阻塞用户的查询操作。倘若没有100个可用空闲页，那么InnoDB存储引擎会将LRU列表尾端的页移除。如果这些页中有脏页，那么需要进行Checkpoint，而这些页是来自LRU列表的，因此称为FLUSH_LRU_LIST Checkpoint。</p>
<p>而从MySQL 5.6版本，也就是InnoDB1.2.x版本开始，这个检查被放在了一个单独的Page Cleaner线程中进行，并且用户可以通过参数innodb_lru_scan_depth控制LRU列表中可用页的数量，该值默认为1024，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW GLOBAL VARIABLES LIKE &apos;innodb_lru_scan_depth&apos;;</span><br><span class="line">+-----------------------+-------+</span><br><span class="line">| Variable_name         | Value |</span><br><span class="line">+-----------------------+-------+</span><br><span class="line">| innodb_lru_scan_depth | 1024  |</span><br><span class="line">+-----------------------+-------+</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Async/Sync Flush Checkpoint</strong> </p>
<p>指的是重做日志文件不可用的情况，这时需要强制将一些页刷新回磁盘。重做日志不可用的情况是因为当前事务数据库系统对重做日志的设计都是循环使用的，并不是让其无限增大，因为无限增大会造成成本和管理的问题。重做日志可以被重用的部分是指这些重做日志已经不需要在数据库恢复时使用到，可以这样理解，重做日志中的操作已经刷新到磁盘，所以数据库也就在恢复时可以将这部分覆盖重用。但是若此时重做日志还需使用，那就必须强制产生Checkpoint，将缓冲池中的页至少刷新到当前重做日志的位置。</p>
</li>
<li><p><strong>Dirty Page too much</strong> </p>
<p>即脏页的数量太多，导致InnoDB存储引擎强制进行Checkpoint。其目的总的来说还是为了保证缓冲池中有足够可用的页。其可由参数innodb_max_dirty_pages_pct控制, innodb_max_dirty_pages_pct值为75表示当缓冲池中脏页的数量占据75%时，强制进行Checkpoint，刷新一部分的脏页到磁盘。在InnoDB 1.0.x版本之前，该参数默认值为90，之后的版本都为75。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW GLOBAL VARIABLES LIKE &apos;innodb_max_dirty_pages_pct;</span><br><span class="line">+----------------------------+-------+</span><br><span class="line">| Variable_name              | Value |</span><br><span class="line">+----------------------------+-------+</span><br><span class="line">| innodb_max_dirty_pages_pct | 75    |</span><br><span class="line">+----------------------------+-------+</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ol start="3">
<li><p>关于Change buffer的一些常见问题官网文档有详细解答：</p>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/faqs-innodb-change-buffer.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/faqs-innodb-change-buffer.html</a> </p>
</li>
<li><p>查询缓存为什么在8.0被删除的原因，MySQL开发者 <a href="https://mysqlserverteam.com/author/matt-lord/" target="_blank" rel="noopener">Matt Lord</a> 在这篇博客中有做说明：</p>
<p><a href="https://mysqlserverteam.com/mysql-8-0-retiring-support-for-the-query-cache/" target="_blank" rel="noopener">https://mysqlserverteam.com/mysql-8-0-retiring-support-for-the-query-cache/</a> </p>
</li>
</ol>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>InnoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis单线程模型</title>
    <url>/2019/10/23/Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h1 id="Redis单线程模型解析"><a href="#Redis单线程模型解析" class="headerlink" title="Redis单线程模型解析"></a>Redis单线程模型解析</h1><h2 id="什么是Redis"><a href="#什么是Redis" class="headerlink" title="什么是Redis"></a>什么是Redis</h2><p>Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 <a href="http://www.redis.cn/topics/data-types-intro.html#strings" target="_blank" rel="noopener">字符串（strings）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#hashes" target="_blank" rel="noopener">散列（hashes）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#lists" target="_blank" rel="noopener">列表（lists）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#sets" target="_blank" rel="noopener">集合（sets）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#sorted-sets" target="_blank" rel="noopener">有序集合（sorted sets）</a> 与范围查询， <a href="http://www.redis.cn/topics/data-types-intro.html#bitmaps" target="_blank" rel="noopener">bitmaps</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#hyperloglogs" target="_blank" rel="noopener">hyperloglogs</a> 和 <a href="http://www.redis.cn/commands/geoadd.html" target="_blank" rel="noopener">地理空间（geospatial）</a> 索引半径查询。 Redis 内置了 <a href="http://www.redis.cn/topics/replication.html" target="_blank" rel="noopener">复制（replication）</a>，<a href="http://www.redis.cn/commands/eval.html" target="_blank" rel="noopener">LUA脚本（Lua scripting）</a>， <a href="http://www.redis.cn/topics/lru-cache.html" target="_blank" rel="noopener">LRU驱动事件（LRU eviction）</a>，<a href="http://www.redis.cn/topics/transactions.html" target="_blank" rel="noopener">事务（transactions）</a> 和不同级别的 <a href="http://www.redis.cn/topics/persistence.html" target="_blank" rel="noopener">磁盘持久化（persistence）</a>， 并通过 <a href="http://www.redis.cn/topics/sentinel.html" target="_blank" rel="noopener">Redis哨兵（Sentinel）</a>和自动 <a href="http://www.redis.cn/topics/cluster-tutorial.html" target="_blank" rel="noopener">分区（Cluster）</a>提供高可用性（high availability）。</p><a id="more"></a>
<h2 id="Redis的单线程模型"><a href="#Redis的单线程模型" class="headerlink" title="Redis的单线程模型"></a>Redis的单线程模型</h2><p>Redis的单线程模型采用非阻塞IO多路复用的机制，使用单线程轮训监控与客户端的socket连接，监控socket命令所形成的AE_READABLE。拿到命令不直接执行，而是放入队列中，一个一个执行，不会有并发问题。<br><img src="https://img-blog.csdnimg.cn/20191025002114613.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM5OTc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="单线程的Redis为什么这么快？"><a href="#单线程的Redis为什么这么快？" class="headerlink" title="单线程的Redis为什么这么快？"></a>单线程的Redis为什么这么快？</h2><ul>
<li>纯内存操作，查找和操作的时间复杂度都是O(1)</li>
<li>单线程操作，避免了频繁的上下文切换，而多线程切换会涉及到锁以及消耗更多CPU</li>
<li>采用非阻塞IO多路复用机制：内部采用epoll+自己实现的简单事件框架。在epoll中的读，写，关闭，连接都转化成了事件，然后利用epoll的多路复用机制，绝不在IO上浪费一点时间</li>
<li>数据结构简单，对数据操作也简单</li>
<li><h2 id="Redis为什么是单线程的？"><a href="#Redis为什么是单线程的？" class="headerlink" title="Redis为什么是单线程的？"></a>Redis为什么是单线程的？</h2>官方答案：<br>因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。</li>
</ul>
<h2 id="如果CPU成为Redis的瓶颈怎么办？"><a href="#如果CPU成为Redis的瓶颈怎么办？" class="headerlink" title="如果CPU成为Redis的瓶颈怎么办？"></a>如果CPU成为Redis的瓶颈怎么办？</h2><p>可以考虑多起几个Redis进程，只要客户端分清楚哪些数据在哪个Redis进程就可以了。使用redis-cluster更好。</p>
<h2 id="单线程处理的缺点？"><a href="#单线程处理的缺点？" class="headerlink" title="单线程处理的缺点？"></a>单线程处理的缺点？</h2><p>无法发挥CPU的多核性能，不过可以通过在单机开多个Redis实例来完善。</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka学习</title>
    <url>/2019/10/22/Kafka%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><table>
<thead>
<tr>
<th>资料名称</th>
<th>来源地址</th>
</tr>
</thead>
<tbody>
<tr>
<td>Kafka官方文档</td>
<td><a href="http://kafka.apache.org/intro" target="_blank" rel="noopener">http://kafka.apache.org/intro</a></td>
</tr>
<tr>
<td>《Kafka技术内幕》</td>
<td>图书</td>
</tr>
<tr>
<td>《Kafka、RabbitMQ、RocketMQ等消息中间件的对比 —— 消息发送性能和优势》</td>
<td><a href="https://yq.aliyun.com/articles/475265?spm=a2c4e.11153940.0.0.26dc794fkRn404" target="_blank" rel="noopener">https://yq.aliyun.com/articles/475265?spm=a2c4e.11153940.0.0.26dc794fkRn404</a></td>
</tr>
</tbody>
</table><a id="more"></a>
<h2 id="1-Kafka介绍"><a href="#1-Kafka介绍" class="headerlink" title="1. Kafka介绍"></a>1. Kafka介绍</h2><p>Kafka是一种高吞吐量的分布式发布订阅消息系统，也是一个流式数据处理平台，具有高性能、持久化、多副本备份、横向扩展能力。Kafka最初由LinkedIn公司开发的，之后成为Apache项目的一部分。具备下面三个特点：</p>
<ul>
<li>类似消息系统，提供事件流的发布和订阅，即具备数据注入功能</li>
<li>存储时间流数据的节点具有故障容错的特点，即具备数据存储功能</li>
<li>能够对实时的事件流进行流式的处理和分析，即具备流处理功能</li>
</ul>
<h3 id="1-1-基础架构和术语"><a href="#1-1-基础架构和术语" class="headerlink" title="1.1 基础架构和术语"></a>1.1 基础架构和术语</h3><p><img src="https://img-blog.csdnimg.cn/20191026190732259.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM5OTc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>Producer：</strong>发布消息的对象称为生产者</p>
<p><strong>Consumer：</strong>订阅消息并处理发布的消息的种子的对象称为消费者</p>
<p><strong>Consumer Group</strong>：我们可以将多个消费者组成一个消费者组，在kafka的设计中同一个分区的数据只能被消费者组中的某一个消费者消费。同一个消费者组的消费者可以消费同一个topic的不同分区的数据，这也是为了提高kafka的吞吐量</p>
<p><strong>Kafka cluster ：</strong>已发布的消息保存在一组服务器中，称之为Kafka集群</p>
<p><strong>Broker：</strong>Kafka集群中的每一个服务器都是一个代理(Broker). 消费者可以订阅一个或多个主题（topic），并从Broker拉数据，从而消费这些已发布的消息。</p>
<p><strong>Topic</strong>：消息的主题，可以理解为消息的分类，kafka的数据就保存在topic。在每个broker上都可以创建多个topic</p>
<p><strong>Partition：</strong>Topic的分区，每个topic可以有多个分区，分区的作用是做负载，提高kafka的吞吐量。同一个topic在不同的分区数据是不重复的，partition的表现形式就是一个一个的文件夹</p>
<p><strong>Replication：</strong>每一个分区都有多个副本，副本的作用是做备胎。当主分区（Leader）故障的时候会选择一个备胎（Follower）上位，成为Leader。在kafka中默认副本的最大数量是10个，且副本的数量不能大于Broker的数量，follower和leader绝对是在不同的机器，同一机器对同一个分区也只可能存放一个副本（包括自己）。</p>
<p><strong>Zookeeper</strong>：kafka集群依赖zookeeper来保存集群的的元信息，来保证系统的可用性</p>
<p><strong>AR ( Assigned Replicas)：</strong>分区中的所有副本合集</p>
<p><strong>ISR(In-Sync Replicas)：</strong>所有与leader 副本保持一定程度同步的副本（包括leader 副本在内〕组成 , ISR 集合是AR 集合中的一个子集</p>
<p><strong>OSR ( Out-of-Sync Replicas )：</strong>与leader 副本同步滞后过多的副本</p>
<p><strong>ISR = leader + 没有落后太多的副本</strong></p>
<p><strong>AR = OSR+ ISR;</strong></p>
<h2 id="2-Kafka三大角色"><a href="#2-Kafka三大角色" class="headerlink" title="2. Kafka三大角色"></a>2. Kafka三大角色</h2><ul>
<li><p><strong>消息系统</strong></p>
<p>Kafka和传统的消息系统（也称作消息中间件）都具备系统解耦、冗余存储、流量削峰、缓冲、异步通信、扩展性、可恢复性等功能。与此同时， Kafka 还提供了大多数消息系统难以实现的<strong>消息顺序性保障及回溯消费</strong>的功能。</p>
</li>
<li><p><strong>存储系统</strong></p>
<p>Kafka 把<strong>消息持久化到磁盘</strong>，相比于其他基于内存存储的系统而言，有效地降低了数据丢失的风险。也正是得益于Kafka 的消息持久化功能和多副本机制，我们可以把Kafka 作为长期的数据存储系统来使用，只需要把对应的数据保留策略设置为“永久”或启用主题的日志压缩功能即可。</p>
</li>
<li><p><strong>流式处理平台</strong></p>
<p>Kafka 不仅为每个流行的流式处理框架提供了可靠的数据来源，还提供了一个完整的<strong>流式处理类库</strong>，比如窗口、连接、变换和聚合等各类操作。</p>
</li>
</ul>
<h2 id="3-消息系统"><a href="#3-消息系统" class="headerlink" title="3. 消息系统"></a>3. 消息系统</h2><h3 id="3-1-消费模式"><a href="#3-1-消费模式" class="headerlink" title="3.1 消费模式"></a>3.1 消费模式</h3><ul>
<li><p><strong>点对点模式</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20191026190519906.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM5OTc0Ng==,size_16,color_FFFFFF,t_70" alt></p>
<p>点对点模式通常是基于拉取或者轮询的消息传送模型，这个模型的特点是发送到队列的消息被一个且只有一个消费者进行处理。生产者将消息放入消息队列后，由消费者主动的去拉取消息进行消费。点对点模型的的优点是消费者拉取消息的频率可以由自己控制。但是消息队列是否有消息需要消费，在消费者端无法感知，所以在消费者端需要额外的线程去监控。</p>
</li>
<li><p><strong>发布订阅模式</strong></p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20191026190624926.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM5OTc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>  在该模式下生产者将消息发送到消息队列后，队列会将消息推送给订阅过该类消息的消费者。由于消费者被动接收推送，所以无需轮询队列是否有待消费的消息。但是consumer1、consumer2、consumer3由于机器性能不一样，所以处理消息的能力也会不一样，但消息队列却无法感知消费者消费的速度，所以推送的速度成了发布订阅模模式的一个问题，假设三个消费者处理速度分别是8M/s、5M/s、2M/s，如果队列推送的速度为5M/s，则consumer3无法承受，如果队列推送的速度为2M/s，则consumer1、consumer2会出现资源的极大浪费。</p>
<p>  <strong>Kafka同时支持这两种模式</strong>：</p>
<ul>
<li>如果所有的消费者都隶属于同一个消费组，那么所有的消息都会被均衡地投递给每一个消费者，即每条消息只会被一个消费者处理，这就相当于点对点模式的应用。</li>
<li>如果所有的消费者都隶属于不同的消费组，那么所有的消息都会被广播给所有的消费者，即每条消息会被所有的消费者处理，这就相当于发布／订阅模式的应用。</li>
</ul>
<h3 id="3-3-消费模型"><a href="#3-3-消费模型" class="headerlink" title="3.3 消费模型"></a>3.3 消费模型</h3><p>消息由生产者发布到Kafka集群后，会被消费者消费。</p>
<p>这里介绍下两种消费模型：推送（push）模型和拉取（pull）模型。</p>
<h4 id="3-3-1-推送模型"><a href="#3-3-1-推送模型" class="headerlink" title="3.3.1 推送模型"></a>3.3.1 推送模型</h4><p>基于推送模型的消息系统，由消息代理将消息推送给消费者。消费者的消费状态由代理服务器记录，消息代理服务器将消息发送给消费者后，将这这条消息标记为已消费，但这种方式无法很好报这个消息的处理语义。比如消息发出去后，当消费进程挂掉或者由于网络原因没有收到这条消息时，就有可能造成消息丢失问题（因为消息代理已经把这条消息标记为已消费了，但实际上这条消息并没有被实际处理）。如果要保证消息的处理语义，消息代理发送完消息后，要设置状态为已发送，只有收到消费者的确认请求后才更新为已消费，这就需要消息代理中记录所有消息的消费状态，这种做法也是不可取的。</p>
<p>####　3.3.2 拉取模型</p>
<p><strong>Kafka采用拉取模型</strong>。拉取模型中由消费者自己记录消费状态，每个消费者互相独立地顺序读取每个分区的消息，消费进度由消费者自由控制，可以重新处理之前消费过的消息或从当前时刻开始消费。</p>
<h3 id="3-2-分区模型"><a href="#3-2-分区模型" class="headerlink" title="3.2 分区模型"></a>3.2 分区模型</h3><p>在Kafka中的每一条消息都有一个topic（主题）。一般来说在我们应用中产生不同类型的数据，都可以设置不同的主题。一个主题一般会有多个消息的订阅者，当生产者发布消息到某个主题时，订阅了这个主题的消费者都可以接收到生产者写入的新消息。</p>
<p>Kafka的消息通过主题进行分类，主题类似于关系型数据库中的表或文件系统的中的文件夹。一个主题可以被分为多个分区，然后每个分区的消息以先进先出的顺序读取。</p>
<p>分区的目的：</p>
<ol>
<li><strong>方便扩展</strong>：因为一个主题可以有多个分区，所以可以通过扩展机器增加分区去轻松应对日益增长的数据量。</li>
<li><strong>提高并发</strong>：以分区为读写单位，可以多个消费者同时消费数据，提高了消息的处理效率。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20191026190810854.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM5OTc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>如上图，每个分区的每条消息都有一个称为offset的顺序ID号，该ID唯一地标识分区中的每个记录。当生产者产生新消息发布到broker时，每条消息追加到分区中，顺序写入磁盘，保证分区内消息顺序。</p>
<p><img src="https://img-blog.csdnimg.cn/20191026190827171.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM5OTc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>分区消息的读取由消费者控制，通常每个消费者都会保存当前消费的消息的偏移量，在每次消费时将这个偏移量不断增加，所以消费者可以自由控制消息读取的位置，重新处理以前的旧数据或跳到最近的记录开始消费，并且不会对其他消费者产生影响。</p>
<p>分区中各偏移量位置：</p>
<p><img src="https://img-blog.csdnimg.cn/20191026190841726.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM5OTc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>HW(High Watermark)</strong>：它标识了一个特定的消息偏移量（ offset ），消费者只能拉取到这个offset 之前的消息</p>
<p><strong>LEO(Log End Offset)</strong>：它标识当前日志文件中下一条待写入消息的offset，LEO 的大小相当于当前日志分区中最后一条消息的offset值加1 。分区ISR 集合中的每个副本都会维护自身的LEO</p>
<p><strong>LSO(Log Start Offset)：</strong>它标识当前日志文件起始的offset</p>
<p>上图表示一个分区的日志文件，当前有8条消息，第一条消息的offset（LogStartOffset）为0，最后一条消息offset为7，用虚线表示的offset为8的消息代表下一条待写入的消息。</p>
<h3 id="3-3-多副本架构"><a href="#3-3-多副本架构" class="headerlink" title="3.3 多副本架构"></a>3.3 多副本架构</h3><p>Kafka为分区提供了多副本机制，通过副本机制来保证容灾能力。副本的职责就是同步数据：从leader副本中同步消息，其他副本叫follower，之间是一主多从的关系。leader负责处理消息的读和写请求，follower负责同步leader上的消息数据。副本处于不同的Broker中，当leader挂掉，从ISR的follower副本中重新选举新的副本作为leader。Kafka 通过多副本机制实现了<strong>故障的自动转移</strong>，当Kafka 集群中某个broker 失效时仍然能保证服务可用。</p>
<p>基于多副本架构，下面分析一下ISR集合和HW、LEO关系：</p>
<p>某分区有三个副本，一个leader和两个follower，HW和LEO都是3，此时生产者发送消息3和消息4后存入leader副本：</p>
<p><img src="https://img-blog.csdnimg.cn/20191026190953443.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM5OTc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>如上图，此时消息3、消息4写入leader副本，follower1从leader同步了消息3，HW取最小值仍为3，leader的LEO变为5，follower1的LEO为4，follower2的LEO为3。当前消费者可以消费0-2之间的消息。</p>
<p><img src="https://img-blog.csdnimg.cn/20191026191121203.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM5OTc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>当follower2也同步了消息3，此时HW取最小值4，follower的LEO变为4。消费者可以消费0-3之间的消息。</p>
<p><img src="https://img-blog.csdnimg.cn/20191026191131945.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM5OTc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>最后follow1和follow2都同步了消息4，LEO和HW都变为5</p>
<h3 id="3-4-消息分区发送机制"><a href="#3-4-消息分区发送机制" class="headerlink" title="3.4 消息分区发送机制"></a>3.4 消息分区发送机制</h3><p>Kafka的消息由键值对和时间戳组成。</p>
<p>生产者负责将消息发布到对应的topic，具体是负责将哪个消息发布到主题中的哪个分区，这里生产者可能对请求进行负载，将消息分发到不同的分区：</p>
<ul>
<li><p>分区在写入的时候可以指定需要写入的分区，如果有指定，则写入对应的分区</p>
</li>
<li><p>如果没有指定分区，但是设置了数据的key，则会根据key的值hash出一个分区</p>
</li>
<li><p>如果既没指定分区，又没有设置key，则会轮询选出一个分区</p>
</li>
</ul>
<h3 id="3-5-消息保留机制"><a href="#3-5-消息保留机制" class="headerlink" title="3.5 消息保留机制"></a>3.5 消息保留机制</h3><p>Kafka集群使用可配置的保留期限持久地保留所有已发布的记录（无论是否已使用它们）。例如，如果将保留策略设置为两天，则在发布记录后的两天内，该记录可供使用，之后将被丢弃以释放空间。Kafka的性能相对于数据大小实际上是恒定的，因此长时间存储数据不是问题。</p>
<h3 id="3-6-消息批量写入机制"><a href="#3-6-消息批量写入机制" class="headerlink" title="3.6 消息批量写入机制"></a>3.6 消息批量写入机制</h3><p>为了提高消息写入效率，消息被分批次写入Kafka中。批次就是一组消息，这些消息属于同一topic下的同一分区。这样减少了网络开销，但是这需要在时间延迟和吞吐量之间作出平衡。批次的数据会被压缩，这样提升了数据的传输和存储能力，但同样做了更多的计算。</p>
<h3 id="3-7-消息顺序性保证"><a href="#3-7-消息顺序性保证" class="headerlink" title="3.7 消息顺序性保证"></a>3.7 消息顺序性保证</h3><p>传统消息系统在服务端保持消息的顺序，如果有多个消费者消费同一个消息队列，服务端会以消息存储的顺序依次发送给消费者。但由于消息是异步发送给消费者的，所以消息到达消费者的顺序可能是无序的，这就意味着并行消费时传统消息队列无法很好保证消息被顺序处理。虽然可以设置一个专用的消费者只消费一个队列，以此来解决消息顺序问题，但是这就使消费无法并行处理。</p>
<p>Kafka比传统消息系统有更强的消息顺序性保证，它使用主题分区作为消息处理的并行单元。Kafka以分区作为最小的粒度，将每个分区分配给消费组中不同的而且是唯一的消费者，并确保一个分区只属于一个消费者，即这个消费者就是这个分区下唯一读取线程。那么，只要分区的消息是有序的，消费者处理的消息顺序就有保证。每个主题有多个分区，不同消费者处理不同分区，所以Kafka不仅保证了消息的有序性，也做到了消费者的负载均衡。不过这个消息消费的顺序仅对于分区而言，如果要保证整个主题的消息消费顺序，那么这个主题只能有一个分区并被一个消费者消费才能保证主题内消息的消费顺序。</p>
<h3 id="3-8-producer向kafka写入消息的机制"><a href="#3-8-producer向kafka写入消息的机制" class="headerlink" title="3.8 producer向kafka写入消息的机制"></a>3.8 producer向kafka写入消息的机制</h3><p>可以通过 request.required.acks参数来设置数据可靠性的级别 ：</p>
<ul>
<li><p>0：producer无需等待来自broker的确认而继续发送下一批消息。这种情况下数据传输效率最高，但是数据可靠性确是最低的。 </p>
</li>
<li><p>1：这是默认值， producer发送消息，在leader已成功收到数据并得到确认后发送下一条消息。如果leader宕机了，则会丢失数据，因为可能消息还没有同步到其他follower。</p>
</li>
<li><p>-1： producer需要等待ISR中的所有follower都确认接收到数据后才算一次发送完成，可靠性最高。但是这样也不能保证数据不丢失，比如只有分区只有一个leader副本的时候，就变成了acks=1情况</p>
</li>
</ul>
<h2 id="4-存储系统"><a href="#4-存储系统" class="headerlink" title="4. 存储系统"></a>4. 存储系统</h2><h3 id="4-1-日志文件相关结构"><a href="#4-1-日志文件相关结构" class="headerlink" title="4.1 日志文件相关结构"></a>4.1 日志文件相关结构</h3><p>每个主题都有一个或多个分区，分区在服务器上表现形式就是一个个的文件夹，每个分区文件夹下会有多组segment文件，每组segment文件又包含.index文件、log文件、timeindex文件，其中log文件就是存储消息的地方，index和timeindex文件为索引文件，用于检索消息。</p>
<p><img src="https://img-blog.csdnimg.cn/20191026191145207.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM5OTc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>每个log文件大小是一样的，但是存储的消息数量不一定相等，因为消息大小可能不一样。文件的命名由segment最小的offset来命名，如segment1的log文件存储offset为0~368795的消息。</p>
<h3 id="4-2-日志索引机制"><a href="#4-2-日志索引机制" class="headerlink" title="4.2 日志索引机制"></a>4.2 日志索引机制</h3><p>kafka利用分段+索引的方式来解决查找效率的问题。由于kafka消息数据太大，如果全部建立索引，即占了空间又增加了耗时，所以kafka选择了稀疏索引的方式，这样的话索引可以直接进入内存，加快偏查询速度。</p>
<p>根据消息的offset368801来查找消息的过程如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20191026191158558.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM5OTc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>1.根据二分法查找offset为368801的消息所在segment，找到为segment2</p>
<p>2.找到segment2中的index文件，文件中记录了消息的稀疏索引，存储相对offset及对应消息的物理偏移关系。这里查找的消息368801的相对offset为368801-368796=5，因为5在index中不存在，所以需要找到距离5最近的索引4。</p>
<p>3.根据索引4，确定相对offset为4的消息物理偏移为388，然后在log文件中根据偏移388找到message368800，一直往下扫描直到查找到offset368801的消息。</p>
<h3 id="4-3-磁盘读取优化机制"><a href="#4-3-磁盘读取优化机制" class="headerlink" title="4.3 磁盘读取优化机制"></a>4.3 磁盘读取优化机制</h3><p><img src="https://img-blog.csdnimg.cn/20191026191219604.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM5OTc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>数据从文件发送到socket网络连接中的常规传输路径：</p>
<ul>
<li>操作系统从磁盘读取数据到内核空间里的页面缓存</li>
<li>应用程序将数据从内核空间读入用户空间的缓冲区</li>
<li>应用程序将读到的数据写回内核空间并放入socket缓冲区</li>
<li>操作系统将数据从socket缓冲区复制到网卡接口，此时数据才能通过网络发送出去</li>
</ul>
<p>这个过程包含了4次copy和两个系统上下文切换，性能比较低效。</p>
<p>结合Kafka的消息有多个订阅者的使用场景，生产者发布的消息一般会被不同的消费者消费多次。Kafka使用“零拷贝”技术只需将磁盘文件的数据复制到页面缓存中一次，然后将数据从页面缓存直接发送到网络中(发送给不同使用者时，都可以重复使用同一个页面缓存)，避免了重复的复制操作。</p>
<h2 id="5-流式处理平台"><a href="#5-流式处理平台" class="headerlink" title="5. 流式处理平台"></a>5. 流式处理平台</h2><p>略</p>
<h2 id="6-API"><a href="#6-API" class="headerlink" title="6. API"></a>6. API</h2><p><img src="https://img-blog.csdnimg.cn/20191026191251218.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM5OTc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li><a href="https://www.orchome.com/190" target="_blank" rel="noopener">Producer API</a> 允许应用程序发送数据流到kafka集群中的topic。</li>
<li><a href="https://www.orchome.com/200" target="_blank" rel="noopener">Consumer API</a> 允许应用程序从kafka集群的topic中读取数据流。</li>
<li><a href="https://www.orchome.com/304" target="_blank" rel="noopener">Streams API</a> 允许从输入topic转换数据流到输出topic。</li>
<li><a href="https://www.orchome.com/455" target="_blank" rel="noopener">Connect API</a> 通过实现连接器（connector），不断地从一些源系统或应用程序中拉取数据到kafka，或从kafka提交数据到宿系统（sink system）或应用程序。</li>
</ul>
<h2 id="7-Kafka使用示例（windows环境）"><a href="#7-Kafka使用示例（windows环境）" class="headerlink" title="7. Kafka使用示例（windows环境）"></a>7. Kafka使用示例（windows环境）</h2><h3 id="7-1-Kafka安装配置"><a href="#7-1-Kafka安装配置" class="headerlink" title="7.1 Kafka安装配置"></a>7.1 Kafka安装配置</h3><p>1.安装JDK</p>
<p>Kafka2.0.0版本开始不支持JDK7及以下版本，这里演示使用JDK1.8，JDK安装过程略过。</p>
<p>2.安装Zookeeper</p>
<p>Zookeeper是安装Kafka集群的必要组件，Kafka通过Zookeeper来实施对元数据信息的管理，包括集群、broker、主题、分区等内容。Kafka的安装包中已经有zookeeper,这里不再去另外下载安装。</p>
<p>3.下载Kafka安装包并解压：</p>
<p><a href="https://www.apache.org/dyn/closer.cgi?path=/kafka/2.3.0/kafka_2.12-2.3.0.tgz" target="_blank" rel="noopener">https://www.apache.org/dyn/closer.cgi?path=/kafka/2.3.0/kafka_2.12-2.3.0.tgz</a></p>
<p>4.进入Kafka目录，查看config目录下的server.properties配置文件，关注以下几个配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># broker的编号，如果集群中有多个broker，则每个broker的编号需要设置的不同</span><br><span class="line">broker.id=0</span><br><span class="line"># broker对外提供的服务入口地址</span><br><span class="line">listeners=PLAINTEXT://172.31.80.151:9092</span><br><span class="line"># 存放消息文件的目录</span><br><span class="line">log.dirs=/tmp/kafka-logs</span><br><span class="line"># Kafka所需的zookeeper集群地址</span><br><span class="line">zookeeper.connect=localhost:2181</span><br></pre></td></tr></table></figure>
<h3 id="7-2-单机模式"><a href="#7-2-单机模式" class="headerlink" title="7.2 单机模式"></a>7.2 单机模式</h3><p>1.进入Kafka安装目录，启动Zookeeper</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.\bin\windows\zookeeper-server-start.bat .\config\zookeeper.properties</span><br></pre></td></tr></table></figure>
<p>2.启动Kafka server</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.\bin\windows\kafka-server-start.bat .\config\server.properties</span><br></pre></td></tr></table></figure>
<p>3.创建topic “tplink”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.\bin\windows\kafka-topics.bat --create --bootstrap-server localhost:9092 --replication-factor 1 --partitions 1 --topic tplink</span><br></pre></td></tr></table></figure>
<p>4.查看是否创建成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.\bin\windows\kafka-topics.bat --list --bootstrap-server localhost:9092</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20191026191314846.png" alt="在这里插入图片描述"></p>
<p>5.启动生产者发送信息</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">.\bin\windows\kafka-console-producer.bat --broker-list localhost:<span class="number">9092</span> --topic tplink</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20191026191328655.png" alt="\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ukTixUTT-1572087828524)(Kafka学习.assets/1571295035887.png)\]"></p>
<p>6.启动消费者消费消息</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">.\bin\windows\kafka-console-consumer.bat --bootstrap-server localhost:<span class="number">9092</span> --topic tplink --from-beginning</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/2019102619134929.png" alt="在这里插入图片描述"></p>
<p>可以看到生产者发送的消息成功被消费者消费</p>
<h3 id="7-3-分布式模式"><a href="#7-3-分布式模式" class="headerlink" title="7.3 分布式模式"></a>7.3 分布式模式</h3><p>分布式模式的Kafka集群拥有多个broker，增加两个broker：</p>
<p>1.复制config/server.properties文件为config/server-1.properties和config/server-2.properties</p>
<p>2.分别修改server-1.properties和server-2.properties</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">config/server-1.properties:</span><br><span class="line">broker.id=1</span><br><span class="line">listeners=PLAINTEXT://localhost:9093</span><br><span class="line">log.dirs=/tmp/kafka-logs-1</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">config/server-2.properties:</span><br><span class="line">broker.id=2</span><br><span class="line">listeners=PLAINTEXT://localhost:9094</span><br><span class="line">log.dirs=/tmp/kafka-logs-2</span><br></pre></td></tr></table></figure>
<p>3.启动broker1和broker2：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">.\bin\windows\kafka-server-start.bat .\config\server-<span class="number">1</span>.properties</span><br><span class="line">.\bin\windows\kafka-server-start.bat .\config\server-<span class="number">2</span>.properties</span><br></pre></td></tr></table></figure>
<p>4.创建topic，分区数量为1，分区副本数量为3</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">.\bin\windows\kafka-topics.bat --create --bootstrap-server <span class="number">172.31</span>.<span class="number">80.151</span>:<span class="number">9092</span> --replication-factor <span class="number">3</span> --partitions <span class="number">1</span> --topic tplink-replicated-topic</span><br></pre></td></tr></table></figure>
<p>5.查看topic</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">.\bin\windows\kafka-topics.bat --describe --bootstrap-server localhost:<span class="number">9092</span> --topic tplink-replicated-topic</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20191026191409701.png" alt="在这里插入图片描述"></p>
<p>解释：</p>
<p>返回的第一个行显示所有partitions的一个总结，以下每一行给出一个partition中的信息，如果我们只有一个partition，则只显示一行。</p>
<ul>
<li><p>Partition:0表示当前分区为0</p>
</li>
<li><p>Leader:0表示当前leader为broker.id为0的kafka实例</p>
</li>
<li><p>Replicas :显示给定partiton所有副本所存储节点的节点列表，不管该节点是否是leader或者是否存活</p>
</li>
<li><p>Isr: 副本都已同步的的节点集合，这个集合中的所有节点都是存活状态，并且跟leader同步</p>
</li>
</ul>
<p>6.创建生产者往集群发送消息</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">.\bin\windows\kafka-console-producer.bat --broker-list localhost:<span class="number">9092</span> --topic tplink-replicated-topic</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20191026191431426.png" alt="在这里插入图片描述"></p>
<p>7.创建消费者消费消息</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">.\bin\windows\kafka-console-consumer.bat --bootstrap-server localhost:<span class="number">9092</span> --from-beginning -topic tplink-replicated-topic</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20191026191449414.png" alt="在这里插入图片描述"></p>
<p>8.杀死分区的leader进程，查看topic状态</p>
<p>从第5步知道leader是1，查找broker id 为1的实例进程：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">wmic <span class="keyword">process</span> where <span class="string">"caption = 'java.exe' and commandline like '%server.properties%'"</span> get processid</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20191026191501176.png" alt="在这里插入图片描述"></p>
<p>杀死进程：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">taskkill /pid <span class="number">36488</span> /f</span><br></pre></td></tr></table></figure>
<p>查看topic状态：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">.\bin\windows\kafka-topics.bat --describe --zookeeper localhost:<span class="number">2181</span> --topic tplink-replicated-topic</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20191026191511829.png" alt="在这里插入图片描述"></p>
<p>此时leader挂掉后，重新选举leader变为broker1，ISR剩下broker1和2</p>
<h3 id="7-4-docker镜像使用"><a href="#7-4-docker镜像使用" class="headerlink" title="7.4 docker镜像使用"></a>7.4 docker镜像使用</h3><p>1.安装 Docker Desktop on Windows</p>
<p> <a href="https://docs.docker.com/docker-for-windows/install/" target="_blank" rel="noopener">https://docs.docker.com/docker-for-windows/install/</a> </p>
<p>2.使用docker hub上的wurstmeister/kafka镜像</p>
<p> <a href="https://hub.docker.com/r/wurstmeister/kafka" target="_blank" rel="noopener">https://hub.docker.com/r/wurstmeister/kafka</a> </p>
<p>dock compose是 docker 提供的一个命令行工具，用来定义和运行由多个容器组成的应用。使用 compose，我们可以通过 YAML 文件声明式的定义应用程序的各个服务，并由单个命令完成应用的创建和启动。</p>
<p>编写docker-compose.yml文件，进行相关配置如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'2'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  zookeeper:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">wurstmeister/zookeeper</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"2181:2181"</span></span><br><span class="line"><span class="attr">  kafka:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">wurstmeister/kafka</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"9092-9095:9092"</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="attr">      KAFKA_ADVERTISED_LISTENERS:</span> <span class="attr">PLAINTEXT://:9092</span></span><br><span class="line"><span class="attr">      KAFKA_ADVERTISED_HOST_NAME:</span> <span class="number">172.31</span><span class="number">.80</span><span class="number">.151</span></span><br><span class="line"><span class="attr">      KAFKA_LISTENERS:</span> <span class="attr">PLAINTEXT://:9092</span></span><br><span class="line"><span class="attr">      KAFKA_ZOOKEEPER_CONNECT:</span> <span class="attr">zookeeper:2181</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line">    <span class="comment"># 使容器内可以执行docker ps、docker port等命令</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">/var/run/docker.sock:/var/run/docker.sock</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>创建和启动docker容器</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>扩展kafka节点为3个</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker-compose scale kafka=<span class="number">3</span></span><br></pre></td></tr></table></figure>
<ol start="5">
<li>查看docker运行容器</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20191026191532820.png" alt="在这里插入图片描述"></p>
<ol start="6">
<li>创建topic</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker exec kafka_kafka_1 kafka-topics.sh --create --topic tplink --partitions <span class="number">3</span> --zookeeper zookeeper:<span class="number">2181</span> --replication-factor <span class="number">3</span></span><br></pre></td></tr></table></figure>
<ol start="7">
<li>查看当前topic列表</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker exec kafka_kafka_1 kafka-topics.sh --list --zookeeper zookeeper:<span class="number">2181</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20191026191550454.png" alt="在这里插入图片描述"></p>
<ol start="8">
<li>查看tplink topic的情况</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker exec kafka_kafka_1 kafka-topics.sh --describe --topic tplink --zookeeper zookeeper:<span class="number">2181</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20191026191606107.png" alt="在这里插入图片描述"></p>
<h2 id="8-Kafka与其他消息队列比较"><a href="#8-Kafka与其他消息队列比较" class="headerlink" title="8. Kafka与其他消息队列比较"></a>8. Kafka与其他消息队列比较</h2><p>与RabbitMQ、RocketMQ比较：</p>
<ul>
<li><p>Kafka是LinkedIn开源的分布式发布-订阅消息系统，目前归属于Apache定级项目。Kafka主要特点是基于Pull的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集和传输。0.8版本开始支持复制，不支持事务，对消息的重复、丢失、错误没有严格要求，适合产生大量数据的互联网服务的数据收集业务。</p>
</li>
<li><p>RabbitMQ是使用Erlang语言开发的开源消息队列系统，基于AMQP协议来实现。AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。AMQP协议更多用在企业系统内，对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量的要求还在其次。</p>
</li>
<li><p>RocketMQ是阿里开源的消息中间件，它是纯Java开发，具有高吞吐量、高可用性、适合大规模分布式系统应用的特点。RocketMQ思路起源于Kafka，但并不是Kafka的一个Copy，它对消息的可靠传输及事务性做了优化，目前在阿里集团被广泛应用于交易、充值、流计算、消息推送、日志流式处理、binglog分发等场景。</p>
</li>
</ul>
<p>测试目的</p>
<p>对比Kafka、RabbitMQ、RocketMQ发送小消息(124字节)的性能。这次压测我们只关注服务端的性能指标,所以压测的标准是:</p>
<p>不断增加发送端的压力,直到系统吞吐量不再上升,而响应时间拉长。这时服务端已出现性能瓶颈,可以获得相应的系统最佳吞吐量。</p>
<p>测试场景</p>
<p>在同步发送场景中，三个消息中间件的表现区分明显：</p>
<p>Kafka的吞吐量高达17.3w/s，不愧是高吞吐量消息中间件的行业老大。这主要取决于它的队列模式保证了写磁盘的过程是线性IO。此时broker磁盘IO已达瓶颈。</p>
<p>RocketMQ也表现不俗，吞吐量在11.6w/s，磁盘IO %util已接近100%。RocketMQ的消息写入内存后即返回ack，由单独的线程专门做刷盘的操作，所有的消息均是顺序写文件。</p>
<p>RabbitMQ的吞吐量5.95w/s，CPU资源消耗较高。它支持AMQP协议，实现非常重量级，为了保证消息的可靠性在吞吐量上做了取舍。我们还做了RabbitMQ在消息持久化场景下的性能测试，吞吐量在2.6w/s左右。</p>
<p>性能对比：</p>
<p><img src="https://img-blog.csdnimg.cn/20191026191627447.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM5OTc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>测试环境</p>
<p>服务端为单机部署，机器配置如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20191026191642686.png" alt="在这里插入图片描述"></p>
<p>应用版本：</p>
<p><img src="https://img-blog.csdnimg.cn/20191026191650642.png" alt="在这里插入图片描述"></p>
<p>测试脚本</p>
<p><img src="https://img-blog.csdnimg.cn/20191026191701530.png" alt="在这里插入图片描述"><br>以上引自 <a href="https://yq.aliyun.com/articles/475265?spm=a2c4e.11153940.0.0.26dc794fkRn404" target="_blank" rel="noopener">https://yq.aliyun.com/articles/475265?spm=a2c4e.11153940.0.0.26dc794fkRn404</a> </p>
]]></content>
      <categories>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析JAVA垃圾回收</title>
    <url>/2019/08/31/%E6%B5%85%E6%9E%90JAVA%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    <content><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><table>
<thead>
<tr>
<th>资料名称</th>
<th>来源地址</th>
</tr>
</thead>
<tbody>
<tr>
<td>《深入理解JVM&amp;G1 GC》</td>
<td>图书</td>
</tr>
<tr>
<td>《深入理解Java虚拟机》</td>
<td>图书</td>
</tr>
<tr>
<td>JAVA 8官方文档</td>
<td><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/</a></td>
</tr>
</tbody>
</table><h2 id="什么是垃圾回收"><a href="#什么是垃圾回收" class="headerlink" title="什么是垃圾回收"></a>什么是垃圾回收</h2><a id="more"></a>
<p>Java一个特点就是引入了垃圾回收机制，Java垃圾回收是指JVM自动对内存中无用对象所占用空间的释放，使Java程序员在编写程序的时候不再需要考虑内存管理，可以有效的防止内存泄露。</p>
<h2 id="为什么要进行垃圾回收"><a href="#为什么要进行垃圾回收" class="headerlink" title="为什么要进行垃圾回收"></a>为什么要进行垃圾回收</h2><p>JVM运行过程中会为对象分配内存空间，当对象不会再被使用后，垃圾收集器需要对其所占用空间进行回收，否则迟早会导致内存占用越来越大直到内存溢出，程序就会无法运行。就比如家里的垃圾一直不扔，迟早会塞满整个家，人也没有空间在家里生活下去。</p>
<h2 id="对什么进行回收"><a href="#对什么进行回收" class="headerlink" title="对什么进行回收"></a>对什么进行回收</h2><p>垃圾回收主要针对堆和方法区的对象进行回收。线程私有的程序计数器、虚拟机栈和本地方法栈在线程结束之后就被清除，不参与垃圾回收。</p>
<h2 id="如何判断一个对象是否可以被回收"><a href="#如何判断一个对象是否可以被回收" class="headerlink" title="如何判断一个对象是否可以被回收"></a>如何判断一个对象是否可以被回收</h2><ul>
<li><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>为对象添加一个引用计数器，每当有一个地方引用它时，计数器值加一；当引用失效时，计数器减一；任何时刻当计数器值为0时说明该对象不可能再被使用，可以被垃圾回收。</p>
<p>如下代码，当存在两个对象之间的循环引用时，两者的引用计数永远不为0，导致无法对它们进行回收。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test a = <span class="keyword">new</span> Test();</span><br><span class="line">        Test b = <span class="keyword">new</span> Test();</span><br><span class="line">        a.instance = b;</span><br><span class="line">        b.instance = a;</span><br><span class="line">        a = <span class="keyword">null</span>;</span><br><span class="line">        b = <span class="keyword">null</span>; </span><br><span class="line">		dosomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为循环引用问题难以处理，JAVA虚拟机没有选用引用计数法来管理内存。</p>
</li>
<li><h3 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h3><p>在主流的商用语言中如Java、C#的主流实现中都是通过可达性分析来判断对象是存活。这个算法的基本思路就是通过一系列的<strong>GC Roots</strong>对象作为起点，从这些节点开始向下搜索引用的对象，走过的路径称为<strong>引用链</strong>。<strong>当一个对象到GC Roots没有任何引用链相连时，证明此对象是不可用的，所以会被判定为是可回收的对象</strong>。<br><img src="https://img-blog.csdnimg.cn/20191028193648631.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM5OTc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在Java中，GC Roots包含以下几种：</p>
<ul>
<li><p>虚拟机栈（栈帧中的本地变量表）中引用的对象</p>
</li>
<li><p>方法区中类静态属性引用的对象</p>
</li>
<li><p>方法区中常量引用的对象</p>
</li>
<li><p>本地方法栈中JNI引用的对象</p>
<h5 id="对象的finalize-方法"><a href="#对象的finalize-方法" class="headerlink" title="对象的finalize()方法"></a>对象的finalize()方法</h5><p>在可达性分析中不可达的对象，也不一定会被回收，这里涉及到finalize方法的知识：</p>
<ul>
<li><p>finalize()是Object的protected方法，子类可以覆盖该方法以实现资源清理工作，GC在回收对象之前调用该方法，如果对象覆盖了该方法并且在该方法中将自身重新被引用链中任意对象引用， 就能完成自救。</p>
</li>
<li><p>finalize()方法最多只能被GC执行一次，第二次被标记回收时不会再执行该方法</p>
</li>
<li><p>finalize()方法不被推荐使用，它能做的所有工作，try-finally都能做得更好更及时</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h3><p>该算法首先标记出需要回收的对象,标记完成后统一回收掉所有的被标记对象</p>
<p>缺点：</p>
<ul>
<li><p>效率问题：标记和清除的效率不高</p>
</li>
<li><p>空间问题：标记清除后会产生大量不连续的内存碎片，空间碎片太多可能导致以后在程序运行过程中产生大量不连续的内存碎片。空间碎片太多可能会导致以后在程序运行中需要分配大对象时因为无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。<br><img src="https://img-blog.csdnimg.cn/20191028194304905.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM5OTc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
</ul>
<h3 id="标记-整理"><a href="#标记-整理" class="headerlink" title="标记-整理"></a>标记-整理</h3><p>该算法的标记过程与标记-整理算法一致，但不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>
<p>优点：不会产生内存碎片<br>缺点：需要移动大量对象，处理效率较低<br><img src="https://img-blog.csdnimg.cn/20191028194236533.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM5OTc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p>复制算法将可用内存分为大小相等的两块，每次只使用其中的一块，当这块内存用完了就将还存活的对象复制到另外一块上面，然后再把已使用的内存空间一次清理掉。</p>
<p>优点：不存在内存碎片问题，实现简单，运行高效。<br>缺点：内存缩小为了原来的一半。如果对象存活率高就要进行较多的复制操作，效率会变低。<br>回收前状态：<br><img src="https://img-blog.csdnimg.cn/20191028194143533.png" alt="在这里插入图片描述"><br>回收后状态：<br><img src="https://img-blog.csdnimg.cn/20191028194201646.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM5OTc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h3><p>当前的商业虚拟机垃圾收集都使用分代收集算法。该算法思想是根据对象存活周期的不同将内存划分为几块，一般是分为年轻代和老年代，然后根据不同年代的特点采用最合适的收集算法。</p>
<p>新生代：每次垃圾收集都有大批对象死亡，少量存活，适合选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。</p>
<p>老年代：对象存活率高，适合使用标记-清理或标记-整理来进行回收。</p>
<h2 id="内存分配和回收策略"><a href="#内存分配和回收策略" class="headerlink" title="内存分配和回收策略"></a>内存分配和回收策略</h2><p><img src="https://img-blog.csdnimg.cn/20191028194457461.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM5OTc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="JAVA堆结构"><a href="#JAVA堆结构" class="headerlink" title="JAVA堆结构"></a>JAVA堆结构</h3><p><img src="https://img-blog.csdnimg.cn/20191028194501315.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM5OTc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在JDK1.8版本之前，JAVA堆被划分为年轻代、老年代和永久代，其中年轻代又被划分为eden、s1、s2。</p>
<p>在 JDK 1.8 中， HotSpot 已经没有 永久代这个区间了，取而代之的是 Metaspace（元空间）。</p>
<p>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过参数设置来指定元空间的大小。</p>
<h3 id="MinorGC-和-Full-GC"><a href="#MinorGC-和-Full-GC" class="headerlink" title="MinorGC 和 Full GC"></a>MinorGC 和 Full GC</h3><p>Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。</p>
<p>Full GC：回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。</p>
<h3 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h3><h4 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h4><p>大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。</p>
<h4 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h4><p>大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。</p>
<p>经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。</p>
<p>-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。</p>
<h4 id="长期存活的对象进入老年代"><a href="#长期存活的对象进入老年代" class="headerlink" title="长期存活的对象进入老年代"></a>长期存活的对象进入老年代</h4><p>为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。</p>
<p>-XX:MaxTenuringThreshold 用来定义年龄的阈值。</p>
<h4 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h4><p>虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于<br>Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。</p>
<h4 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h4><p>在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。</p>
<p>如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。</p>
<h4 id="Full-GC的触发条件"><a href="#Full-GC的触发条件" class="headerlink" title="Full GC的触发条件"></a>Full GC的触发条件</h4><p>对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件：</p>
<ul>
<li><strong>调用System.gc()</strong></li>
</ul>
<p>只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。</p>
<ul>
<li><strong>老年代空间不足</strong></li>
</ul>
<p>老年代空间不足的常见场景为大对象直接进入老年代、长期存活的对象进入老年代等。</p>
<p>为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。</p>
<ul>
<li><strong>空间分配担保失败</strong></li>
</ul>
<p>使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。</p>
<ul>
<li><strong>JDK 1.7 及以前的永久代空间不足</strong></li>
</ul>
<p>在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。</p>
<p>当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。</p>
<p>为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。</p>
<ul>
<li><strong>Concurrent Mode Failure</strong></li>
</ul>
<p>执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。</p>
<h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p>垃圾收集器是内存回收的具体实现。不同厂商、不同版本的虚拟机所提供的垃圾收集器可能有很大差别，一般来说会提供参数供用户根据自己的应用特点组合出各个年代所使用的收集器。<br>如下分为JDK1.7Update14之后HotSpot虚拟机的7种作用于不同分代的收集器，两个收集器存在连线则说明它们可以搭配使用：<br><img src="https://img-blog.csdnimg.cn/20191028194554146.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM5OTc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h4><p>Serial收集器是最基本、发展历史最悠久的收集器。<br>它是单线程的收集器，只会使用一个线程进行垃圾收集工作。<br>在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束，这个停顿被称为“Stop The World”。<br><img src="https://img-blog.csdnimg.cn/20191028194622320.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM5OTc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>它的优点是简单高效，在单个 CPU 环境下，由于没有线程交互的开销，因此拥有最高的单线程收集效率。<br>它是 Client 场景下的默认新生代收集器，因为在该场景下内存一般来说不会很大。它收集一两百兆垃圾的停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿时间是可以接受的。<br>启用配置：-XX:+UseSerialGC</p>
<h4 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h4><p>ParNew收集器是Serial收集器的多线程版本。<br><img src="https://img-blog.csdnimg.cn/20191028194644615.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM5OTc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>它是 Server 场景下默认的新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合使用。CMS收集器的介绍后面会进行说明。</p>
<h4 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h4><p>与 ParNew 一样是多线程收集器。<br>CMS等收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，因此它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户程序的时间占总时间的比值。</p>
<p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务。</p>
<p>缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。</p>
<p>可以通过一个开关参数-XX:+UseAdaptiveSizePolicy打开 GC 自适应的调节策略（GC Ergonomics），就不需要手工指定新生代的大小（-Xmn）、Eden 和 Survivor 区的比例、晋升老年代对象年龄等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。</p>
<h4 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h4><p>是 Serial 收集器的老年代版本，也是给 Client 场景下的虚拟机使用。如果用在 Server 场景下，它有两大用途：</p>
<ul>
<li>在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。</li>
<li>作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。<br><img src="https://img-blog.csdnimg.cn/20191028194740814.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM5OTc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h4 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h4>是 Parallel Scavenge 收集器的老年代版本。<br>在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。</li>
</ul>
<h4 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h4><p><img src="https://img-blog.csdnimg.cn/20191028194823217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM5OTc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记-清除算法。<br>分为以下四个流程：</p>
<ul>
<li>初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。</li>
<li>并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。</li>
<li>重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。</li>
<li>并发清除：不需要停顿。</li>
</ul>
<p>在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。<br>具有以下缺点：</p>
<ul>
<li>吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。</li>
<li>无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。</li>
<li>标记-清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。</li>
</ul>
<p>相关配置参数：</p>
<ul>
<li>-XX:CMSInitiatingOccupancyFraction设置老年代占用多少百分比激活CMS收集</li>
<li>+UseCMSCompactAtFullCollection开关参数，默认开启：由于CMS顶不住要进行Full GC时开启内存碎片的合并整理过程，这个过程会导致停顿时间变长</li>
<li>-XX:CMSFullGCsBeforeCompaction:设置执行多少次不压缩的Full GC后来一次压缩的（默认值为0，代表每次进入Full GC都进行碎片整理）</li>
</ul>
<h4 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h4><p>G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。<br>堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。<br>G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离<br><img src="https://img-blog.csdnimg.cn/20191028194957295.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM5OTc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。<br>每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。<br><img src="https://img-blog.csdnimg.cn/20191028195012933.png" alt="在这里插入图片描述"><br>如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：</p>
<ul>
<li>初始标记</li>
<li>并发标记</li>
<li>最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。</li>
<li>筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</li>
</ul>
<p>具备如下特点：</p>
<ul>
<li>空间整合：整体来看是基于“标记-整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。</li>
<li>可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。</li>
</ul>
<h3 id="存疑问题"><a href="#存疑问题" class="headerlink" title="存疑问题"></a>存疑问题</h3><h4 id="JVM的-server参数和-client参数"><a href="#JVM的-server参数和-client参数" class="headerlink" title="JVM的-server参数和-client参数"></a>JVM的-server参数和-client参数</h4><p>Java5以上版本JVM能够根据硬件配置等数据自动判断使用Server模式还是Client模式。<br>cilent模式与server模式的区别 </p>
<p>1）编译器方面：<br>当虚拟机运行在client模式时，使用的是一个代号为c1的轻量级编译器，而server模式启动时，虚拟机采用的是相对重量级，代号为c2的编译器；c2编译器比c1编译器编译的相对彻底，服务起来之后，性能更高。</p>
<p>2）gc方面：<br>cilent模式下的新生代（Serial收集器）和老年代（Serial Old）选择的是串行gc<br>server模式下的新生代选择并行回收gc，老年代选择并行gc</p>
<p>3）启动方面：<br>client模式启动快，编译快，内存占用少，针对桌面应用程序设计，优化客户端环境的启动时间<br>server模式启动慢，编译更完全，编译器是自适应编译器，效率高，针对服务端应用设计，优化服务器环境的最大化程序执行速度 </p>
<p>使用命令java –version可以查看当前JVM默认工作在哪个模式<br><img src="https://img-blog.csdnimg.cn/20191028195239134.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>垃圾回收</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析MySQL索引</title>
    <url>/2019/08/31/%E6%B5%85%E6%9E%90MySQL%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><table>
<thead>
<tr>
<th>资料名称</th>
<th>来源地址</th>
</tr>
</thead>
<tbody>
<tr>
<td>《MySQL王者晋级之路》</td>
<td>图书</td>
</tr>
<tr>
<td>《高性能MySQL》</td>
<td>图书</td>
</tr>
<tr>
<td>MySQL官方文档</td>
<td><a href="https://dev.mysql.com/doc/" target="_blank" rel="noopener">https://dev.mysql.com/doc/</a></td>
</tr>
<tr>
<td>《MySQL索引背后的数据结构及算法原理》</td>
<td><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">http://blog.codinglabs.org/articles/theory-of-mysql-index.html</a></td>
</tr>
</tbody>
</table><a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>MySQL的索引是存储引擎用于快速查找记录的一种数据结构。工作原理是先从索引上找到对应值，再根据匹配的索引记录找到对应的数据行。索引的目的在于提高查询效率，可类比字典、书籍的目录等这种形式。</p>
<h2 id="数据结构介绍"><a href="#数据结构介绍" class="headerlink" title="数据结构介绍"></a>数据结构介绍</h2><p>目前大部分数据库系统及文件系统都采用B-Tree或其变种B+Tree作为索引结构。实际上MySQL的很多存储引擎如最常见的innoDB使用的是B+Tree，即每个叶子节点都包含指向下一个叶子节点的指针，从而方便叶子节点的范围遍历。</p>
<h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h3><p><img src="https://img-blog.csdnimg.cn/20190819181704873.png" alt="在这里插入图片描述"></p>
<h3 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h3><p><img src="https://img-blog.csdnimg.cn/20190819181727194.png" alt="在这里插入图片描述"></p>
<h3 id="为什么要使用这种数据结构"><a href="#为什么要使用这种数据结构" class="headerlink" title="为什么要使用这种数据结构"></a>为什么要使用这种数据结构</h3><p>从理论上讲，二叉树查找速度和比较次数都是最小的，为什么不用二叉树呢？ </p>
<p>首先索引本质上是一种数据结构，占用空间也很大，不可能全部存储在内存中，一般以索引文件形式存储在磁盘上，所以查找索引时就涉及到从磁盘中读取数据，就会有I/O消耗。相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数，对于树来说，IO次数就是树的高度，而“矮胖”就是b树的特征之一。</p>
<p>磁盘读取数据时，并不是只读取所需要的数据就行，而是会从读取数据的起始处往后读取一定长度的数据。这就涉及到局部性原理和磁盘的预读机制的概念：</p>
<h4 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h4><p>当一个数据被用到时，其附近的数据也通常会马上被使用。</p>
<h4 id="磁盘预读机制"><a href="#磁盘预读机制" class="headerlink" title="磁盘预读机制"></a>磁盘预读机制</h4><p>因为磁盘存取速度比内存慢很多，根据局部性原理，为了提高效率，需要尽量减少磁盘I/O，磁盘每次都要从读取的数据位置顺序向后读取一页数据的整数倍放入内存中。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页的大小通常为4k）。</p>
<p>B-Tree每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个节点只需一次I/O。</p>
<p>B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存，h为树的高度），渐进复杂度为$O(h)=O(log_dN)$。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。</p>
<p>综上所述，用B-Tree作为索引结构效率是非常高的。</p>
<p>比如红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为$O(h)$，效率明显比B-Tree差很多。</p>
<h2 id="MySQL索引实现"><a href="#MySQL索引实现" class="headerlink" title="MySQL索引实现"></a>MySQL索引实现</h2><h3 id="MyISAM索引实现"><a href="#MyISAM索引实现" class="headerlink" title="MyISAM索引实现"></a>MyISAM索引实现</h3><p><img src="https://img-blog.csdnimg.cn/20190819181740530.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM5OTc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>MyISAM索引的数据结构是B+Tree结构，在叶子节点处保存的是数据记录的地址</p>
<p><img src="https://img-blog.csdnimg.cn/20190819181755308.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM5OTc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>辅助索引与主键索引除了主键索引具有唯一性外，其他地方没有任何区别，在叶子节点处仅保存数据记录的地址。搜索数据记录时先使用B+Tree的搜索算法找出数据地址，再根据数据地址找出数据记录。</p>
<p>MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分。</p>
<p>###　InnoDB索引实现</p>
<p><img src="https://img-blog.csdnimg.cn/20190819181808960.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM5OTc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>InnoDB引擎也是使用B+Tree作为索引结构。</p>
<p>与MyISAM引擎的索引实现方式不同在于InnoDB的数据文件本身就是主键的索引文件。</p>
<p>由上图可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p>
<p><img src="https://img-blog.csdnimg.cn/20190819181821472.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM5OTc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。</p>
<p>所以聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。</p>
<h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><h3 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h3><p>主键索引就是聚集索引，每张表中有且仅有一个主键，可以由表中一个或多个字段组成。</p>
<ul>
<li><p>主键值必须唯一</p>
</li>
<li><p>不能包含null值</p>
</li>
</ul>
<p>创建主键索引语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table table_name add primary key(column_list);</span><br></pre></td></tr></table></figure>
<h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><p>唯一索引是约束条件的一种，就是不允许有重复的值，但是可以允许有null值。表的主键只能有一个，但是唯一索引可以有多个。</p>
<p>创建唯一索引的语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create unique index index_name on table_name (column_list);</span><br><span class="line">-- 或</span><br><span class="line">alter table table_name add unique (column_list);</span><br></pre></td></tr></table></figure>
<h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><p>对于BLOB，TEXT或者很长的VARCHAR类型的列，为它们的前n个字符（具体几个由创建索引时指定）建立索引，这样的索引就叫前缀索引。这样建立的索引更小，查询更快。</p>
<p>创建前缀索引的语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create index index_name on table_name(column_name(prefix_length));</span><br><span class="line">-- 或</span><br><span class="line">alter table table_name add key(column_name(prefix_length));</span><br></pre></td></tr></table></figure>
<h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><p>联合索引又叫复合索引，是在表中两个或两个以上的列上创建的索引。利用索引的附加列，可以缩小检索的范围，更快搜索到数据。</p>
<p>创建联合索引的语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create index index_name on table_name (column_list);</span><br><span class="line">-- 或</span><br><span class="line">alter table table_name add index index_name (column_list);</span><br></pre></td></tr></table></figure>
<p>假设表t有c1，c2两个字段，为它们创建联合索引：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create index idx_c1_c2 on t (c1, c2);</span><br></pre></td></tr></table></figure>
<p>联合索引的使用必须满足最左前缀原则。一般把选择性高的列放在前面。一条查询语句可以只使用索引中的一部分，但是必须从最左侧开始。联合idx_c1_c2可以用到c1索引和c1，c2索引，但用不到c2索引。</p>
<p>以下查询可以用到idx_c1_c2的索引：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from t where c1 = &apos;xxx&apos;;</span><br><span class="line">select * from t where c1 = &apos;xxx&apos; and c2 = &apos;xxxx&apos;;</span><br><span class="line">select * from t where c1 = &apos;xxx&apos; and c2 in (&apos;xxxx&apos;, &apos;xxx&apos;);</span><br><span class="line">select * from t where c1 = (&apos;xxx&apos;, &apos;xxxx&apos;) and c2 = &apos;xxx&apos;;</span><br><span class="line">select * from t order by c1, c2;</span><br><span class="line">select * from t where c1 = &apos;xxx&apos; order by c2;</span><br></pre></td></tr></table></figure>
<p>用不到idx_c1_c2索引的查询：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from t where c2 = &apos;xxx&apos;;</span><br><span class="line">select * from t where c2 = &apos;xxx&apos; order by c1;</span><br></pre></td></tr></table></figure>
<p>另外，使用or关键字也是不能使用到联合索引的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from t where c1 = &apos;xxx&apos; or c2 = &apos;xxxx&apos;;</span><br></pre></td></tr></table></figure>
<p>这种情况就要在c1，c2各自建两个单列索引。</p>
<h3 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h3><p>哈希索引采用哈希算法，将键值换算成哈希值。哈希值只能进行等值查询，不能进行排序、模糊查找、范围查询等。检索时不需要像B+Tree那样从根节点到叶子节点逐级查找，只需一次哈希算法即可立刻定位到相应的位置，查询速度非常快。</p>
<p>innodb引擎支持哈希索引，称为自适应哈希索引，但是需要通过innodb_adaptive_hash_index参数来启用，默认是启用的。hash索引的创建由InnoDB存储引擎引擎自动优化创建。哈希索引只能用来搜索等值的查询，对于其他查找类型，如范围查找，是不能使用哈希索引的</p>
<p><img src="https://img-blog.csdnimg.cn/20190819181904638.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM5OTc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><p>全文索引是在基于文本的列（char、varchar或text列）上创建的，有助于提高对这些列中文本的查询速度和DML操作效率。</p>
<p>InnoDB引擎对全文索引的支持是MySQL5.6新引入的特性，之前只有MyISAM引擎支持全文索引。对于全文索引的内容可以使用MATCH()…AGAINST语法进行查询。MySQL5.6不支持中文全文索引，因为与英文不同，中文的文字是连着一起写的，中间没有MySQL能找到分词的地方。MySQL 5.7开始，MySQL内置了ngram全文检索插件，用来支持中文分词，并且对MyISAM和InnoDB引擎有效。</p>
<p>添加全文索引:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table table_name add fulltext index index_name(column_list) with parser ngram;</span><br></pre></td></tr></table></figure>
<p>查询语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MATCH(col1,col2,…) AGAINST (expr[search_modifier])</span><br></pre></td></tr></table></figure>
<h2 id="索引使用策略和优化技巧"><a href="#索引使用策略和优化技巧" class="headerlink" title="索引使用策略和优化技巧"></a>索引使用策略和优化技巧</h2><p>创建一个员工表用于示例，并导入数据，数据来源：<a href="https://dev.mysql.com/doc/employee/en/" target="_blank" rel="noopener">https://dev.mysql.com/doc/employee/en/</a></p>
<p>表结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE employees (</span><br><span class="line">    emp_no      INT             NOT NULL,</span><br><span class="line">    birth_date  DATE            NOT NULL,</span><br><span class="line">    first_name  VARCHAR(14)     NOT NULL,</span><br><span class="line">    last_name   VARCHAR(16)     NOT NULL,</span><br><span class="line">    gender      ENUM (&apos;M&apos;,&apos;F&apos;)  NOT NULL,    </span><br><span class="line">    hire_date   DATE            NOT NULL,</span><br><span class="line">    PRIMARY KEY (emp_no)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="全值匹配"><a href="#全值匹配" class="headerlink" title="全值匹配"></a>全值匹配</h3><p>全值匹配是指索引匹配查询条件的所有列</p>
<p>为字段birth_date, first_name, last_name创建联合索引：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table employees add index idx_bfl(`birth_date`, `first_name`, `last_name`);</span><br></pre></td></tr></table></figure>
<p>使用如下语句查询：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from employees where birth_date = &apos;1953-09-02&apos; and first_name = &apos;Georgi&apos; and last_name = &apos;Facello&apos;;</span><br></pre></td></tr></table></figure>
<p>执行计划如下，可见该查询使用到了索引：</p>
<p><img src="https://img-blog.csdnimg.cn/2019081918193058.png" alt="在这里插入图片描述"></p>
<h3 id="联合索引匹配最左列原则"><a href="#联合索引匹配最左列原则" class="headerlink" title="联合索引匹配最左列原则"></a>联合索引匹配最左列原则</h3><p>对于复合索引来说，不总是匹配所有字段列，但是可以匹配索引中靠左的列</p>
<p>如果在(a,b,c)三个字段上建立联合索引，那么它能够加快 a | (a,b) | (a,b,c) 三组查询速度。</p>
<p>查询如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from employees where birth_date = &apos;1953-09-02&apos; and first_name = &apos;Georgi&apos;;</span><br></pre></td></tr></table></figure>
<p>执行计划：</p>
<p><img src="https://img-blog.csdnimg.cn/20190819182022353.png" alt="在这里插入图片描述"></p>
<p>将where中的first_name 改为last_name:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from employees where birth_date = &apos;1953-09-02&apos; and last_name = &apos;Facello&apos;;</span><br></pre></td></tr></table></figure>
<p>执行计划：</p>
<p><img src="https://img-blog.csdnimg.cn/20190819182032858.png" alt="在这里插入图片描述"></p>
<p>可见该查询只用到了复合索引中的一个列。</p>
<p>联合索引优化技巧：</p>
<ul>
<li><p>建联合索引的时候，区分度最高的字段在最左边。</p>
<blockquote>
<p>计算一个列的区分度可以使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; select count(distinct(column_name))/count(1) from table; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>计算出来的结果约接近1区分度越好。</p>
</blockquote>
</li>
<li><p>如果建立了(a,b)联合索引，就不必再单独建立 a 索引。同理，如果建立了(a,b,c)联合索引，就不必再单独建立 a、(a,b) 索引。</p>
</li>
<li><p>存在非等号和等号混合判断条件时，在建索引时，请把等号条件的列前置。如     where a&gt;? and b=?，那么即使 a 的区分度更高，也必须把 b 放在索引的最前列。</p>
</li>
<li><p>最左侧查询需求，并不是指 SQL 语句的 where 顺序要和联合索引一致，where的条件顺序MySQL会进行优化为使用适合的索引。</p>
</li>
<li>范围条件有：&lt;、&lt;=、&gt;、&gt;=、between等。范围列可以用到索引（联合索引必须是最左前缀），但是范围列后面的列无法用到索引，索引最多用于一个范围列，如果查询条件中有两个范围列则无法全用到索引。</li>
</ul>
<h3 id="使用覆盖索引"><a href="#使用覆盖索引" class="headerlink" title="使用覆盖索引"></a>使用覆盖索引</h3><p>MySQL可以使用索引来直接获取列的数据，这样就不需要再去读取数据行了。如果一个索引包含（或者说覆盖）所有需要查询的数据，就称为“覆盖索引”。</p>
<p>执行如下查询：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select birth_date, first_name, last_name from employees where birth_date = &apos;1953-09-02&apos; and first_name = &apos;Georgi&apos;;</span><br></pre></td></tr></table></figure>
<p>此时查询只获取birth_date, first_name, last_name列，而索引idx_bfl已经包含了这三列字段的数据，所以MySQL无需再通过索引idx_bfl查询到的data域中的主键值去主键索引文件中查询数据记录。</p>
<p>该查询的执行计划如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20190819182102664.png" alt="在这里插入图片描述"></p>
<p>其中Extra为Using index，说明使用了覆盖索引。</p>
<h3 id="避免强制类型转换"><a href="#避免强制类型转换" class="headerlink" title="避免强制类型转换"></a>避免强制类型转换</h3><p>强制类型转换的查询会导致全表扫描。</p>
<p>如果 salary字段是 varchar 类型，则下面的 SQL 不能命中索引。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from salaries where salary = 62102;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20190819182129436.png" alt="在这里插入图片描述"></p>
<p>可以优化为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from salaries where salary = &apos;62102&apos;;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20190819182149983.png" alt="在这里插入图片描述"></p>
<h2 id="InnoDB的主键选择与插入优化"><a href="#InnoDB的主键选择与插入优化" class="headerlink" title="InnoDB的主键选择与插入优化"></a>InnoDB的主键选择与插入优化</h2><p>在使用InnoDB存储引擎时，如果没有特别的需要，请永远使用一个与业务无关的自增字段作为主键。</p>
<p>上文讨论过InnoDB的索引实现，InnoDB使用聚集索引，数据记录本身被存于主索引（一颗B+Tree）的叶子节点上。这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）。</p>
<p>如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20190819182200838.png" alt="在这里插入图片描述"></p>
<p>这样就会形成一个紧凑的索引结构，近似顺序填满。由于每次插入时也不需要移动已有数据，因此效率很高，也不会增加很多开销在维护索引上。</p>
<p>如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置：</p>
<p><img src="https://img-blog.csdnimg.cn/20190819182209576.png" alt="在这里插入图片描述"></p>
<p>此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。</p>
<p>因此，只要可以，请尽量在InnoDB上采用自增字段做主键。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="只要是查询语句需要，就建上索引？"><a href="#只要是查询语句需要，就建上索引？" class="headerlink" title="只要是查询语句需要，就建上索引？"></a>只要是查询语句需要，就建上索引？</h3><p>不是，因为索引虽然加快了查询速度，但索引也是有代价的。索引文件本身要消耗存储空间，同时索引会加重插入、删除和修改记录时的负担。另外，MySQL 在运行时也要消耗资源维护索引，因此索引并不是越多越好。一般两种情况下不建议建索引。第一种情况是表记录比较少，例如一两千条甚至只有几百条记录的表，没必要建索引，另一种是数据的区分度比较低，可以使用 count(distinct(列名))/count(*) 来计算区分度。</p>
<h3 id="假如建立联合索引-a-b-c-，下列语句是否可以使用索引，如果可以，使用了那几列？"><a href="#假如建立联合索引-a-b-c-，下列语句是否可以使用索引，如果可以，使用了那几列？" class="headerlink" title="假如建立联合索引(a,b,c)，下列语句是否可以使用索引，如果可以，使用了那几列？"></a>假如建立联合索引(a,b,c)，下列语句是否可以使用索引，如果可以，使用了那几列？</h3><p>where a= 3</p>
<p>答：是，使用了 a 列。</p>
<p>where a= 3 and b = 5</p>
<p>答：是，使用了 a，b 列。</p>
<p>where a = 3 and c = 4 and b = 5</p>
<p>答：是，使用了 a，b，c 列。</p>
<p>where b= 3</p>
<p>答：否。</p>
<p>where a= 3 and c = 4</p>
<p>答：是，使用了 a 列。</p>
<p>where a = 3 and b &gt; 10 and c = 7</p>
<p>答：是，使用了 a，b 列。</p>
<p>where a = 3 and b like ‘xx%’  and c = 7</p>
<p>答：是，使用了 a，b 列。</p>
<h2 id="答疑"><a href="#答疑" class="headerlink" title="答疑"></a>答疑</h2><h3 id="关于执行计划的相关列含义"><a href="#关于执行计划的相关列含义" class="headerlink" title="关于执行计划的相关列含义"></a>关于执行计划的相关列含义</h3><ul>
<li><p>Extra列</p>
<blockquote>
<p>Extra列是不适合在其他列显示的额外信息。</p>
<p>常用值如下：</p>
<p>Using index：表示使用覆盖索引</p>
<p>Using where：需要回表查询，使用where来过滤条件</p>
<p>Using index condition：查找使用了索引，但是需要回表查询数据</p>
</blockquote>
</li>
<li><p>filtered：显示的是针对表里符合where子句或联接条件的记录数的百分比</p>
</li>
<li><p>type：访问类型</p>
<blockquote>
<p>ALL：全表扫描</p>
<p>index：也是全表扫描，但是按照索引的次序进行</p>
<p>range：范围扫描</p>
<p>ref：索引查找</p>
</blockquote>
</li>
<li><p>possible_keys：查询可以使用哪些索引</p>
</li>
<li><p>key：MySQL决定用哪个索引来优化查询</p>
</li>
<li><p>key_len：索引使用的字节数。如果MySQL正在使用的只是索引里的某些列，那么就可以用这个值来算出具体是哪些列</p>
</li>
<li><p>rows：MySQL为了找到所需的行而要读取的行数</p>
</li>
</ul>
<h3 id="聚集（簇）索引的优势在哪？"><a href="#聚集（簇）索引的优势在哪？" class="headerlink" title="聚集（簇）索引的优势在哪？"></a>聚集（簇）索引的优势在哪？</h3><p>看上去聚簇索引的效率明显要低于非聚簇索引，因为每次使用辅助索引检索都要经过两次B+树查找，那么聚簇索引的优势在哪？</p>
<ul>
<li><p>由于行数据和叶子节点存储在一起，这样主键和行数据是一起被载入内存的，找到叶子节点就可以立刻将行数据返回了，如果按照主键Id来组织数据，获得数据更快。</p>
</li>
<li><p>辅助索引使用主键作为”指针” 而不是使用行地址值作为指针的好处是，减少了当出现行移动或者数据页分裂时辅助索引的维护工作，使用主键值当作指针会让辅助索引占用更多的空间，换来的好处是InnoDB在移动行时无须更新辅助索引中的这个”指针”，使用聚簇索引可以保证不管这个主键B+树的节点如何变化，辅助索引树都不受影响。<br>原文链接：<a href="https://blog.csdn.net/molashaonian/article/details/83012176" target="_blank" rel="noopener">https://blog.csdn.net/molashaonian/article/details/83012176</a></p>
</li>
</ul>
<h3 id="使用in关键字时联合索引使用情况"><a href="#使用in关键字时联合索引使用情况" class="headerlink" title="使用in关键字时联合索引使用情况"></a>使用in关键字时联合索引使用情况</h3><p>本地测试的MySQL版本为5.7.19。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from employees where birth_date in (&apos;1953-09-02&apos;, &apos;1953-09-05&apos;)</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20190819182232154.png" alt="在这里插入图片描述"></p>
<p>由执行计划得知用到了联合索引中的最左列。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from employees where birth_date in (&apos;1953-09-02&apos;, &apos;1953-09-05&apos;) and first_name = &apos;Georgi&apos;;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/2019081918224125.png" alt="在这里插入图片描述"></p>
<p>通过key_len可以知道用到了联合索引中的前两个字段（当where条件只有birth_date条件时key_len为3，key_len是指MySQL在索引里使用的字节数）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from employees where birth_date = &apos;1953-09-02&apos; and first_name in (&apos;Georgi&apos;, &apos;xxx&apos;) and last_name = &apos;Facello&apos;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20190819182259343.png" alt="在这里插入图片描述"></p>
<p>通过key_len可以知道用到了联合索引中的所有字段</p>
<h3 id="使用范围查询时联合索引使用情况"><a href="#使用范围查询时联合索引使用情况" class="headerlink" title="使用范围查询时联合索引使用情况"></a>使用范围查询时联合索引使用情况</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from employees where birth_date = &apos;1953-09-02&apos; and first_name &gt; &apos;Georgi&apos; and last_name = &apos;Facello&apos;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20190819182310251.png" alt="在这里插入图片描述"></p>
<p>由执行计划得知，该查询使用到了联合索引的前两列。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap的四种遍历方式及遍历性能的测试</title>
    <url>/2018/08/18/HashMap%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E5%8F%8A%E9%81%8D%E5%8E%86%E6%80%A7%E8%83%BD%E7%9A%84%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> gsy.main.collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> gongshiyun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> hashmap 遍历方式练习,以及遍历性能测试</span></span><br><span class="line"><span class="comment"> * 输出:</span></span><br><span class="line"><span class="comment"> * Map 初始化1000000条数据时间: 1040014952</span></span><br><span class="line"><span class="comment"> * 遍历方式1:通过 keySet 进行循环遍历: 52262563</span></span><br><span class="line"><span class="comment"> * 遍历方式2:通过 Map.entrySet 使用 iterator 遍历 key 和 value: 40783708</span></span><br><span class="line"><span class="comment"> * 遍历方式3:通过 Map.entrySet 遍历 key 和 value: 34407489</span></span><br><span class="line"><span class="comment"> * 遍历方式4: 通过 map.keySet().iterator() 遍历: 32135582</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Map 初始化100000条数据时间: 35574972</span></span><br><span class="line"><span class="comment"> * 遍历方式1:通过 keySet 进行循环遍历: 13408674</span></span><br><span class="line"><span class="comment"> * 遍历方式2:通过 Map.entrySet 使用 iterator 遍历 key 和 value: 6436631</span></span><br><span class="line"><span class="comment"> * 遍历方式3:通过 Map.entrySet 遍历 key 和 value: 3298929</span></span><br><span class="line"><span class="comment"> * 遍历方式4: 通过 map.keySet().iterator() 遍历: 4588371</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Map 初始化1000条数据时间: 1227517</span></span><br><span class="line"><span class="comment"> * 遍历方式1:通过 keySet 进行循环遍历: 712118</span></span><br><span class="line"><span class="comment"> * 遍历方式2:通过 Map.entrySet 使用 iterator 遍历 key 和 value: 259776</span></span><br><span class="line"><span class="comment"> * 遍历方式3:通过 Map.entrySet 遍历 key 和 value: 154431</span></span><br><span class="line"><span class="comment"> * 遍历方式4: 通过 map.keySet().iterator() 遍历: 138950</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 总结: 从测试结果来看,遍历方式3和4性能较优</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/8/3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> t1, t2, t3, t4, t5, t6, init, initEnd;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> MAP_INIT_NUM = <span class="number">1000000</span>;</span><br><span class="line">        <span class="comment">// 指定初始值,赋值100000值所需时间21855171</span></span><br><span class="line">        <span class="comment">// 不指定初始值,赋值100000所需时间39124238</span></span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(MAP_INIT_NUM);</span><br><span class="line"></span><br><span class="line">        init = System.nanoTime();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAP_INIT_NUM; i++) &#123;</span><br><span class="line">            map.put(String.valueOf(i), String.valueOf(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        initEnd = System.nanoTime();</span><br><span class="line"></span><br><span class="line">        t1 = System.nanoTime();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 遍历方式1:通过 keySet 进行循环遍历</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(<span class="string">"遍历方式1:通过 keySet 进行循环遍历:"</span>);</span><br><span class="line">        <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">            <span class="comment">//System.out.println("Key: " + key + " Value: " + map.get(key));</span></span><br><span class="line">            map.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//map.keySet().forEach(k -&gt; map.get(k)); //使用forEach耗费时间更多</span></span><br><span class="line"></span><br><span class="line">        t2 = System.nanoTime();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 遍历方式2:通过 Map.entrySet 使用 iterator 遍历 key 和 value</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(<span class="string">"遍历方式2:通过 Map.entrySet 使用 iterator 遍历 key 和 value :"</span>);</span><br><span class="line">        Iterator iterator = map.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Map.Entry&lt;String, String&gt; entry = (Map.Entry&lt;String, String&gt;) iterator.next();</span><br><span class="line">            <span class="comment">//System.out.println("Key: " + entry.getKey() + " Value: " + entry.getValue());</span></span><br><span class="line">            entry.getValue();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        t3 = System.nanoTime();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 遍历方式3:通过 Map.entrySet 遍历 key 和 value</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(<span class="string">"遍历方式3:通过 Map.entrySet 遍历 key 和 value :"</span>);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            <span class="comment">//System.out.println("Key: " + entry.getKey() + " Value: " + entry.getValue());</span></span><br><span class="line">            entry.getValue();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//map.entrySet().forEach(k -&gt; k.getValue());</span></span><br><span class="line"></span><br><span class="line">        t4 = System.nanoTime();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 遍历方式4: 通过 map.keySet().iterator() 遍历</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(<span class="string">"遍历方式4: 通过 map.keySet().iterator() 遍历 :"</span>);</span><br><span class="line">        Iterator keyIt = map.keySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (keyIt.hasNext()) &#123;</span><br><span class="line">            Object key = keyIt.next();</span><br><span class="line">            map.get(key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        t5 = System.nanoTime();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Map 初始化"</span> + MAP_INIT_NUM + <span class="string">"条数据时间: "</span> + (initEnd - init));</span><br><span class="line">        System.out.println(<span class="string">"遍历方式1:通过 keySet 进行循环遍历: "</span> + (t2 - t1));</span><br><span class="line">        System.out.println(<span class="string">"遍历方式2:通过 Map.entrySet 使用 iterator 遍历 key 和 value: "</span> + (t3 - t2));</span><br><span class="line">        System.out.println(<span class="string">"遍历方式3:通过 Map.entrySet 遍历 key 和 value: "</span> + (t4 - t3));</span><br><span class="line">        System.out.println(<span class="string">"遍历方式4: 通过 map.keySet().iterator() 遍历: "</span> + (t5 - t4));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>集合</category>
      </categories>
      <tags>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>数值的整数次方</title>
    <url>/2018/07/22/%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/</url>
    <content><![CDATA[<p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。<br><a id="more"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leetcode.main;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> gongshiyun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 数值的整数次方</span></span><br><span class="line"><span class="comment"> * 给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/7/20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Power</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">solution1</span><span class="params">(<span class="keyword">double</span> base,<span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> result = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> k = Math.abs(exponent);</span><br><span class="line">        <span class="keyword">if</span> (exponent == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result = base;</span><br><span class="line">        <span class="keyword">while</span> (--k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            result *= base;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (exponent &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            result = <span class="number">1</span> / result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>二进制中1的个数</title>
    <url>/2018/07/22/%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。<br><a id="more"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leetcode.main;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> gongshiyun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 二进制中1的个数</span></span><br><span class="line"><span class="comment"> * 输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/7/20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberOf1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * n与n-1做与运算,将n二进制最后一位1的位置之后都变为0,</span></span><br><span class="line"><span class="comment">     * 当n最后为0时说明二进制中已经没有1</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solution1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            n &amp;= n - <span class="number">1</span>;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * n与1做与运算，结果为1说明n最后一位为1</span></span><br><span class="line"><span class="comment">     * 然后对n进行无符号右移，循环以上操作，直到n为0</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solution2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            n &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>变态跳台阶</title>
    <url>/2018/07/19/%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6/</url>
    <content><![CDATA[<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法<br><a id="more"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leetcode.main;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> gongshiyun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 变态跳台阶</span></span><br><span class="line"><span class="comment"> * 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。</span></span><br><span class="line"><span class="comment"> * 求该青蛙跳上一个n级的台阶总共有多少种跳法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/7/19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JumpFloorII</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 思路：</span></span><br><span class="line"><span class="comment">     * 找规律得出该结论：</span></span><br><span class="line"><span class="comment">     *        | 1  n=0</span></span><br><span class="line"><span class="comment">     * f(n) = | 1  n=1</span></span><br><span class="line"><span class="comment">     *        | 2*f(n-1) n &gt; 1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"参数不能小于0"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; (n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>跳台阶</title>
    <url>/2018/07/19/%E8%B7%B3%E5%8F%B0%E9%98%B6/</url>
    <content><![CDATA[<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。<br><a id="more"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leetcode.main;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> gongshiyun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 跳台阶：</span></span><br><span class="line"><span class="comment"> * 一只青蛙一次可以跳上1级台阶，也可以跳上2级。</span></span><br><span class="line"><span class="comment"> * 求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/7/19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JumpFloor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 思路：有两种跳法，一种跳一阶，另一种跳两阶;</span></span><br><span class="line"><span class="comment">     * 第一次跳如果跳一阶，剩下为f(n-1);</span></span><br><span class="line"><span class="comment">     * 如果跳两阶，剩下为f(n-2);</span></span><br><span class="line"><span class="comment">     * 所以f(n) = f(n-1) + f(n-2)。</span></span><br><span class="line"><span class="comment">     * 可以看出这是一个斐波那契数列。</span></span><br><span class="line"><span class="comment">     * 使用循环法。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jumpFloor</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"参数不能小于0"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> num1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> num2 = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (n-- &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            num2 += num1;</span><br><span class="line">            num1 = num2 - num1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>斐波那契数列</title>
    <url>/2018/07/19/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<p>输入一个整数n，输出斐波那契数列的第n项（从0开始，第0项为0,n&lt;=39)<br><a id="more"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leetcode.main;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> gongshiyun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。</span></span><br><span class="line"><span class="comment"> * n&lt;=39</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/7/19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fibonacci</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归法：重复计算情况过多</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fibonacciByRecursive</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fibonacciByRecursive(n - <span class="number">1</span>) + fibonacciByRecursive(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用循环</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fibonacciByCycle</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"参数不能为负"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> num1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            num2 += num1;</span><br><span class="line">            num1 = num2 - num1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>旋转数组的最小数字</title>
    <url>/2018/07/19/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<p>一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。<br>NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。<br><a id="more"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.leetcode.main;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> gongshiyun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。</span></span><br><span class="line"><span class="comment"> * 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。</span></span><br><span class="line"><span class="comment"> * 例如数组&#123;3,4,5,1,2&#125;为&#123;1,2,3,4,5&#125;的一个旋转，该数组的最小值为1。</span></span><br><span class="line"><span class="comment"> * NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/7/19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinNumberInRotateArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历数组，找到第一个比数组第一位小的数即为最小值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minInOrder</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> min = array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (min &gt; array[i]) &#123;</span><br><span class="line">                min = array[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用二分查找最小数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray2</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"数组为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (array.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (array[left] &gt;= array[right]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (right - left == <span class="number">1</span>) &#123;</span><br><span class="line">                mid = right;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 数组为非减排序，旋转后可能出现左右中位置的数相等的情况</span></span><br><span class="line">            <span class="comment">// 如非减排序数组[0,1,1,1,1]，旋转后可能为[1,0,1,1,1],[1,1,1,0,1]</span></span><br><span class="line">            <span class="comment">// 这种情况直接遍历数组</span></span><br><span class="line">            <span class="keyword">if</span> (array[left] == array[mid] &amp;&amp; array[mid] == array[right]) &#123;</span><br><span class="line">                <span class="keyword">return</span> minInOrder(array);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (array[mid] &lt;= array[right]) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[mid] &gt;= array[left]) &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[mid];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>用两个栈实现队列</title>
    <url>/2018/07/19/%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。<br>思路:<br>1.stack1作为入队列,stack2作为出队列<br>2.pop:当stack2为空时,stack1全部出栈到stack2,stack2再出栈顶部元素<br><a id="more"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leetcode.main;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> gongshiyun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</span></span><br><span class="line"><span class="comment"> *              思路:</span></span><br><span class="line"><span class="comment"> *              1.stack1作为入队列,stack2作为出队列</span></span><br><span class="line"><span class="comment"> *              2.pop:当stack2为空时,stack1全部出栈到stack2,stack2再出栈顶部元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/7/19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueByTwoStacks</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * stack1作为入队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * stack2作为出队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 入队列操作,入栈stack1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当stack2为空时,stack1全部出栈到stack2,stack2再出栈顶部元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack1.empty() &amp;&amp; stack2.empty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (stack2.empty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack1.empty())&#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>删除链表的倒数第 n 个节点</title>
    <url>/2018/07/17/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-n-%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。<br>示例：<br>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.<br>当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.<br>说明：<br>给定的 n 保证是有效的。<br>进阶：<br>尝试使用一趟扫描实现:快慢指针<br><a id="more"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leetcode.main;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.leetcode.entity.ListNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 19</span></span><br><span class="line"><span class="comment"> * 给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</span></span><br><span class="line"><span class="comment"> * 示例：</span></span><br><span class="line"><span class="comment"> * 给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.</span></span><br><span class="line"><span class="comment"> * 当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</span></span><br><span class="line"><span class="comment"> * 说明：</span></span><br><span class="line"><span class="comment"> * 给定的 n 保证是有效的。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> gongshiyun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2018/5/3 22:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoveNthFromEnd</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ListNode l1 = <span class="keyword">new</span> ListNode(<span class="number">2</span>);</span><br><span class="line">        ListNode l2 = <span class="keyword">new</span> ListNode(<span class="number">4</span>);</span><br><span class="line">        <span class="comment">//ListNode l3 = new ListNode(3);</span></span><br><span class="line">        <span class="comment">//ListNode l4 = new ListNode(5);</span></span><br><span class="line">        <span class="comment">//ListNode l5 = new ListNode(6);</span></span><br><span class="line"></span><br><span class="line">        l1.setNext(l2);</span><br><span class="line">        <span class="comment">//l2.setNext(l3);</span></span><br><span class="line">        <span class="comment">//l3.setNext(l4);</span></span><br><span class="line">        <span class="comment">//l4.setNext(l5);</span></span><br><span class="line">        ListNode result = removeNthFromEnd(l1,<span class="number">1</span>);</span><br><span class="line">        System.out.print(result.val);</span><br><span class="line">        <span class="keyword">while</span> (result.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(<span class="string">" -&gt; "</span>);</span><br><span class="line">            result = result.next;</span><br><span class="line">            System.out.print(result.val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 思想:使用快慢指针,一个快n步遍历,当快指针到达末尾,慢指针指向要删除的节点</span></span><br><span class="line"><span class="comment">     * head-&gt;a-&gt;b-&gt;c-&gt;d</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode headNode = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        headNode.next = head;</span><br><span class="line">        ListNode fastNode = headNode;</span><br><span class="line">        ListNode slowNode = headNode;</span><br><span class="line">        <span class="keyword">while</span> (fastNode.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            fastNode = fastNode.next;</span><br><span class="line">            <span class="keyword">if</span> (n-- &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                slowNode = slowNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (slowNode.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            slowNode.next = slowNode.next.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> headNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>从尾到头打印链表</title>
    <url>/2018/07/17/%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>输入一个链表，从尾到头打印链表每个节点的值。<br><a id="more"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leetcode.main;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.leetcode.entity.ListNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从尾到头打印链表</span></span><br><span class="line"><span class="comment"> * 输入一个链表，从尾到头打印链表每个节点的值。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> gongshiyun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2018/6/26 1:27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReversePrintListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; arr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ListNode l1 = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        ListNode l2 = <span class="keyword">new</span> ListNode(<span class="number">2</span>);</span><br><span class="line">        ListNode l3 = <span class="keyword">new</span> ListNode(<span class="number">3</span>);</span><br><span class="line">        ListNode l4 = <span class="keyword">new</span> ListNode(<span class="number">4</span>);</span><br><span class="line">        ListNode l5 = <span class="keyword">new</span> ListNode(<span class="number">5</span>);</span><br><span class="line">        ListNode l6 = <span class="keyword">new</span> ListNode(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        l1.setNext(l2);</span><br><span class="line">        l2.setNext(l3);</span><br><span class="line">        l3.setNext(l4);</span><br><span class="line">        l4.setNext(l5);</span><br><span class="line">        l5.setNext(l6);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//printListFromTailToHead(l1);</span></span><br><span class="line">        <span class="comment">//ArrayList&lt;Integer&gt; arr = getListFromTailToHead(l1);</span></span><br><span class="line">        ArrayList&lt;Integer&gt; arr = printListFromTailToHeadByStack(l1);</span><br><span class="line">        <span class="keyword">if</span> (arr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> val : arr) &#123;</span><br><span class="line">                System.out.println(val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">getListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; arr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        printListFromTailToHead(listNode, arr);</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用递归方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listNode</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode, ArrayList&lt;Integer&gt; arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (listNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            printListFromTailToHead(listNode.next, arr);</span><br><span class="line">            arr.add(listNode.val);</span><br><span class="line">            <span class="comment">//System.out.println(listNode.val);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用栈</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listNode</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHeadByStack</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (listNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(listNode.val);</span><br><span class="line">            listNode = listNode.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stack.empty()) &#123;</span><br><span class="line">            result.add(stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>Thread基础知识</title>
    <url>/2018/07/16/Thread%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li>java的线程是通过java.lang.Thread类来实现的。</li>
<li>VM启动时会有一个由主方法所定义的线程。</li>
<li>可以通过创建Thread的实例来创建新的线程。</li>
<li>每个线程都是通过某个特定Thread对象所对应的方法run()来完成其操作的，<strong>方法run()称为线程体</strong>。</li>
<li><strong>通过调用Thread类的start()方法来启动一个线程。</strong></li>
</ul>
<hr>
<a id="more"></a>
<h3 id="线程的5种状态"><a href="#线程的5种状态" class="headerlink" title="线程的5种状态"></a>线程的5种状态</h3><ul>
<li><strong>创建</strong>:生成了线程对象,并没有调用该对象的start方法,这是线程处于创建状态。</li>
<li><strong>就绪</strong>:当调用了线程对象的start方法之后，该线程就进入了就绪状态，但是此时线程调度程序还没有把该线程设置为当前线程，此时处于就绪状态。在线程运行之后，从等待或者睡眠中回来之后，也会处于就绪状态。</li>
<li><strong>运行</strong>:线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行run函数当中的代码。</li>
<li><strong>阻塞</strong>:线程正在运行的时候，被暂停，通常是为了等待某个时间的发生(比如说某项资源就绪)之后再继续运行。sleep,suspend，wait等方法都可以导致线程阻塞。</li>
<li><strong>死亡</strong>:如果一个线程的run方法执行结束或者调用stop方法后，该线程就会死亡。对于已经死亡的线程，无法再使用start方法令其进入就绪。</li>
</ul>
<hr>
<h3 id="实现并启动线程方法"><a href="#实现并启动线程方法" class="headerlink" title="实现并启动线程方法"></a>实现并启动线程方法</h3><ul>
<li>写一个类继承自Thread类，重写run方法。用start方法启动线程</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 继承Thread类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">　　<span class="comment">//重写run方法</span></span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//创建并启动线程</span></span><br><span class="line">　　　　<span class="keyword">new</span> MyThread().start();</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>写一个类实现Runnable接口，实现run方法。用new Thread(Runnable target).start()方法来启动</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现Runnable接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//重写run方法</span></span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">　　　　<span class="comment">//创建并启动线程</span></span><br><span class="line"></span><br><span class="line">　　　　MyThread2 myThread=<span class="keyword">new</span> MyThread2();</span><br><span class="line"></span><br><span class="line">　　　　Thread thread=<span class="keyword">new</span> Thread(myThread);</span><br><span class="line"></span><br><span class="line">　　　　thread().start();</span><br><span class="line"></span><br><span class="line">　　　　<span class="comment">//或者</span></span><br><span class="line">       <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread2()).start();</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用Callable和Future创建线程</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">　　　MyThread3 th=<span class="keyword">new</span> MyThread3();</span><br><span class="line"></span><br><span class="line">　　　<span class="comment">//使用Lambda表达式创建Callable对象</span></span><br><span class="line"></span><br><span class="line">　　  <span class="comment">//使用FutureTask类来包装Callable对象</span></span><br><span class="line"></span><br><span class="line">　　　FutureTask&lt;Integer&gt; future=<span class="keyword">new</span> FutureTask&lt;Integer&gt;(</span><br><span class="line"></span><br><span class="line">　　　　(Callable&lt;Integer&gt;)()-&gt;&#123;</span><br><span class="line"></span><br><span class="line">　　　　　　<span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　  );</span><br><span class="line">      <span class="comment">//实质上还是以Callable对象来创建并启动线程</span></span><br><span class="line">　　　<span class="keyword">new</span> Thread(future,<span class="string">"有返回值的线程"</span>).start();</span><br><span class="line"></span><br><span class="line">　　  <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//get()方法会阻塞，直到子线程执行结束才返回</span></span><br><span class="line">　　　　System.out.println(<span class="string">"子线程的返回值："</span>+future.get());</span><br><span class="line"></span><br><span class="line"> 　　 &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line"></span><br><span class="line">　　　　ex.printStackTrace();</span><br><span class="line"></span><br><span class="line">　　　&#125;</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="三种创建线程方法对比"><a href="#三种创建线程方法对比" class="headerlink" title="三种创建线程方法对比"></a>三种创建线程方法对比</h3><p>实现Runnable和实现Callable接口的方式基本相同，不过是后者执行call()方法有返回值，后者线程执行体run()方法无返回值，因此可以把这两种方式归为一种这种方式与继承Thread类的方法之间的差别如下：</p>
<ul>
<li><p>线程只是实现Runnable或实现Callable接口，还可以继承其他类。</p>
</li>
<li><p>这种方式下，多个线程可以共享一个target对象，非常适合多线程处理同一份资源的情形。</p>
</li>
<li><p>但是编程稍微复杂，如果需要访问当前线程，必须调用Thread.currentThread()方法。</p>
</li>
<li><p>继承Thread类的线程类不能再继承其他父类（Java单继承决定）。</p>
</li>
</ul>
<h4 id="注：一般推荐采用实现接口的方式来创建多线程"><a href="#注：一般推荐采用实现接口的方式来创建多线程" class="headerlink" title="注：一般推荐采用实现接口的方式来创建多线程"></a>注：一般推荐采用实现接口的方式来创建多线程</h4><hr>
<h3 id="start和run方法区别"><a href="#start和run方法区别" class="headerlink" title="start和run方法区别"></a>start和run方法区别</h3><ul>
<li>start()方法来启动线程，真正实现了多线程运行。这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码；<strong>通过调用Thread类的start()方法来启动一个线程， 这时此线程是处于就绪状态， 并没有运行</strong>。 然后通过此Thread类调用方法run()来完成其运行操作的， 这里方法run()称为线程体，它包含了要执行的这个线程的内容， Run方法运行结束， 此线程终止。然后CPU再调度其它线程。</li>
<li><strong>run()方法当作普通方法的方式调用</strong>。程序还是要顺序执行，要等待run方法体执行完毕后，才可继续执行下面的代码； 程序中只有主线程——这一个线程， 其程序执行路径还是只有一条， 这样就没有达到写线程的目的。</li>
</ul>
<hr>
<h4 id="多线程就是分时利用CPU，宏观上让所有线程一起执行-，也叫并发"><a href="#多线程就是分时利用CPU，宏观上让所有线程一起执行-，也叫并发" class="headerlink" title="多线程就是分时利用CPU，宏观上让所有线程一起执行 ，也叫并发"></a><strong>多线程就是分时利用CPU，宏观上让所有线程一起执行 ，也叫并发</strong></h4>]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-单例模式代码示例</title>
    <url>/2018/07/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B/</url>
    <content><![CDATA[<h4 id="饿汉"><a href="#饿汉" class="headerlink" title="饿汉"></a>饿汉</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 单例模式-饿汉</span></span><br><span class="line"><span class="comment"> *  优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。</span></span><br><span class="line"><span class="comment"> *  缺点：在类装载的时候就完成实例化，没有达到Lazy Loading的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> gongshiyun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/07/05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类装载时实例化静态常量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HungrySingleton INSTANCE = <span class="keyword">new</span> HungrySingleton();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态代码块模式</span></span><br><span class="line"><span class="comment">     * 类实例化的过程放在了静态代码块中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/*static &#123;</span></span><br><span class="line"><span class="comment">        INSTANCE = new HungrySingleton();</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="懒汉-线程不安全"><a href="#懒汉-线程不安全" class="headerlink" title="懒汉(线程不安全)"></a>懒汉(线程不安全)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 单例模式-懒汉(线程不安全)</span></span><br><span class="line"><span class="comment"> * 这种写法起到了Lazy Loading的效果，但是只能在单线程下使用。</span></span><br><span class="line"><span class="comment"> * 如果在多线程下，一个线程进入了if (singleton == null)判断语句块，</span></span><br><span class="line"><span class="comment"> * 还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。</span></span><br><span class="line"><span class="comment"> * 所以在多线程环境下不可使用这种方式。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> gongshiyun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/7/5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="懒汉-线程安全-同步方法"><a href="#懒汉-线程安全-同步方法" class="headerlink" title="懒汉(线程安全,同步方法)"></a>懒汉(线程安全,同步方法)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> gongshiyun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> SafeLazySingleton</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 单例模式-懒汉(线程安全,同步方法)</span></span><br><span class="line"><span class="comment"> * 缺点：效率低，每个线程获取类的实例都需要进行同步</span></span><br><span class="line"><span class="comment"> * 而其实这个方法只执行一次实例化代码就够了，后面的想</span></span><br><span class="line"><span class="comment"> * 获得该类实例，直接return就行了。方法进行同步效率太低要改进。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/7/5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeLazySingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SafeLazySingleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SafeLazySingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SafeLazySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SafeLazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="双重检查"><a href="#双重检查" class="headerlink" title="双重检查"></a>双重检查</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> gongshiyun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> DbCheckSingleton</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 双重检查</span></span><br><span class="line"><span class="comment"> * 优点：线程安全；延迟加载；效率较高。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/7/5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DbCheckSingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> DbCheckSingleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DbCheckSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DbCheckSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (DbCheckSingleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> DbCheckSingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> gongshiyun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> Singleton</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 静态内部类[推荐用]</span></span><br><span class="line"><span class="comment"> * 这种方式跟饿汉式方式采用的机制类似，但又有不同。</span></span><br><span class="line"><span class="comment"> * 两者都是采用了类装载的机制来保证初始化实例时只有一个线程。</span></span><br><span class="line"><span class="comment"> * 不同的地方在饿汉式方式是只要Singleton类被装载就会实例化，</span></span><br><span class="line"><span class="comment"> * 没有Lazy-Loading的作用，而静态内部类方式在Singleton类</span></span><br><span class="line"><span class="comment"> * 被装载时并不会立即实例化，而是在需要实例化时，调用getInstance方法，</span></span><br><span class="line"><span class="comment"> * 才会装载SingletonInstance类，从而完成Singleton的实例化。</span></span><br><span class="line"><span class="comment"> * 类的静态属性只会在第一次加载类的时候初始化，所以在这里，</span></span><br><span class="line"><span class="comment"> * JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。</span></span><br><span class="line"><span class="comment"> * 优点：避免了线程不安全，延迟加载，效率高。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/7/5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInstance</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonInstance.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> gongshiyun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> EnumSingleton</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 枚举实现单例模式</span></span><br><span class="line"><span class="comment"> * 不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/7/5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EnumSingleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
</search>
