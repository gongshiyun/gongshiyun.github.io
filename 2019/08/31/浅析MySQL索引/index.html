<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/upload/favicon.ico?v=7.4.2">
  <link rel="icon" type="image/png" sizes="32x32" href="/upload/favicon.ico?v=7.4.2">
  <link rel="icon" type="image/png" sizes="16x16" href="/upload/favicon.ico?v=7.4.2">

<link rel="stylesheet" href="/css/main.css?v=7.4.2">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.4.2',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"flat"},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="参考资料   资料名称 来源地址     《MySQL王者晋级之路》 图书   《高性能MySQL》 图书   MySQL官方文档 https://dev.mysql.com/doc/   《MySQL索引背后的数据结构及算法原理》 http://blog.codinglabs.org/articles/theory-of-mysql-index.html">
<meta name="keywords" content="MySQL">
<meta property="og:type" content="article">
<meta property="og:title" content="浅析MySQL索引">
<meta property="og:url" content="gongshiyun.top/2019/08/31/浅析MySQL索引/index.html">
<meta property="og:site_name" content="gsyun&#39;s blog">
<meta property="og:description" content="参考资料   资料名称 来源地址     《MySQL王者晋级之路》 图书   《高性能MySQL》 图书   MySQL官方文档 https://dev.mysql.com/doc/   《MySQL索引背后的数据结构及算法原理》 http://blog.codinglabs.org/articles/theory-of-mysql-index.html">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190819181704873.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190819181727194.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190819181740530.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM5OTc0Ng==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190819181755308.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM5OTc0Ng==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190819181808960.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM5OTc0Ng==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190819181821472.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM5OTc0Ng==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190819181904638.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM5OTc0Ng==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2019081918193058.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190819182022353.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190819182032858.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190819182102664.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190819182129436.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190819182149983.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190819182200838.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190819182209576.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190819182232154.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2019081918224125.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190819182259343.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190819182310251.png">
<meta property="og:updated_time" content="2019-10-26T11:30:59.120Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="浅析MySQL索引">
<meta name="twitter:description" content="参考资料   资料名称 来源地址     《MySQL王者晋级之路》 图书   《高性能MySQL》 图书   MySQL官方文档 https://dev.mysql.com/doc/   《MySQL索引背后的数据结构及算法原理》 http://blog.codinglabs.org/articles/theory-of-mysql-index.html">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20190819181704873.png">

<link rel="canonical" href="gongshiyun.top/2019/08/31/浅析MySQL索引/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>浅析MySQL索引 | gsyun's blog</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?1569499920513";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">gsyun's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="gongshiyun.top/2019/08/31/浅析MySQL索引/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/upload/me.jpg">
      <meta itemprop="name" content="龚士云">
      <meta itemprop="description" content="I'm gonna ride 'til I can't no more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gsyun's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          浅析MySQL索引
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-08-31 13:30:14" itemprop="dateCreated datePublished" datetime="2019-08-31T13:30:14+08:00">2019-08-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-10-26 19:30:59" itemprop="dateModified" datetime="2019-10-26T19:30:59+08:00">2019-10-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index">
                    <span itemprop="name">MySQL</span>
                  </a>
                </span>
            </span>

          
            <span id="/2019/08/31/浅析MySQL索引/" class="post-meta-item leancloud_visitors" data-flag-title="浅析MySQL索引" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/08/31/浅析MySQL索引/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/08/31/浅析MySQL索引/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><table>
<thead>
<tr>
<th>资料名称</th>
<th>来源地址</th>
</tr>
</thead>
<tbody>
<tr>
<td>《MySQL王者晋级之路》</td>
<td>图书</td>
</tr>
<tr>
<td>《高性能MySQL》</td>
<td>图书</td>
</tr>
<tr>
<td>MySQL官方文档</td>
<td><a href="https://dev.mysql.com/doc/" target="_blank" rel="noopener">https://dev.mysql.com/doc/</a></td>
</tr>
<tr>
<td>《MySQL索引背后的数据结构及算法原理》</td>
<td><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">http://blog.codinglabs.org/articles/theory-of-mysql-index.html</a></td>
</tr>
</tbody>
</table><a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>MySQL的索引是存储引擎用于快速查找记录的一种数据结构。工作原理是先从索引上找到对应值，再根据匹配的索引记录找到对应的数据行。索引的目的在于提高查询效率，可类比字典、书籍的目录等这种形式。</p>
<h2 id="数据结构介绍"><a href="#数据结构介绍" class="headerlink" title="数据结构介绍"></a>数据结构介绍</h2><p>目前大部分数据库系统及文件系统都采用B-Tree或其变种B+Tree作为索引结构。实际上MySQL的很多存储引擎如最常见的innoDB使用的是B+Tree，即每个叶子节点都包含指向下一个叶子节点的指针，从而方便叶子节点的范围遍历。</p>
<h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h3><p><img src="https://img-blog.csdnimg.cn/20190819181704873.png" alt="在这里插入图片描述"></p>
<h3 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h3><p><img src="https://img-blog.csdnimg.cn/20190819181727194.png" alt="在这里插入图片描述"></p>
<h3 id="为什么要使用这种数据结构"><a href="#为什么要使用这种数据结构" class="headerlink" title="为什么要使用这种数据结构"></a>为什么要使用这种数据结构</h3><p>从理论上讲，二叉树查找速度和比较次数都是最小的，为什么不用二叉树呢？ </p>
<p>首先索引本质上是一种数据结构，占用空间也很大，不可能全部存储在内存中，一般以索引文件形式存储在磁盘上，所以查找索引时就涉及到从磁盘中读取数据，就会有I/O消耗。相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数，对于树来说，IO次数就是树的高度，而“矮胖”就是b树的特征之一。</p>
<p>磁盘读取数据时，并不是只读取所需要的数据就行，而是会从读取数据的起始处往后读取一定长度的数据。这就涉及到局部性原理和磁盘的预读机制的概念：</p>
<h4 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h4><p>当一个数据被用到时，其附近的数据也通常会马上被使用。</p>
<h4 id="磁盘预读机制"><a href="#磁盘预读机制" class="headerlink" title="磁盘预读机制"></a>磁盘预读机制</h4><p>因为磁盘存取速度比内存慢很多，根据局部性原理，为了提高效率，需要尽量减少磁盘I/O，磁盘每次都要从读取的数据位置顺序向后读取一页数据的整数倍放入内存中。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页的大小通常为4k）。</p>
<p>B-Tree每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个节点只需一次I/O。</p>
<p>B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存，h为树的高度），渐进复杂度为$O(h)=O(log_dN)$。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。</p>
<p>综上所述，用B-Tree作为索引结构效率是非常高的。</p>
<p>比如红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为$O(h)$，效率明显比B-Tree差很多。</p>
<h2 id="MySQL索引实现"><a href="#MySQL索引实现" class="headerlink" title="MySQL索引实现"></a>MySQL索引实现</h2><h3 id="MyISAM索引实现"><a href="#MyISAM索引实现" class="headerlink" title="MyISAM索引实现"></a>MyISAM索引实现</h3><p><img src="https://img-blog.csdnimg.cn/20190819181740530.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM5OTc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>MyISAM索引的数据结构是B+Tree结构，在叶子节点处保存的是数据记录的地址</p>
<p><img src="https://img-blog.csdnimg.cn/20190819181755308.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM5OTc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>辅助索引与主键索引除了主键索引具有唯一性外，其他地方没有任何区别，在叶子节点处仅保存数据记录的地址。搜索数据记录时先使用B+Tree的搜索算法找出数据地址，再根据数据地址找出数据记录。</p>
<p>MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分。</p>
<p>###　InnoDB索引实现</p>
<p><img src="https://img-blog.csdnimg.cn/20190819181808960.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM5OTc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>InnoDB引擎也是使用B+Tree作为索引结构。</p>
<p>与MyISAM引擎的索引实现方式不同在于InnoDB的数据文件本身就是主键的索引文件。</p>
<p>由上图可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p>
<p><img src="https://img-blog.csdnimg.cn/20190819181821472.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM5OTc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。</p>
<p>所以聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。</p>
<h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><h3 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h3><p>主键索引就是聚集索引，每张表中有且仅有一个主键，可以由表中一个或多个字段组成。</p>
<ul>
<li><p>主键值必须唯一</p>
</li>
<li><p>不能包含null值</p>
</li>
</ul>
<p>创建主键索引语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table table_name add primary key(column_list);</span><br></pre></td></tr></table></figure>
<h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><p>唯一索引是约束条件的一种，就是不允许有重复的值，但是可以允许有null值。表的主键只能有一个，但是唯一索引可以有多个。</p>
<p>创建唯一索引的语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create unique index index_name on table_name (column_list);</span><br><span class="line">-- 或</span><br><span class="line">alter table table_name add unique (column_list);</span><br></pre></td></tr></table></figure>
<h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><p>对于BLOB，TEXT或者很长的VARCHAR类型的列，为它们的前n个字符（具体几个由创建索引时指定）建立索引，这样的索引就叫前缀索引。这样建立的索引更小，查询更快。</p>
<p>创建前缀索引的语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create index index_name on table_name(column_name(prefix_length));</span><br><span class="line">-- 或</span><br><span class="line">alter table table_name add key(column_name(prefix_length));</span><br></pre></td></tr></table></figure>
<h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><p>联合索引又叫复合索引，是在表中两个或两个以上的列上创建的索引。利用索引的附加列，可以缩小检索的范围，更快搜索到数据。</p>
<p>创建联合索引的语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create index index_name on table_name (column_list);</span><br><span class="line">-- 或</span><br><span class="line">alter table table_name add index index_name (column_list);</span><br></pre></td></tr></table></figure>
<p>假设表t有c1，c2两个字段，为它们创建联合索引：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create index idx_c1_c2 on t (c1, c2);</span><br></pre></td></tr></table></figure>
<p>联合索引的使用必须满足最左前缀原则。一般把选择性高的列放在前面。一条查询语句可以只使用索引中的一部分，但是必须从最左侧开始。联合idx_c1_c2可以用到c1索引和c1，c2索引，但用不到c2索引。</p>
<p>以下查询可以用到idx_c1_c2的索引：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select * from t where c1 = &apos;xxx&apos;;</span><br><span class="line">select * from t where c1 = &apos;xxx&apos; and c2 = &apos;xxxx&apos;;</span><br><span class="line">select * from t where c1 = &apos;xxx&apos; and c2 in (&apos;xxxx&apos;, &apos;xxx&apos;);</span><br><span class="line">select * from t where c1 = (&apos;xxx&apos;, &apos;xxxx&apos;) and c2 = &apos;xxx&apos;;</span><br><span class="line">select * from t order by c1, c2;</span><br><span class="line">select * from t where c1 = &apos;xxx&apos; order by c2;</span><br></pre></td></tr></table></figure>
<p>用不到idx_c1_c2索引的查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from t where c2 = &apos;xxx&apos;;</span><br><span class="line">select * from t where c2 = &apos;xxx&apos; order by c1;</span><br></pre></td></tr></table></figure>
<p>另外，使用or关键字也是不能使用到联合索引的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where c1 = &apos;xxx&apos; or c2 = &apos;xxxx&apos;;</span><br></pre></td></tr></table></figure>
<p>这种情况就要在c1，c2各自建两个单列索引。</p>
<h3 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h3><p>哈希索引采用哈希算法，将键值换算成哈希值。哈希值只能进行等值查询，不能进行排序、模糊查找、范围查询等。检索时不需要像B+Tree那样从根节点到叶子节点逐级查找，只需一次哈希算法即可立刻定位到相应的位置，查询速度非常快。</p>
<p>innodb引擎支持哈希索引，称为自适应哈希索引，但是需要通过innodb_adaptive_hash_index参数来启用，默认是启用的。hash索引的创建由InnoDB存储引擎引擎自动优化创建。哈希索引只能用来搜索等值的查询，对于其他查找类型，如范围查找，是不能使用哈希索引的</p>
<p><img src="https://img-blog.csdnimg.cn/20190819181904638.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM5OTc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><p>全文索引是在基于文本的列（char、varchar或text列）上创建的，有助于提高对这些列中文本的查询速度和DML操作效率。</p>
<p>InnoDB引擎对全文索引的支持是MySQL5.6新引入的特性，之前只有MyISAM引擎支持全文索引。对于全文索引的内容可以使用MATCH()…AGAINST语法进行查询。MySQL5.6不支持中文全文索引，因为与英文不同，中文的文字是连着一起写的，中间没有MySQL能找到分词的地方。MySQL 5.7开始，MySQL内置了ngram全文检索插件，用来支持中文分词，并且对MyISAM和InnoDB引擎有效。</p>
<p>添加全文索引:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table table_name add fulltext index index_name(column_list) with parser ngram;</span><br></pre></td></tr></table></figure>
<p>查询语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MATCH(col1,col2,…) AGAINST (expr[search_modifier])</span><br></pre></td></tr></table></figure>
<h2 id="索引使用策略和优化技巧"><a href="#索引使用策略和优化技巧" class="headerlink" title="索引使用策略和优化技巧"></a>索引使用策略和优化技巧</h2><p>创建一个员工表用于示例，并导入数据，数据来源：<a href="https://dev.mysql.com/doc/employee/en/" target="_blank" rel="noopener">https://dev.mysql.com/doc/employee/en/</a></p>
<p>表结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE employees (</span><br><span class="line">    emp_no      INT             NOT NULL,</span><br><span class="line">    birth_date  DATE            NOT NULL,</span><br><span class="line">    first_name  VARCHAR(14)     NOT NULL,</span><br><span class="line">    last_name   VARCHAR(16)     NOT NULL,</span><br><span class="line">    gender      ENUM (&apos;M&apos;,&apos;F&apos;)  NOT NULL,    </span><br><span class="line">    hire_date   DATE            NOT NULL,</span><br><span class="line">    PRIMARY KEY (emp_no)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="全值匹配"><a href="#全值匹配" class="headerlink" title="全值匹配"></a>全值匹配</h3><p>全值匹配是指索引匹配查询条件的所有列</p>
<p>为字段birth_date, first_name, last_name创建联合索引：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table employees add index idx_bfl(`birth_date`, `first_name`, `last_name`);</span><br></pre></td></tr></table></figure>
<p>使用如下语句查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from employees where birth_date = &apos;1953-09-02&apos; and first_name = &apos;Georgi&apos; and last_name = &apos;Facello&apos;;</span><br></pre></td></tr></table></figure>
<p>执行计划如下，可见该查询使用到了索引：</p>
<p><img src="https://img-blog.csdnimg.cn/2019081918193058.png" alt="在这里插入图片描述"></p>
<h3 id="联合索引匹配最左列原则"><a href="#联合索引匹配最左列原则" class="headerlink" title="联合索引匹配最左列原则"></a>联合索引匹配最左列原则</h3><p>对于复合索引来说，不总是匹配所有字段列，但是可以匹配索引中靠左的列</p>
<p>如果在(a,b,c)三个字段上建立联合索引，那么它能够加快 a | (a,b) | (a,b,c) 三组查询速度。</p>
<p>查询如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from employees where birth_date = &apos;1953-09-02&apos; and first_name = &apos;Georgi&apos;;</span><br></pre></td></tr></table></figure>
<p>执行计划：</p>
<p><img src="https://img-blog.csdnimg.cn/20190819182022353.png" alt="在这里插入图片描述"></p>
<p>将where中的first_name 改为last_name:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from employees where birth_date = &apos;1953-09-02&apos; and last_name = &apos;Facello&apos;;</span><br></pre></td></tr></table></figure>
<p>执行计划：</p>
<p><img src="https://img-blog.csdnimg.cn/20190819182032858.png" alt="在这里插入图片描述"></p>
<p>可见该查询只用到了复合索引中的一个列。</p>
<p>联合索引优化技巧：</p>
<ul>
<li><p>建联合索引的时候，区分度最高的字段在最左边。</p>
<blockquote>
<p>计算一个列的区分度可以使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; select count(distinct(column_name))/count(1) from table; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>计算出来的结果约接近1区分度越好。</p>
</blockquote>
</li>
<li><p>如果建立了(a,b)联合索引，就不必再单独建立 a 索引。同理，如果建立了(a,b,c)联合索引，就不必再单独建立 a、(a,b) 索引。</p>
</li>
<li><p>存在非等号和等号混合判断条件时，在建索引时，请把等号条件的列前置。如     where a&gt;? and b=?，那么即使 a 的区分度更高，也必须把 b 放在索引的最前列。</p>
</li>
<li><p>最左侧查询需求，并不是指 SQL 语句的 where 顺序要和联合索引一致，where的条件顺序MySQL会进行优化为使用适合的索引。</p>
</li>
<li>范围条件有：&lt;、&lt;=、&gt;、&gt;=、between等。范围列可以用到索引（联合索引必须是最左前缀），但是范围列后面的列无法用到索引，索引最多用于一个范围列，如果查询条件中有两个范围列则无法全用到索引。</li>
</ul>
<h3 id="使用覆盖索引"><a href="#使用覆盖索引" class="headerlink" title="使用覆盖索引"></a>使用覆盖索引</h3><p>MySQL可以使用索引来直接获取列的数据，这样就不需要再去读取数据行了。如果一个索引包含（或者说覆盖）所有需要查询的数据，就称为“覆盖索引”。</p>
<p>执行如下查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select birth_date, first_name, last_name from employees where birth_date = &apos;1953-09-02&apos; and first_name = &apos;Georgi&apos;;</span><br></pre></td></tr></table></figure>
<p>此时查询只获取birth_date, first_name, last_name列，而索引idx_bfl已经包含了这三列字段的数据，所以MySQL无需再通过索引idx_bfl查询到的data域中的主键值去主键索引文件中查询数据记录。</p>
<p>该查询的执行计划如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20190819182102664.png" alt="在这里插入图片描述"></p>
<p>其中Extra为Using index，说明使用了覆盖索引。</p>
<h3 id="避免强制类型转换"><a href="#避免强制类型转换" class="headerlink" title="避免强制类型转换"></a>避免强制类型转换</h3><p>强制类型转换的查询会导致全表扫描。</p>
<p>如果 salary字段是 varchar 类型，则下面的 SQL 不能命中索引。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from salaries where salary = 62102;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20190819182129436.png" alt="在这里插入图片描述"></p>
<p>可以优化为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from salaries where salary = &apos;62102&apos;;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20190819182149983.png" alt="在这里插入图片描述"></p>
<h2 id="InnoDB的主键选择与插入优化"><a href="#InnoDB的主键选择与插入优化" class="headerlink" title="InnoDB的主键选择与插入优化"></a>InnoDB的主键选择与插入优化</h2><p>在使用InnoDB存储引擎时，如果没有特别的需要，请永远使用一个与业务无关的自增字段作为主键。</p>
<p>上文讨论过InnoDB的索引实现，InnoDB使用聚集索引，数据记录本身被存于主索引（一颗B+Tree）的叶子节点上。这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）。</p>
<p>如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20190819182200838.png" alt="在这里插入图片描述"></p>
<p>这样就会形成一个紧凑的索引结构，近似顺序填满。由于每次插入时也不需要移动已有数据，因此效率很高，也不会增加很多开销在维护索引上。</p>
<p>如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置：</p>
<p><img src="https://img-blog.csdnimg.cn/20190819182209576.png" alt="在这里插入图片描述"></p>
<p>此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。</p>
<p>因此，只要可以，请尽量在InnoDB上采用自增字段做主键。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="只要是查询语句需要，就建上索引？"><a href="#只要是查询语句需要，就建上索引？" class="headerlink" title="只要是查询语句需要，就建上索引？"></a>只要是查询语句需要，就建上索引？</h3><p>不是，因为索引虽然加快了查询速度，但索引也是有代价的。索引文件本身要消耗存储空间，同时索引会加重插入、删除和修改记录时的负担。另外，MySQL 在运行时也要消耗资源维护索引，因此索引并不是越多越好。一般两种情况下不建议建索引。第一种情况是表记录比较少，例如一两千条甚至只有几百条记录的表，没必要建索引，另一种是数据的区分度比较低，可以使用 count(distinct(列名))/count(*) 来计算区分度。</p>
<h3 id="假如建立联合索引-a-b-c-，下列语句是否可以使用索引，如果可以，使用了那几列？"><a href="#假如建立联合索引-a-b-c-，下列语句是否可以使用索引，如果可以，使用了那几列？" class="headerlink" title="假如建立联合索引(a,b,c)，下列语句是否可以使用索引，如果可以，使用了那几列？"></a>假如建立联合索引(a,b,c)，下列语句是否可以使用索引，如果可以，使用了那几列？</h3><p>where a= 3</p>
<p>答：是，使用了 a 列。</p>
<p>where a= 3 and b = 5</p>
<p>答：是，使用了 a，b 列。</p>
<p>where a = 3 and c = 4 and b = 5</p>
<p>答：是，使用了 a，b，c 列。</p>
<p>where b= 3</p>
<p>答：否。</p>
<p>where a= 3 and c = 4</p>
<p>答：是，使用了 a 列。</p>
<p>where a = 3 and b &gt; 10 and c = 7</p>
<p>答：是，使用了 a，b 列。</p>
<p>where a = 3 and b like ‘xx%’  and c = 7</p>
<p>答：是，使用了 a，b 列。</p>
<h2 id="答疑"><a href="#答疑" class="headerlink" title="答疑"></a>答疑</h2><h3 id="关于执行计划的相关列含义"><a href="#关于执行计划的相关列含义" class="headerlink" title="关于执行计划的相关列含义"></a>关于执行计划的相关列含义</h3><ul>
<li><p>Extra列</p>
<blockquote>
<p>Extra列是不适合在其他列显示的额外信息。</p>
<p>常用值如下：</p>
<p>Using index：表示使用覆盖索引</p>
<p>Using where：需要回表查询，使用where来过滤条件</p>
<p>Using index condition：查找使用了索引，但是需要回表查询数据</p>
</blockquote>
</li>
<li><p>filtered：显示的是针对表里符合where子句或联接条件的记录数的百分比</p>
</li>
<li><p>type：访问类型</p>
<blockquote>
<p>ALL：全表扫描</p>
<p>index：也是全表扫描，但是按照索引的次序进行</p>
<p>range：范围扫描</p>
<p>ref：索引查找</p>
</blockquote>
</li>
<li><p>possible_keys：查询可以使用哪些索引</p>
</li>
<li><p>key：MySQL决定用哪个索引来优化查询</p>
</li>
<li><p>key_len：索引使用的字节数。如果MySQL正在使用的只是索引里的某些列，那么就可以用这个值来算出具体是哪些列</p>
</li>
<li><p>rows：MySQL为了找到所需的行而要读取的行数</p>
</li>
</ul>
<h3 id="聚集（簇）索引的优势在哪？"><a href="#聚集（簇）索引的优势在哪？" class="headerlink" title="聚集（簇）索引的优势在哪？"></a>聚集（簇）索引的优势在哪？</h3><p>看上去聚簇索引的效率明显要低于非聚簇索引，因为每次使用辅助索引检索都要经过两次B+树查找，那么聚簇索引的优势在哪？</p>
<ul>
<li><p>由于行数据和叶子节点存储在一起，这样主键和行数据是一起被载入内存的，找到叶子节点就可以立刻将行数据返回了，如果按照主键Id来组织数据，获得数据更快。</p>
</li>
<li><p>辅助索引使用主键作为”指针” 而不是使用行地址值作为指针的好处是，减少了当出现行移动或者数据页分裂时辅助索引的维护工作，使用主键值当作指针会让辅助索引占用更多的空间，换来的好处是InnoDB在移动行时无须更新辅助索引中的这个”指针”，使用聚簇索引可以保证不管这个主键B+树的节点如何变化，辅助索引树都不受影响。<br>原文链接：<a href="https://blog.csdn.net/molashaonian/article/details/83012176" target="_blank" rel="noopener">https://blog.csdn.net/molashaonian/article/details/83012176</a></p>
</li>
</ul>
<h3 id="使用in关键字时联合索引使用情况"><a href="#使用in关键字时联合索引使用情况" class="headerlink" title="使用in关键字时联合索引使用情况"></a>使用in关键字时联合索引使用情况</h3><p>本地测试的MySQL版本为5.7.19。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from employees where birth_date in (&apos;1953-09-02&apos;, &apos;1953-09-05&apos;)</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20190819182232154.png" alt="在这里插入图片描述"></p>
<p>由执行计划得知用到了联合索引中的最左列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from employees where birth_date in (&apos;1953-09-02&apos;, &apos;1953-09-05&apos;) and first_name = &apos;Georgi&apos;;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/2019081918224125.png" alt="在这里插入图片描述"></p>
<p>通过key_len可以知道用到了联合索引中的前两个字段（当where条件只有birth_date条件时key_len为3，key_len是指MySQL在索引里使用的字节数）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from employees where birth_date = &apos;1953-09-02&apos; and first_name in (&apos;Georgi&apos;, &apos;xxx&apos;) and last_name = &apos;Facello&apos;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20190819182259343.png" alt="在这里插入图片描述"></p>
<p>通过key_len可以知道用到了联合索引中的所有字段</p>
<h3 id="使用范围查询时联合索引使用情况"><a href="#使用范围查询时联合索引使用情况" class="headerlink" title="使用范围查询时联合索引使用情况"></a>使用范围查询时联合索引使用情况</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from employees where birth_date = &apos;1953-09-02&apos; and first_name &gt; &apos;Georgi&apos; and last_name = &apos;Facello&apos;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20190819182310251.png" alt="在这里插入图片描述"></p>
<p>由执行计划得知，该查询使用到了联合索引的前两列。</p>

    </div>

    
    
    
      
  <div class="popular-posts-header">相关文章</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/2019/11/26/InnoDB缓存机制和底层数据结构/" rel="bookmark">InnoDB缓存机制和底层数据结构</a></div>
    </li>
  </ul>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/MySQL/" rel="tag"><i class="fa fa-tag"></i> MySQL</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
                <a href="/2018/08/18/HashMap的四种遍历方式及遍历性能的测试/" rel="next" title="HashMap的四种遍历方式及遍历性能的测试">
                  <i class="fa fa-chevron-left"></i> HashMap的四种遍历方式及遍历性能的测试
                </a>
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
                <a href="/2019/08/31/浅析JAVA垃圾回收/" rel="prev" title="浅析JAVA垃圾回收">
                  浅析JAVA垃圾回收 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
      </footer>
    
  </article>

  <ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-title"><h3><a href="/2019/11/26/InnoDB缓存机制和底层数据结构/" title="InnoDB缓存机制和底层数据结构" rel="bookmark">InnoDB缓存机制和底层数据结构</a></h3></div></li></ul>
    
  
  
  

  </div>


          </div>
          
    <div class="comments" id="comments"></div>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#参考资料"><span class="nav-number">1.</span> <span class="nav-text">参考资料</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-number">2.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据结构介绍"><span class="nav-number">3.</span> <span class="nav-text">数据结构介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#B-Tree"><span class="nav-number">3.1.</span> <span class="nav-text">B-Tree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B-Tree-1"><span class="nav-number">3.2.</span> <span class="nav-text">B+Tree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么要使用这种数据结构"><span class="nav-number">3.3.</span> <span class="nav-text">为什么要使用这种数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#局部性原理"><span class="nav-number">3.3.1.</span> <span class="nav-text">局部性原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#磁盘预读机制"><span class="nav-number">3.3.2.</span> <span class="nav-text">磁盘预读机制</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL索引实现"><span class="nav-number">4.</span> <span class="nav-text">MySQL索引实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MyISAM索引实现"><span class="nav-number">4.1.</span> <span class="nav-text">MyISAM索引实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#索引分类"><span class="nav-number">5.</span> <span class="nav-text">索引分类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#主键索引"><span class="nav-number">5.1.</span> <span class="nav-text">主键索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#唯一索引"><span class="nav-number">5.2.</span> <span class="nav-text">唯一索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#前缀索引"><span class="nav-number">5.3.</span> <span class="nav-text">前缀索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#联合索引"><span class="nav-number">5.4.</span> <span class="nav-text">联合索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#哈希索引"><span class="nav-number">5.5.</span> <span class="nav-text">哈希索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#全文索引"><span class="nav-number">5.6.</span> <span class="nav-text">全文索引</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#索引使用策略和优化技巧"><span class="nav-number">6.</span> <span class="nav-text">索引使用策略和优化技巧</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#全值匹配"><span class="nav-number">6.1.</span> <span class="nav-text">全值匹配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#联合索引匹配最左列原则"><span class="nav-number">6.2.</span> <span class="nav-text">联合索引匹配最左列原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用覆盖索引"><span class="nav-number">6.3.</span> <span class="nav-text">使用覆盖索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#避免强制类型转换"><span class="nav-number">6.4.</span> <span class="nav-text">避免强制类型转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#InnoDB的主键选择与插入优化"><span class="nav-number">7.</span> <span class="nav-text">InnoDB的主键选择与插入优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#问题"><span class="nav-number">8.</span> <span class="nav-text">问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#只要是查询语句需要，就建上索引？"><span class="nav-number">8.1.</span> <span class="nav-text">只要是查询语句需要，就建上索引？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#假如建立联合索引-a-b-c-，下列语句是否可以使用索引，如果可以，使用了那几列？"><span class="nav-number">8.2.</span> <span class="nav-text">假如建立联合索引(a,b,c)，下列语句是否可以使用索引，如果可以，使用了那几列？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#答疑"><span class="nav-number">9.</span> <span class="nav-text">答疑</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#关于执行计划的相关列含义"><span class="nav-number">9.1.</span> <span class="nav-text">关于执行计划的相关列含义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#聚集（簇）索引的优势在哪？"><span class="nav-number">9.2.</span> <span class="nav-text">聚集（簇）索引的优势在哪？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用in关键字时联合索引使用情况"><span class="nav-number">9.3.</span> <span class="nav-text">使用in关键字时联合索引使用情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用范围查询时联合索引使用情况"><span class="nav-number">9.4.</span> <span class="nav-text">使用范围查询时联合索引使用情况</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="龚士云"
    src="/upload/me.jpg">
  <p class="site-author-name" itemprop="name">龚士云</p>
  <div class="site-description" itemprop="description">I'm gonna ride 'til I can't no more.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/gongshiyun" title="GitHub &rarr; https://github.com/gongshiyun" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:gongshiyun@126.com" title="E-Mail &rarr; mailto:gongshiyun@126.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2017 – 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-gsy"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">龚士云</span>
</div>

        






  
  <script>
  function leancloudSelector(url) {
    return document.getElementById(url).querySelector('.leancloud-visitors-count');
  }
  if (CONFIG.page.isPost) {
    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = visitors.getAttribute('id').trim();
      var title = visitors.getAttribute('data-flag-title').trim();

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .then(response => response.json())
              .then(() => {
                leancloudSelector(url).innerText = counter.time + 1;
              })
              .catch(error => {
                console.log('Failed to save visitor count', error);
              })
          } else {
              Counter('post', '/classes/Counter', { title: title, url: url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.log('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.log('LeanCloud Counter Error', error);
        });
    }
  } else {
    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return element.getAttribute('id').trim();
      });

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url: { '$in': entries } })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length === 0) {
            document.querySelectorAll('.leancloud_visitors .leancloud-visitors-count').forEach(element => {
              element.innerText = 0;
            });
            return;
          }
          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.url;
            var time = item.time;
            leancloudSelector(url).innerText = time;
          }
          for (var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = leancloudSelector(url);
            if (element.innerText == '') {
              element.innerText = 0;
            }
          }
        })
        .catch(error => {
          console.log('LeanCloud Counter Error', error);
        });
    }
  }

  fetch('https://app-router.leancloud.cn/2/route?appId=EPAXVAVtteh6PmtI0ngHp5h9-gzGzoHsz')
    .then(response => response.json())
    .then(({ api_server }) => {
      var Counter = (method, url, data) => {
        return fetch(`https://${api_server}/1.1${url}`, {
          method: method,
          headers: {
            'X-LC-Id': 'EPAXVAVtteh6PmtI0ngHp5h9-gzGzoHsz',
            'X-LC-Key': 'cY1JjAQtDORFkYcXsbUy8trn',
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        const localhost = /http:\/\/(localhost|127.0.0.1|0.0.0.0)/;
        if (localhost.test(document.URL)) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    });
  </script>






        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.2"></script><script src="/js/motion.js?v=7.4.2"></script>
<script src="/js/schemes/muse.js?v=7.4.2"></script>
<script src="/js/next-boot.js?v=7.4.2"></script>



  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>






  <script src="/js/local-search.js?v=7.4.2"></script>













  

  

  


<script>
NexT.utils.getScript('https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(item => {
    return GUEST.includes(item);
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'EPAXVAVtteh6PmtI0ngHp5h9-gzGzoHsz',
    appKey: 'cY1JjAQtDORFkYcXsbUy8trn',
    placeholder: "Just say something",
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: '' || 'zh-cn',
    path: location.pathname,
    recordIP: false,
    serverURLs: ''
  });
}, window.Valine);
</script>

</body>
</html>
