<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/upload/favicon.ico?v=7.4.2">
  <link rel="icon" type="image/png" sizes="32x32" href="/upload/favicon.ico?v=7.4.2">
  <link rel="icon" type="image/png" sizes="16x16" href="/upload/favicon.ico?v=7.4.2">

<link rel="stylesheet" href="/css/main.css?v=7.4.2">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.4.2',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"flat"},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="InnoDB缓存方案和底层存储结构参考资料   资料名称 来源地址     《MySQL王者晋级之路》 图书   《MySQL技术内幕 InnoDB存储引擎》 图书   MySQL 5.7官方文档 https://dev.mysql.com/doc/refman/5.7/en/   InnoDB引擎概述">
<meta name="keywords" content="MySQL,InnoDB">
<meta property="og:type" content="article">
<meta property="og:title" content="InnoDB缓存机制和底层数据结构">
<meta property="og:url" content="gongshiyun.top/2019/11/26/InnoDB缓存机制和底层数据结构/index.html">
<meta property="og:site_name" content="gsyun&#39;s blog">
<meta property="og:description" content="InnoDB缓存方案和底层存储结构参考资料   资料名称 来源地址     《MySQL王者晋级之路》 图书   《MySQL技术内幕 InnoDB存储引擎》 图书   MySQL 5.7官方文档 https://dev.mysql.com/doc/refman/5.7/en/   InnoDB引擎概述">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="gongshiyun.top/2019/11/26/InnoDB缓存机制和底层数据结构/InnoDB%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E5%92%8C%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/innodb-architecture.png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9kZXYubXlzcWwuY29tL2RvYy9yZWZtYW4vNS43L2VuL2ltYWdlcy9pbm5vZGItYnVmZmVyLXBvb2wtbGlzdC5wbmc?x-oss-process=image/format,png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2ltZy9iVkoxaFM?x-oss-process=image/format,png">
<meta property="og:updated_time" content="2019-11-26T12:56:15.260Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="InnoDB缓存机制和底层数据结构">
<meta name="twitter:description" content="InnoDB缓存方案和底层存储结构参考资料   资料名称 来源地址     《MySQL王者晋级之路》 图书   《MySQL技术内幕 InnoDB存储引擎》 图书   MySQL 5.7官方文档 https://dev.mysql.com/doc/refman/5.7/en/   InnoDB引擎概述">
<meta name="twitter:image" content="gongshiyun.top/2019/11/26/InnoDB缓存机制和底层数据结构/InnoDB%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E5%92%8C%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/innodb-architecture.png">

<link rel="canonical" href="gongshiyun.top/2019/11/26/InnoDB缓存机制和底层数据结构/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>InnoDB缓存机制和底层数据结构 | gsyun's blog</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?1569499920513";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">gsyun's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="gongshiyun.top/2019/11/26/InnoDB缓存机制和底层数据结构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/upload/me.jpg">
      <meta itemprop="name" content="龚士云">
      <meta itemprop="description" content="I'm gonna ride 'til I can't no more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gsyun's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          InnoDB缓存机制和底层数据结构
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-11-26 20:52:30 / 修改时间：20:56:15" itemprop="dateCreated datePublished" datetime="2019-11-26T20:52:30+08:00">2019-11-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index">
                    <span itemprop="name">MySQL</span>
                  </a>
                </span>
            </span>

          
            <span id="/2019/11/26/InnoDB缓存机制和底层数据结构/" class="post-meta-item leancloud_visitors" data-flag-title="InnoDB缓存机制和底层数据结构" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/11/26/InnoDB缓存机制和底层数据结构/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/11/26/InnoDB缓存机制和底层数据结构/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="InnoDB缓存方案和底层存储结构"><a href="#InnoDB缓存方案和底层存储结构" class="headerlink" title="InnoDB缓存方案和底层存储结构"></a>InnoDB缓存方案和底层存储结构</h1><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><table>
<thead>
<tr>
<th>资料名称</th>
<th>来源地址</th>
</tr>
</thead>
<tbody>
<tr>
<td>《MySQL王者晋级之路》</td>
<td>图书</td>
</tr>
<tr>
<td>《MySQL技术内幕 InnoDB存储引擎》</td>
<td>图书</td>
</tr>
<tr>
<td>MySQL 5.7官方文档</td>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/</a></td>
</tr>
</tbody>
</table><h2 id="InnoDB引擎概述"><a href="#InnoDB引擎概述" class="headerlink" title="InnoDB引擎概述"></a>InnoDB引擎概述</h2><a id="more"></a>
<p>InnoDB是事务安全的MySQL存储引擎。最早由Innobase Oy公司开发，从MySQL 5.5版本开始是默认的表存储引擎（之前版本InnoDB存储引擎仅在Windows下为默认的存储引擎）。该存储引擎是第一个完整支持ACID事务的MySQL存储引擎，其特点是行锁设计、支持MVCC、支持外键、提供一致性非锁定读，同时被设计用来最有效地利用以及使用内存和CPU。</p>
<h2 id="InnoDB体系架构"><a href="#InnoDB体系架构" class="headerlink" title="InnoDB体系架构"></a>InnoDB体系架构</h2><p><img src="InnoDB%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E5%92%8C%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/innodb-architecture.png" alt="InnoDB architecture diagram showing in-memory and on-disk structures."></p>
<p>InnoDB存储引擎有多个内存块，这些内存块组成一个内存池，主要负责如下工作：</p>
<ul>
<li>维护所有进程、线程需要访问的多个内部数据结构</li>
<li>缓存磁盘上的数据，方便快速读取，同时在对磁盘文件的数据修改之前在这里缓存</li>
<li>重做日志（redo log）缓冲</li>
</ul>
<p>后台线程的主要作用：</p>
<ul>
<li>负责刷新内存池中的数据，保证缓冲池中的内存缓存的是最近的数据</li>
<li>将已修改的数据文件刷新到磁盘文件</li>
</ul>
<h2 id="InnoDB缓存机制"><a href="#InnoDB缓存机制" class="headerlink" title="InnoDB缓存机制"></a>InnoDB缓存机制</h2><h3 id="缓冲池（Buffer-Pool）"><a href="#缓冲池（Buffer-Pool）" class="headerlink" title="缓冲池（Buffer Pool）"></a>缓冲池（Buffer Pool）</h3><p>Buffer Pool是InnoDB在主内存中用于缓存查询到的表和索引数据的区域，它能够使InnoDB直接从内存中处理经常使用的数据，从而加快处理速度。在专用MySQL服务器上，多达80%的物理内存通常分配给缓冲池。</p>
<p>为提高大批量数据的读取效率，Buffer Pool被划分为多个页，每个页包可以含多条行记录。为了提高缓存管理的效率，Buffer Pool被实现为页面的列表，很少使用的数据页使用变种的LRU算法从缓存中老化。</p>
<h4 id="缓冲池的-LRU-算法"><a href="#缓冲池的-LRU-算法" class="headerlink" title="缓冲池的 LRU 算法"></a>缓冲池的 LRU 算法</h4><p>普通的LRU算法实现的是末尾淘汰制，当整个链表已满时，淘汰尾部，将新的数据页加入头部；</p>
<p>Buffer Pool的LRU算法与普通的LRU算法不一样，新数据页插入时并不从头部插入，而是从中间位置插入（默认配置下，该位置从表头计算为列表5/8的位置)，在该位置，列表被分成了如下两个子列表：</p>
<ul>
<li>在头部是最近被访问的新页列表</li>
<li>在尾部是很少被访问的旧页列表</li>
</ul>
<p> <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9kZXYubXlzcWwuY29tL2RvYy9yZWZtYW4vNS43L2VuL2ltYWdlcy9pbm5vZGItYnVmZmVyLXBvb2wtbGlzdC5wbmc?x-oss-process=image/format,png" alt="Content is described in the surrounding text."> </p>
<p>默认情况下，该变种的LRU算法特点如下：</p>
<ul>
<li>Buffer Pool的3/8用于旧页列表</li>
<li>列表的中点事新页列表的尾部和旧页列表的头部相交的边界</li>
<li>当 InnoDB从磁盘读一页数据并放入缓冲池中时，它会将此页插入到列表的中间位置（也就是旧页列表的头部）。发生读页一般是因为用户查询数据，或者InnoDB自动触发的预读（read-ahead）操作。 </li>
<li>读取旧页列表中的数据会让该页变年轻，并将其移动到新页列表的头部。如果是因为用户查询读造成该页被读取，则该页会立即被标识为年轻，并直接移动到新页列表头部。如果该页因为预读被读取，则首次读取该页并放入缓冲池时不会将该页放入新页列表头部，而是放入列表中点，需要再次读取才能使该页被标识为年轻状态，这样是为了避免预读导致的<strong>缓冲池搅动</strong></li>
<li>数据库运行过程中，Buffer Pool中不被访问的页因其他被访问的页的移动或新插入的页而老化向尾部移动，最后到达旧页列表尾部并被移出</li>
</ul>
<h5 id="缓冲池搅动"><a href="#缓冲池搅动" class="headerlink" title="缓冲池搅动"></a>缓冲池搅动</h5><p>预读或者表、索引的扫描都会造成大量数据页被读入缓冲池，这些页可能会在短时间内被读取若干次，然后从此不再访问，因此，数据页的大量插入到新页头部可能会将热点数据迅速老化移除出缓冲池。这种情况叫做缓冲池搅动。为解决该问题，MySQL提供了配置参数<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_old_blocks_time" target="_blank" rel="noopener"><code>innodb_old_blocks_time</code></a>  用来指定该页在放入缓冲池后第一次读之后一定时间内（时间窗口，单位毫秒）读取不会被标识为年轻，也就是不会被移动到列表头部 。</p>
<h5 id="相关参数"><a href="#相关参数" class="headerlink" title="相关参数"></a>相关参数</h5><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_old_blocks_pct" target="_blank" rel="noopener"><code>innodb_old_blocks_pct</code></a> 该参数为旧页列表占LRU列表的百分比，默认为37即3/8，取值范围为[5,95]。</p>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_old_blocks_time" target="_blank" rel="noopener"><code>innodb_old_blocks_time</code></a> 指定第一次访问页面之后的时间窗口（以毫秒为单位），在此期间，可以访问页面，而无需移动页到LRU新页列表的前端。innodb_old_blocks_time的默认值是1000。增加这个值会使越来越多的块从缓冲池中老化得更快。</p>
<h4 id="缓冲池状态监控"><a href="#缓冲池状态监控" class="headerlink" title="缓冲池状态监控"></a>缓冲池状态监控</h4><p>使用InnoDB标准监视器可以监视缓冲池的状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW ENGINE INNODB STATUS\G</span><br><span class="line">----------------------</span><br><span class="line">BUFFER POOL AND MEMORY</span><br><span class="line">----------------------</span><br><span class="line">Total large memory allocated 17170432 #分配给缓冲池的内存大小（bytes）</span><br><span class="line">Dictionary memory allocated 352153    #分配给InnoDB数据字典的内存大小（bytes）</span><br><span class="line">Buffer pool size   1024				  #分配给缓冲池的总页数</span><br><span class="line">Free buffers       761				  #缓冲池可用列表的总页数</span><br><span class="line">Database pages     256				  #缓冲池LRU列表的总页数</span><br><span class="line">Old database pages 0				  #缓冲池LRU旧页列表的总页数</span><br><span class="line">Modified db pages  0			 	  #缓冲池中当前修改的页数</span><br><span class="line">Pending reads      0				  #等待读入缓冲池的缓冲池页数</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0 #等待写入磁盘的脏页数</span><br><span class="line">Pages made young 0, not young 0</span><br><span class="line">0.00 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 8439, created 1241, written 34441</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">No buffer pool page gets since the last printout</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 256, unzip_LRU len: 0</span><br><span class="line">I/O sum[0]:cur[0], unzip sum[0]:cur[0]</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Total memory allocated</td>
<td>The total memory allocated for the buffer pool in bytes.</td>
</tr>
<tr>
<td>Dictionary memory allocated</td>
<td>The total memory allocated for the <code>InnoDB</code> data dictionary in bytes.</td>
</tr>
<tr>
<td>Buffer pool size</td>
<td>The total size in pages allocated to the buffer pool.</td>
</tr>
<tr>
<td>Free buffers</td>
<td>The total size in pages of the buffer pool free list.</td>
</tr>
<tr>
<td>Database pages</td>
<td>The total size in pages of the buffer pool LRU list.</td>
</tr>
<tr>
<td>Old database pages</td>
<td>The total size in pages of the buffer pool old LRU sublist.</td>
</tr>
<tr>
<td>Modified db pages</td>
<td>The current number of pages modified in the buffer pool.</td>
</tr>
<tr>
<td>Pending reads</td>
<td>The number of buffer pool pages waiting to be read into the buffer pool.</td>
</tr>
<tr>
<td>Pending writes LRU</td>
<td>The number of old dirty pages within the buffer pool to be written from the bottom of the LRU list.</td>
</tr>
<tr>
<td>Pending writes flush list</td>
<td>The number of buffer pool pages to be flushed during checkpointing.</td>
</tr>
<tr>
<td>Pending writes single page</td>
<td>The number of pending independent page writes within the buffer pool.</td>
</tr>
<tr>
<td>Pages made young</td>
<td>The total number of pages made young in the buffer pool LRU list (moved to the head of sublist of “new” pages).</td>
</tr>
<tr>
<td>Pages made not young</td>
<td>The total number of pages not made young in the buffer pool LRU list (pages that have remained in the “old” sublist without being made young).</td>
</tr>
<tr>
<td>youngs/s</td>
<td>The per second average of accesses to old pages in the buffer pool LRU list that have resulted in making pages young. See the notes that follow this table for more information.</td>
</tr>
<tr>
<td>non-youngs/s</td>
<td>The per second average of accesses to old pages in the buffer pool LRU list that have resulted in not making pages young. See the notes that follow this table for more information.</td>
</tr>
<tr>
<td>Pages read</td>
<td>The total number of pages read from the buffer pool.</td>
</tr>
<tr>
<td>Pages created</td>
<td>The total number of pages created within the buffer pool.</td>
</tr>
<tr>
<td>Pages written</td>
<td>The total number of pages written from the buffer pool.</td>
</tr>
<tr>
<td>reads/s</td>
<td>The per second average number of buffer pool page reads per second.</td>
</tr>
<tr>
<td>creates/s</td>
<td>The per second average number of buffer pool pages created per second.</td>
</tr>
<tr>
<td>writes/s</td>
<td>The per second average number of buffer pool page writes per second.</td>
</tr>
<tr>
<td>Buffer pool hit rate</td>
<td>The buffer pool page hit rate for pages read from the buffer pool memory vs from disk storage.</td>
</tr>
<tr>
<td>young-making rate</td>
<td>The average hit rate at which page accesses have resulted in making pages young. See the notes that follow this table for more information.</td>
</tr>
<tr>
<td>not (young-making rate)</td>
<td>The average hit rate at which page accesses have not resulted in making pages young. See the notes that follow this table for more information.</td>
</tr>
<tr>
<td>Pages read ahead</td>
<td>The per second average of read ahead operations.</td>
</tr>
<tr>
<td>Pages evicted without access</td>
<td>The per second average of the pages evicted without being accessed from the buffer pool.</td>
</tr>
<tr>
<td>Random read ahead</td>
<td>The per second average of random read ahead operations.</td>
</tr>
<tr>
<td>LRU len</td>
<td>The total size in pages of the buffer pool LRU list.</td>
</tr>
<tr>
<td>unzip_LRU len</td>
<td>The total size in pages of the buffer pool unzip_LRU list.</td>
</tr>
<tr>
<td>I/O sum</td>
<td>The total number of buffer pool LRU list pages accessed, for the last 50 seconds.</td>
</tr>
<tr>
<td>I/O cur</td>
<td>The total number of buffer pool LRU list pages accessed.</td>
</tr>
<tr>
<td>I/O unzip sum</td>
<td>The total number of buffer pool unzip_LRU list pages accessed.</td>
</tr>
<tr>
<td>I/O unzip cur</td>
<td>The total number of buffer pool unzip_LRU list pages accessed.</td>
</tr>
</tbody>
</table>
<h4 id="缓冲池配置"><a href="#缓冲池配置" class="headerlink" title="缓冲池配置"></a>缓冲池配置</h4><p>MySQL 官方文档对于缓冲池的相关配置参考：</p>
<p>You can configure the various aspects of the buffer pool to improve performance.</p>
<ul>
<li>Ideally, you set the size of the buffer pool to as large a value as practical, leaving enough memory for other processes on the server to run without excessive paging. The larger the buffer pool, the more <code>InnoDB</code> acts like an in-memory database, reading data from disk once and then accessing the data from memory during subsequent reads. See <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-buffer-pool-resize.html" target="_blank" rel="noopener">Section 14.8.3.1, “Configuring InnoDB Buffer Pool Size”</a>.</li>
<li>On 64-bit systems with sufficient memory, you can split the buffer pool into multiple parts to minimize contention for memory structures among concurrent operations. For details, see <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-multiple-buffer-pools.html" target="_blank" rel="noopener">Section 14.8.3.2, “Configuring Multiple Buffer Pool Instances”</a>.</li>
<li>You can keep frequently accessed data in memory regardless of sudden spikes of activity from operations that would bring large amounts of infrequently accessed data into the buffer pool. For details, see <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-midpoint_insertion.html" target="_blank" rel="noopener">Section 14.8.3.3, “Making the Buffer Pool Scan Resistant”</a>.</li>
<li>You can control when and how to perform read-ahead requests to prefetch pages into the buffer pool asynchronously in anticipation that the pages will be needed soon. For details, see <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-read_ahead.html" target="_blank" rel="noopener">Section 14.8.3.4, “Configuring InnoDB Buffer Pool Prefetching (Read-Ahead)”</a>.</li>
<li>You can control when background flushing occurs and whether or not the rate of flushing is dynamically adjusted based on workload. For details, see <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-buffer-pool-flushing.html" target="_blank" rel="noopener">Section 14.8.3.5, “Configuring Buffer Pool Flushing”</a>.</li>
<li>You can configure how <code>InnoDB</code> preserves the current buffer pool state to avoid a lengthy warmup period after a server restart. For details, see <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-preload-buffer-pool.html" target="_blank" rel="noopener">Section 14.8.3.6, “Saving and Restoring the Buffer Pool State”</a>.</li>
</ul>
<h3 id="变更缓冲（Change-Buffer）"><a href="#变更缓冲（Change-Buffer）" class="headerlink" title="变更缓冲（Change Buffer）"></a>变更缓冲（Change Buffer）</h3><p> [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-IIXmsOIv-1574392220787)(innodb缓存方案和底层存储结构.assets/innodb-change-buffer.png)] </p>
<p>Change buffer的主要目的是将对二级索引的数据操作缓存下来，以此减少二级索引的随机IO，并达到操作合并的效果。 在MySQL5.5之前的版本中，由于只支持缓存insert操作，所以最初叫做insert buffer，只是后来的版本中支持了更多的操作类型缓存，才改叫change buffer 。</p>
<p>当执行插入、更新或删除操作时，会触发与表有关的索引的操作，表的索引也会进行相应的插入、更新或删除，这样会影响到对源表的数据的操作速度。当对表进行DML操作时，非聚集索引的值通常是无序的，如果索引所在的页不在缓冲池中，就需要从磁盘中读取该页到缓冲池中进行更新，然后刷新到磁盘，如果有大量的DML操作，就会产生大量的磁盘随机读取，影响性能。</p>
<p>Change Buffer的作用，就是当变更的二级索引的相关页不在缓冲池中时，将二级索引的更改缓存到Change Buffer区，当该索引的页被加载到缓冲池中时，根据Change Buffer区中的更改对其进行更新合并，更新的页之后被刷新到磁盘。InnoDB主线程在服务器接近空闲时以及在缓慢关闭期间合并缓冲的更改。</p>
<p>通过Change Buffer，可以减少磁盘读写，对于具有大量DML操作的应用程序来说该功能很有用。不过Change Buffer也有弊端，那就是它占用了Buffer Pool的空间，从而减少了缓存数据页的可用内存。</p>
<p><strong>相关配置参数</strong>：</p>
<p> <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_change_buffering" target="_blank" rel="noopener"><code>innodb_change_buffering</code></a> 该参数可以指定哪些操作可以使用change buffer</p>
<p>可选值包含如下：</p>
<ul>
<li><p><strong><code>all</code></strong></p>
<p>缓冲全部操作</p>
</li>
<li><p><strong><code>none</code></strong></p>
<p>不缓存任何操作</p>
</li>
<li><p><strong><code>inserts</code></strong></p>
<p>仅insert操作</p>
</li>
<li><p><strong><code>deletes</code></strong></p>
<p>包含delete标记和update操作（update分两步，删除原有记录，插入新的记录）</p>
</li>
<li><p><strong><code>changes</code></strong></p>
<p>insert和delete标记操作</p>
</li>
<li><p><strong><code>purges</code></strong></p>
<p>缓冲后台进程的物理删除操作</p>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_change_buffer_max_size" target="_blank" rel="noopener"><code>innodb_change_buffer_max_size</code></a>  该参数可以设定change buffer占用缓冲池的百分比最大值，默认值为25，最大可以设置为50。innodb_change_buffer_max_size设置是动态的，允许在不重新启动服务器的情况下修改设置。</p>
</li>
</ul>
<p><strong>Change buffer监控</strong>：</p>
<p>通过以下指令可以监控Change Buffer状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW ENGINE INNODB STATUS\G</span><br></pre></td></tr></table></figure>
<p>本地使用MySQL 5.7.19版本，以“ INSERT BUFFER AND ADAPTIVE HASH INDEX ”为标题的输出如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-------------------------------------</span><br><span class="line">INSERT BUFFER AND ADAPTIVE HASH INDEX</span><br><span class="line">-------------------------------------</span><br><span class="line">Ibuf: size 1, free list len 389, seg size 391, 18 merges</span><br><span class="line">merged operations:</span><br><span class="line"> insert 26, delete mark 0, delete 0</span><br><span class="line">discarded operations:</span><br><span class="line"> insert 0, delete mark 0, delete 0</span><br><span class="line">Hash table size 4441, node heap has 1 buffer(s)</span><br><span class="line">Hash table size 4441, node heap has 1 buffer(s)</span><br><span class="line">Hash table size 4441, node heap has 1 buffer(s)</span><br><span class="line">Hash table size 4441, node heap has 1 buffer(s)</span><br><span class="line">Hash table size 4441, node heap has 2 buffer(s)</span><br><span class="line">Hash table size 4441, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 4441, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 4441, node heap has 1 buffer(s)</span><br><span class="line">0.00 hash searches/s, 0.00 non-hash searches/s</span><br></pre></td></tr></table></figure>
<p>seg size显示了当前Change Buffer的大小为391x16KB，约为6.1MB；free list len表示空闲列表的长度；size表示已合并记录页的数量。</p>
<p>可以看到这里显示了merged operations和discarded operations，并且下面具体显示了Change Buffer中每个操作的次数。insert表示insert buffer，delete mark表示delete buffer，delete表示purge buffer；discarded operations表示当Change Buffer发生merge时，表已经被删除，此时就无需将记录合并到二级索引。</p>
<h3 id="日志缓冲（Log-Buffer）"><a href="#日志缓冲（Log-Buffer）" class="headerlink" title="日志缓冲（Log Buffer）"></a>日志缓冲（Log Buffer）</h3><p>日志缓冲是存储要写入磁盘日志文件的数据的内存区域。日志缓冲的数据会定期刷新到磁盘。大的日志缓冲区可以确保大事务无需在事务提交前将重做日志写入磁盘。因此如果应用程序的事务较多，增加日志缓冲区的大小可以减少磁盘的I/O。</p>
<p>相关参数：</p>
<p> <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_log_buffer_size" target="_blank" rel="noopener"><code>innodb_log_buffer_size</code></a> 日志缓冲区大小，默认为16MB，单位是byte</p>
<p> <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_flush_log_at_trx_commit" target="_blank" rel="noopener"><code>innodb_flush_log_at_trx_commit</code></a> 控制如何将日志缓冲区的内容写入并刷新到磁盘</p>
<table>
<thead>
<tr>
<th>value</th>
<th>remark</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>每秒将日志写入并刷新到磁盘一次。未刷新日志的事务可能在崩溃中丢失。</td>
</tr>
<tr>
<td>1（default）</td>
<td>每次事务提交时，日志都会写入并刷新到磁盘。</td>
</tr>
<tr>
<td>2</td>
<td>每次事务提交后都会写入日志，并每秒刷新一次到磁盘。未刷新日志的事务可能在崩溃中丢失。</td>
</tr>
</tbody>
</table>
<p> <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_flush_log_at_timeout" target="_blank" rel="noopener"><code>innodb_flush_log_at_timeout</code></a> 每隔N秒写入并刷新日志。innodb_flush_log_at_timeout允许增加刷新之间的超时时间，以减少刷新频率并避免影响binlog提交的性能。innodb_flush_log_at_timeout的默认设置是每秒一次。取值范围[1,2700]。</p>
<h3 id="查询缓存（-Query-Cache-）"><a href="#查询缓存（-Query-Cache-）" class="headerlink" title="查询缓存（ Query Cache ）"></a>查询缓存（ Query Cache ）</h3><p>【注】从MySQL 5.7.20开始，查询缓存已被弃用，并在MySQL 8.0中被删除。 </p>
<p>查询缓存就是将SELECT语句作为Key（select语句的字节不同则被认为是不同的key），查询结果作为VALUE的形式进行缓存。 如果服务器收到相同的语句，则服务器从查询缓存中检索结果，而不是再次解析并执行该语句。查询缓存在会话之间共享，因此可以响应另一个客户端发出的同一查询。 </p>
<p><strong>缺点：</strong></p>
<ul>
<li>hash性能问题和命中率问题</li>
<li>查询缓存容易失效：当表内容发生变化或者表结构发生变化，INSERT, UPDATE, DELETE, TRUNCATE, ALTER TABLE, DROP TABLE, or DROP DATABASE等操作都会导致表的查询缓存失效</li>
<li>查询缓存中的结果容易产生重复；因为查询缓存中缓存的是查询结果，所以不同的查询的结果很容易重复</li>
<li>查询缓存会增加检查和清理缓存中记录集的开销</li>
<li>SELECT语句不能被缓存的情况<ul>
<li>查询语句中加了SQL_NO_CACHE参数；</li>
<li>查询语句中含有获得值的函数，包涵自定义函数，如：CURDATE()、GET_LOCK()、RAND()、CONVERT_TZ等；</li>
<li>对系统数据库的查询：mysql、information_schema</li>
<li>查询语句中使用SESSION级别变量或存储过程中的局部变量；</li>
<li>查询语句中使用了LOCK IN SHARE MODE、FOR UPDATE的语句</li>
<li>查询语句中类似SELECT …INTO 导出数据的语句；</li>
<li>事务隔离级别为：Serializable情况下，所有查询语句都不能缓存；</li>
<li>对临时表的查询操作；</li>
<li>存在警告信息的查询语句；</li>
<li>不涉及任何表或视图的查询语句；</li>
<li>某用户只有列级别权限的查询语句；</li>
</ul>
</li>
</ul>
<p><strong>适合使用场景：</strong><br>表的读操作非常频繁,而且数据不常更新。 </p>
<h4 id="指定SELECT缓存"><a href="#指定SELECT缓存" class="headerlink" title="指定SELECT缓存"></a>指定SELECT缓存</h4><p>select语句中可以通过 SQL_CACHE 和 SQL_NO_CACHE 指定缓存或不缓存该查询结果</p>
<ul>
<li><p>SQL_CACHE </p>
<p>如果查询结果是可缓存的，并且 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_query_cache_type" target="_blank" rel="noopener"><code>query_cache_type</code></a> 的值是ON或DEMAND，则查询结果将被缓存。</p>
</li>
<li><p>SQL_NO_CACHE </p>
<p>服务器不使用查询缓存。它既不检查查询缓存以查看结果是否已缓存，也不缓存查询结果。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT SQL_CACHE id, name FROM customer;</span><br><span class="line">SELECT SQL_NO_CACHE id, name FROM customer;</span><br></pre></td></tr></table></figure>
<h4 id="相关参数-1"><a href="#相关参数-1" class="headerlink" title="相关参数"></a>相关参数</h4><p> <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_have_query_cache" target="_blank" rel="noopener"><code>have_query_cache</code></a> 查询缓存是否可用</p>
<p> <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_query_cache_size" target="_blank" rel="noopener"><code>query_cache_size</code></a> 查询缓存的大小，默认为1048576bytes，即1MB</p>
<p> <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_query_cache_type" target="_blank" rel="noopener"><code>query_cache_type</code></a> 查询缓存的类型</p>
<table>
<thead>
<tr>
<th>value</th>
<th>remark</th>
</tr>
</thead>
<tbody>
<tr>
<td>OFF</td>
<td>关闭缓存</td>
</tr>
<tr>
<td>ON</td>
<td>启用缓存，但以SELECT SQL_NO_CACHE开头的语句除外</td>
</tr>
<tr>
<td>DEMAND</td>
<td>启用缓存，只缓存以SELECT SQL_CACHE开头的语句</td>
</tr>
</tbody>
</table>
<h4 id="状态监控"><a href="#状态监控" class="headerlink" title="状态监控"></a>状态监控</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW STATUS LIKE &apos;Qcache%&apos;;</span><br><span class="line">+-------------------------+---------+</span><br><span class="line">| Variable_name           | Value   |</span><br><span class="line">+-------------------------+---------+</span><br><span class="line">| Qcache_free_blocks      | 1       | #缓存中相邻内存块的个数</span><br><span class="line">| Qcache_free_memory      | 1031872 | #缓存中的空闲内存</span><br><span class="line">| Qcache_hits             | 0       | #查询在缓存中命中次数</span><br><span class="line">| Qcache_inserts          | 0       | #插入查询缓存次数</span><br><span class="line">| Qcache_lowmem_prunes    | 0       | #内存不足并且必须要进行清理以便为更多查询缓存提供空间的次数</span><br><span class="line">| Qcache_not_cached       | 14188   | #不适合进行缓存的查询的数量</span><br><span class="line">| Qcache_queries_in_cache | 0       | #当前缓存的查询的数量</span><br><span class="line">| Qcache_total_blocks     | 1       | #缓存中块的数量</span><br><span class="line">+-------------------------+---------+</span><br></pre></td></tr></table></figure>
<h2 id="InnoDB存储结构"><a href="#InnoDB存储结构" class="headerlink" title="InnoDB存储结构"></a>InnoDB存储结构</h2><h3 id="逻辑存储结构"><a href="#逻辑存储结构" class="headerlink" title="逻辑存储结构"></a>逻辑存储结构</h3><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-pzoix7WO-1574392220792)(innodb缓存方案和底层存储结构.assets/image-20191120111018106.png)]</p>
<p>InnoDB的逻辑存储结构如上，所有数据都被逻辑地存储在表空间中，其中表空间又由段（segment）、区（extent）、页（page）组成，在一些文档中页也被称为块（block）。</p>
<h4 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h4><p>InnoDB存储引擎中所有数据都是存储在表空间中</p>
<p><strong>系统表空间</strong></p>
<p>系统表空间以ibdata1命名，在安装数据库初始化数据时就是系统在创建一个ibdata1的表空间文件，它会存储所有数据的信息以及回滚段（undo）的信息。MySQL5.6之后，undo表空间可以通过参数单独设置存储位置。</p>
<p><strong>独立表空间</strong></p>
<p>设置参数innodb_file_per_table=1可以使每张表都有一个独立的表空间文件，而不用存储在ibdata1中。值得注意的是独立表空间存放的是B+树数据、索引和插入缓冲等信息，其他数据还是存放在ibdata1中。目前默认使用的就是独立表空间的存储方式。</p>
<p><strong>临时表空间</strong></p>
<p>MySQL5.7把临时表的数据从系统表空间中抽离出来，形成自己的独立表空间，并把临时表的相关检索信息保存在系统信息表的information_schema库下的innodb_temp_table_info表中。</p>
<p><strong>通用表空间</strong></p>
<p>与系统表空间类似，通用表空间是可以存储多个表的数据的共享表空间。多个表放在同一个表空间中，可以减少存储开销。</p>
<h4 id="段"><a href="#段" class="headerlink" title="段"></a>段</h4><p>表空间由段组成，常见的段有数据段，回滚段，索引段等。因为InnoDB表是索引组织的，所以索引即数据，数据即索引，数据段就是B+树的叶子节点（Leaf node segment），索引段即B+树的非叶子节点（Non-leaf node segment）。</p>
<h4 id="区"><a href="#区" class="headerlink" title="区"></a>区</h4><p>区由连续的页组成，是物理上连续的一块空间，每个区的大小固定是1MB。</p>
<h4 id="页"><a href="#页" class="headerlink" title="页"></a>页</h4><p>页是InnoDB最小的的物理存储分配单位，有数据页和回滚页等。一般情况下，一个区由64个页组成，页的默认大小是16KB。从MySQL5.6开始可以自定义调低页的大小为8KB、4KB，MySQL5.7开始可以调高页的大小为32KB或64KB。 </p>
<h4 id="行"><a href="#行" class="headerlink" title="行"></a>行</h4><p>InnoDB引擎是面向列的（row-oriented），也就是说数据是按行进行存储的。每个页存放的行记录按照行格式进行存放。</p>
<h3 id="行记录格式"><a href="#行记录格式" class="headerlink" title="行记录格式"></a>行记录格式</h3><p>在InnoDB 1.0.X之前，InnoDB存储引擎提供了Compact和Redundant两种格式来存放行记录数据。Redundant是mysql5.0版本之前的行记录存储方式，之后仍然支持这个格式是为了兼容之前版本的格式，5.1之后很少用到了，因为Compact的结构设计比它好，因为compact格式消耗的磁盘空间和备份耗时更小，Redundant相比之下大了一些。compact格式更适用于大多数的业务场景。</p>
<p>在InnoDB 1.0.X版本开始又引入了新的文件格式(file format)，以前支持Compact和Redundant格式称为Antelope文件格式，新引入的文件格式称为Barracuda文件格式。Barracuda文件格式下拥有两种新的行记录格式：Compressed和Dynamic，同时，Barracuda文件格式也包括了Antelope所有的文件格式。</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-qaxXMUuQ-1574392220797)(innodb缓存方案和底层存储结构.assets/image-20191120150117896.png)]</p>
<p>可以通过如下命令查看表的行格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show table status like &apos;%iot_linkage_info%&apos;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           Name: iot_linkage_info</span><br><span class="line">         Engine: InnoDB</span><br><span class="line">        Version: 10</span><br><span class="line">     Row_format: Dynamic # 这行Row_format表示的就是行记录的格式</span><br><span class="line">           Rows: 22</span><br><span class="line"> Avg_row_length: 744</span><br><span class="line">    Data_length: 16384</span><br><span class="line">Max_data_length: 0</span><br><span class="line">   Index_length: 65536</span><br><span class="line">      Data_free: 0</span><br><span class="line"> Auto_increment: 77</span><br><span class="line">    Create_time: 2019-11-11 15:41:51</span><br><span class="line">    Update_time: 2019-11-15 15:12:52</span><br><span class="line">     Check_time: NULL</span><br><span class="line">      Collation: utf8mb4_general_ci</span><br><span class="line">       Checksum: NULL</span><br><span class="line"> Create_options: row_format=DYNAMIC</span><br><span class="line">        Comment:</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>MySQL5.7默认使用dynamic行记录格式和Barracuda文件格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;%innodb_file%&apos;;</span><br><span class="line">+--------------------------+-----------+</span><br><span class="line">| Variable_name            | Value     |</span><br><span class="line">+--------------------------+-----------+</span><br><span class="line">| innodb_file_format       | Barracuda |</span><br><span class="line">| innodb_file_format_check | ON        |</span><br><span class="line">| innodb_file_format_max   | Barracuda |</span><br><span class="line">| innodb_file_per_table    | ON        |</span><br><span class="line">+--------------------------+-----------+</span><br><span class="line">4 rows in set, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &apos;%row_format%&apos;;</span><br><span class="line">+---------------------------+---------+</span><br><span class="line">| Variable_name             | Value   |</span><br><span class="line">+---------------------------+---------+</span><br><span class="line">| innodb_default_row_format | dynamic |</span><br><span class="line">+---------------------------+---------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>Dynamic和Compact基本是类似的，但是它们在行溢出数据的处理上却完全不同，这里我们需要先了解一下行溢出的概念。行溢出就是将需要存储的数据存储在当前页面之外，拆分到多个页进行存储，针对大数据类型text或blob字段类型的数据。</p>
<p>dynamic将数据都存放在溢出的页中（off-page），而数据页只存储前20个字节的指针。在Compact格式下，溢出的列只存放768个前缀字节。dynamic这种行格式模式针对溢出列所在的新页利用率会更高，所以生产环境中建议使用dynamic。</p>
<p>Dynamic格式的行溢出处理：</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-MBmqC6eY-1574392220801)(innodb缓存方案和底层存储结构.assets/image-20191120173440319.png)]</p>
<p>Compact格式的行溢出处理：</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-xjaamQy1-1574392220805)(innodb缓存方案和底层存储结构.assets/image-20191120173351771.png)]</p>
<p>Redundant是最早的行记录格式，相比compact要消耗更多空间，不建议使用；Compressed是压缩行格式，对数据和索引页进行压缩，但只是针对物理存储层面的压缩，在内存中是不压缩的，所以当数据读取内存中就需要转换，会增加了CPU消耗，而且效率也低，压缩比例只接近1/2，压缩带来的负面影响也大，数据库的TPS会下降，影响线上业务。</p>
<h3 id="数据页结构"><a href="#数据页结构" class="headerlink" title="数据页结构"></a>数据页结构</h3><p>页是InnoDB存储引擎管理数据库的最小磁盘单位。页类型为B-tree Node的页存放的就是表中行的实际数据，下图为页的结构：</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-QSi3BukE-1574392220807)(innodb缓存方案和底层存储结构.assets/image-20191120152625275.png)]</p>
<p>InnoDB数据页由七个部分组成，其中File Header、Page Header、File Trailer的大小是固定的，这些空间用来标记页的一些信息。User Records、Free Space和Page Directory为实际的行记录存储空间，因此大小是动态的。</p>
<h4 id="File-Header"><a href="#File-Header" class="headerlink" title="File Header"></a>File Header</h4><p>File Header用于记录页的头信息，大小为38个字节，组成部分如下：</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-g2Cpdd9t-1574392220809)(innodb缓存方案和底层存储结构.assets/image-20191120153417851.png)]</p>
<p>InnoDB存储引擎中页的类型：</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-RLCBjRNR-1574392220811)(innodb缓存方案和底层存储结构.assets/image-20191120153750560.png)]</p>
<h4 id="Page-Header"><a href="#Page-Header" class="headerlink" title="Page Header"></a>Page Header</h4><p>Page Header用来记录数据页的状态信息，由14个部分组成，共占用56个字节：</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-TTMx91UL-1574392220813)(innodb缓存方案和底层存储结构.assets/image-20191120154133018.png)]</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-4wKw1slx-1574392220818)(innodb缓存方案和底层存储结构.assets/image-20191120154150903.png)]</p>
<h4 id="Infimum和Suprenum-Record"><a href="#Infimum和Suprenum-Record" class="headerlink" title="Infimum和Suprenum Record"></a>Infimum和Suprenum Record</h4><p>InnoDB的每个数据页都有两个虚拟的行记录虚拟最小行（Infimum records）和虚拟最大行（Supremum records），用来限定记录的边界：</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-M6qk3xnn-1574392220820)(innodb缓存方案和底层存储结构.assets/image-20191120154754662.png)]</p>
<h4 id="User-Record和Free-Space"><a href="#User-Record和Free-Space" class="headerlink" title="User Record和Free Space"></a>User Record和Free Space</h4><p>User Record是实际存储行记录的内容。Free Space是空闲空间，是链表的数据结构。在一条记录被删除后，该空间会被加入到空闲链表中。</p>
<h4 id="Page-Directory"><a href="#Page-Directory" class="headerlink" title="Page Directory"></a>Page Directory</h4><p>Page Directory存放了记录的相对位置。</p>
<h4 id="File-Trailer"><a href="#File-Trailer" class="headerlink" title="File Trailer"></a>File Trailer</h4><p>InnoDB利用File Trailer来保证页完整地写入磁盘。File Trailer只有一个FIL_PAGE_END_LSN部分，占用8个字节，前4个字节代表该页的checksum值，后4个字节和File Header中的FIL_PAGE_LSN相同。通过将这两个值与File Header中的FIL_PAGE_SPACE_OR_CHECKSUM和FIL_PAGE_LSN值进行比较是否一致来保证页的完整性（checksum不是等值比较，需要用到InnoDB的checksum函数进行比较）。</p>
<h2 id="会议疑问点"><a href="#会议疑问点" class="headerlink" title="会议疑问点"></a>会议疑问点</h2><ol>
<li><p>Infimum和Suprenum Record怎么保证B+tree节点是双向链表结构？</p>
<p>关于这两个概念，官网有做介绍 <a href="https://dev.mysql.com/doc/internals/en/innodb-infimum-and-supremum-records.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/internals/en/innodb-infimum-and-supremum-records.html</a> 。Infimum和Suprenum Record用来限定记录的边界，Infimum是比页中任何主键值都要小的值，Suprenum 是指比任何可能大值还要大的值，这两个值在页创建时被建立，并且在任何情况下都不会被删除。Infimum和Suprenum与行记录组成单链表结构，查询记录时，从Infimum开始查找，如果找不到结果会直到查到最后的suprenum为止，然后通过Page Header中的FIL_PAGE_NEXT指针跳转到下一个page继续从Infimum开始逐个查找 </p>
<p> <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2ltZy9iVkoxaFM?x-oss-process=image/format,png" alt="clipboard.png"> </p>
</li>
</ol>
<p>所以原文档说的Infimum和Suprenum Record保证B+tree节点是双向链表结构应该是不对的，应该是保证节点内部记录的结构是单链表结构</p>
<ol start="2">
<li>关于脏页的刷新机制Checkpoint</li>
</ol>
<p>缓冲池设计目的是为了协调CPU速度和磁盘速度的鸿沟，页的操作首先都是在缓冲池中完成的，如果一条DML语句改变了页中的记录，那么此时页是脏的，即缓冲池中的页的版本要比磁盘的新，数据库需要将新版本的页从缓冲池刷新到磁盘，如果页每次发生改变都要将其刷新到磁盘，并且热点数据集中在几个页中，那么数据库的性能就会变得很差，InnoDB使用了一些机制来避免这种问题。</p>
<p>InnoDB采用Write Ahead Log策略来防止宕机数据丢失，即事务提交时，先写重做日志，再修改内存数据页，这样就产生了脏页，由于重做日志不可能无限大，缓冲池也不可能无限大，所以脏页需要刷新到磁盘，另外如果重做日志太大，宕机的时候也会使重做全部日志恢复的时间过长。InnoDB为了避免这些问题，使用checkpoint技术来使数据库宕机时只需要重做上次checkpiont之后的日志。</p>
<p>checkpoint主要解决以下问题：</p>
<ul>
<li>缩短数据库恢复时间</li>
<li>缓冲池不可用时，将脏页刷新到磁盘</li>
<li>重做日志不可用时，将脏页刷新到磁盘</li>
</ul>
<p>Checkpoint分为两种：</p>
<ul>
<li><p><strong>Sharp Checkpoint</strong></p>
<p>发生在数据库关闭的时候将所有脏页刷新到磁盘，这是默认的工作方式，即参数innodb_fast_shutdown=1</p>
</li>
<li><p><strong>Fuzzy Checkpoint</strong></p>
<p>数据库运行过程中使用的是Fuzzy checkpoint进行页的刷新，即只刷新一部分脏页，而不是刷新所有脏页。</p>
<p>Fuzzy Checkpoint中包含几种情况：</p>
<ul>
<li><p><strong>Master Thread Checkpoint</strong></p>
<p>master thread是后台线程中的主线程，内部的flush loop刷新循环中会执行每秒或每十秒将缓冲池中的脏页列表中刷新一定比例的页回磁盘，这个过程是异步的，不会阻塞用户的查询线程。</p>
</li>
<li><p><strong>FLUSH_LRU_LIST Checkpoint</strong></p>
<p>因为InnoDB存储引擎需要保证LRU列表中需要有差不多100个空闲页可供使用。在InnoDB1.1.x版本之前，需要检查LRU列表中是否有足够的可用空间操作发生在用户查询线程中，显然这会阻塞用户的查询操作。倘若没有100个可用空闲页，那么InnoDB存储引擎会将LRU列表尾端的页移除。如果这些页中有脏页，那么需要进行Checkpoint，而这些页是来自LRU列表的，因此称为FLUSH_LRU_LIST Checkpoint。</p>
<p>而从MySQL 5.6版本，也就是InnoDB1.2.x版本开始，这个检查被放在了一个单独的Page Cleaner线程中进行，并且用户可以通过参数innodb_lru_scan_depth控制LRU列表中可用页的数量，该值默认为1024，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW GLOBAL VARIABLES LIKE &apos;innodb_lru_scan_depth&apos;;</span><br><span class="line">+-----------------------+-------+</span><br><span class="line">| Variable_name         | Value |</span><br><span class="line">+-----------------------+-------+</span><br><span class="line">| innodb_lru_scan_depth | 1024  |</span><br><span class="line">+-----------------------+-------+</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Async/Sync Flush Checkpoint</strong> </p>
<p>指的是重做日志文件不可用的情况，这时需要强制将一些页刷新回磁盘。重做日志不可用的情况是因为当前事务数据库系统对重做日志的设计都是循环使用的，并不是让其无限增大，因为无限增大会造成成本和管理的问题。重做日志可以被重用的部分是指这些重做日志已经不需要在数据库恢复时使用到，可以这样理解，重做日志中的操作已经刷新到磁盘，所以数据库也就在恢复时可以将这部分覆盖重用。但是若此时重做日志还需使用，那就必须强制产生Checkpoint，将缓冲池中的页至少刷新到当前重做日志的位置。</p>
</li>
<li><p><strong>Dirty Page too much</strong> </p>
<p>即脏页的数量太多，导致InnoDB存储引擎强制进行Checkpoint。其目的总的来说还是为了保证缓冲池中有足够可用的页。其可由参数innodb_max_dirty_pages_pct控制, innodb_max_dirty_pages_pct值为75表示当缓冲池中脏页的数量占据75%时，强制进行Checkpoint，刷新一部分的脏页到磁盘。在InnoDB 1.0.x版本之前，该参数默认值为90，之后的版本都为75。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW GLOBAL VARIABLES LIKE &apos;innodb_max_dirty_pages_pct;</span><br><span class="line">+----------------------------+-------+</span><br><span class="line">| Variable_name              | Value |</span><br><span class="line">+----------------------------+-------+</span><br><span class="line">| innodb_max_dirty_pages_pct | 75    |</span><br><span class="line">+----------------------------+-------+</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ol start="3">
<li><p>关于Change buffer的一些常见问题官网文档有详细解答：</p>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/faqs-innodb-change-buffer.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/faqs-innodb-change-buffer.html</a> </p>
</li>
<li><p>查询缓存为什么在8.0被删除的原因，MySQL开发者 <a href="https://mysqlserverteam.com/author/matt-lord/" target="_blank" rel="noopener">Matt Lord</a> 在这篇博客中有做说明：</p>
<p><a href="https://mysqlserverteam.com/mysql-8-0-retiring-support-for-the-query-cache/" target="_blank" rel="noopener">https://mysqlserverteam.com/mysql-8-0-retiring-support-for-the-query-cache/</a> </p>
</li>
</ol>

    </div>

    
    
    
      
  <div class="popular-posts-header">相关文章</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/2019/08/31/浅析MySQL索引/" rel="bookmark">浅析MySQL索引</a></div>
    </li>
  </ul>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/MySQL/" rel="tag"><i class="fa fa-tag"></i> MySQL</a>
              <a href="/tags/InnoDB/" rel="tag"><i class="fa fa-tag"></i> InnoDB</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
                <a href="/2019/10/23/Redis为什么是单线程架构/" rel="next" title="Redis单线程模型">
                  <i class="fa fa-chevron-left"></i> Redis单线程模型
                </a>
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
                <a href="/2020/02/23/剑指offer解题记录/" rel="prev" title="剑指offer解题记录">
                  剑指offer解题记录 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
      </footer>
    
  </article>

  <ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-title"><h3><a href="/2019/08/31/浅析MySQL索引/" title="浅析MySQL索引" rel="bookmark">浅析MySQL索引</a></h3></div></li></ul>
    
  
  
  

  </div>


          </div>
          
    <div class="comments" id="comments"></div>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#InnoDB缓存方案和底层存储结构"><span class="nav-number">1.</span> <span class="nav-text">InnoDB缓存方案和底层存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#参考资料"><span class="nav-number">1.1.</span> <span class="nav-text">参考资料</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#InnoDB引擎概述"><span class="nav-number">1.2.</span> <span class="nav-text">InnoDB引擎概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#InnoDB体系架构"><span class="nav-number">1.3.</span> <span class="nav-text">InnoDB体系架构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#InnoDB缓存机制"><span class="nav-number">1.4.</span> <span class="nav-text">InnoDB缓存机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#缓冲池（Buffer-Pool）"><span class="nav-number">1.4.1.</span> <span class="nav-text">缓冲池（Buffer Pool）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#缓冲池的-LRU-算法"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">缓冲池的 LRU 算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#缓冲池搅动"><span class="nav-number">1.4.1.1.1.</span> <span class="nav-text">缓冲池搅动</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#相关参数"><span class="nav-number">1.4.1.1.2.</span> <span class="nav-text">相关参数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#缓冲池状态监控"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">缓冲池状态监控</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#缓冲池配置"><span class="nav-number">1.4.1.3.</span> <span class="nav-text">缓冲池配置</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#变更缓冲（Change-Buffer）"><span class="nav-number">1.4.2.</span> <span class="nav-text">变更缓冲（Change Buffer）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#日志缓冲（Log-Buffer）"><span class="nav-number">1.4.3.</span> <span class="nav-text">日志缓冲（Log Buffer）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查询缓存（-Query-Cache-）"><span class="nav-number">1.4.4.</span> <span class="nav-text">查询缓存（ Query Cache ）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#指定SELECT缓存"><span class="nav-number">1.4.4.1.</span> <span class="nav-text">指定SELECT缓存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#相关参数-1"><span class="nav-number">1.4.4.2.</span> <span class="nav-text">相关参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#状态监控"><span class="nav-number">1.4.4.3.</span> <span class="nav-text">状态监控</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#InnoDB存储结构"><span class="nav-number">1.5.</span> <span class="nav-text">InnoDB存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#逻辑存储结构"><span class="nav-number">1.5.1.</span> <span class="nav-text">逻辑存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#表空间"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">表空间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#段"><span class="nav-number">1.5.1.2.</span> <span class="nav-text">段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#区"><span class="nav-number">1.5.1.3.</span> <span class="nav-text">区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#页"><span class="nav-number">1.5.1.4.</span> <span class="nav-text">页</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#行"><span class="nav-number">1.5.1.5.</span> <span class="nav-text">行</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#行记录格式"><span class="nav-number">1.5.2.</span> <span class="nav-text">行记录格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据页结构"><span class="nav-number">1.5.3.</span> <span class="nav-text">数据页结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#File-Header"><span class="nav-number">1.5.3.1.</span> <span class="nav-text">File Header</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Page-Header"><span class="nav-number">1.5.3.2.</span> <span class="nav-text">Page Header</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Infimum和Suprenum-Record"><span class="nav-number">1.5.3.3.</span> <span class="nav-text">Infimum和Suprenum Record</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#User-Record和Free-Space"><span class="nav-number">1.5.3.4.</span> <span class="nav-text">User Record和Free Space</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Page-Directory"><span class="nav-number">1.5.3.5.</span> <span class="nav-text">Page Directory</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#File-Trailer"><span class="nav-number">1.5.3.6.</span> <span class="nav-text">File Trailer</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#会议疑问点"><span class="nav-number">1.6.</span> <span class="nav-text">会议疑问点</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="龚士云"
    src="/upload/me.jpg">
  <p class="site-author-name" itemprop="name">龚士云</p>
  <div class="site-description" itemprop="description">I'm gonna ride 'til I can't no more.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/gongshiyun" title="GitHub &rarr; https://github.com/gongshiyun" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:gongshiyun@126.com" title="E-Mail &rarr; mailto:gongshiyun@126.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2017 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-gsy"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">龚士云</span>
</div>

        






  
  <script>
  function leancloudSelector(url) {
    return document.getElementById(url).querySelector('.leancloud-visitors-count');
  }
  if (CONFIG.page.isPost) {
    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = visitors.getAttribute('id').trim();
      var title = visitors.getAttribute('data-flag-title').trim();

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .then(response => response.json())
              .then(() => {
                leancloudSelector(url).innerText = counter.time + 1;
              })
              .catch(error => {
                console.log('Failed to save visitor count', error);
              })
          } else {
              Counter('post', '/classes/Counter', { title: title, url: url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.log('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.log('LeanCloud Counter Error', error);
        });
    }
  } else {
    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return element.getAttribute('id').trim();
      });

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url: { '$in': entries } })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length === 0) {
            document.querySelectorAll('.leancloud_visitors .leancloud-visitors-count').forEach(element => {
              element.innerText = 0;
            });
            return;
          }
          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.url;
            var time = item.time;
            leancloudSelector(url).innerText = time;
          }
          for (var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = leancloudSelector(url);
            if (element.innerText == '') {
              element.innerText = 0;
            }
          }
        })
        .catch(error => {
          console.log('LeanCloud Counter Error', error);
        });
    }
  }

  fetch('https://app-router.leancloud.cn/2/route?appId=EPAXVAVtteh6PmtI0ngHp5h9-gzGzoHsz')
    .then(response => response.json())
    .then(({ api_server }) => {
      var Counter = (method, url, data) => {
        return fetch(`https://${api_server}/1.1${url}`, {
          method: method,
          headers: {
            'X-LC-Id': 'EPAXVAVtteh6PmtI0ngHp5h9-gzGzoHsz',
            'X-LC-Key': 'cY1JjAQtDORFkYcXsbUy8trn',
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        const localhost = /http:\/\/(localhost|127.0.0.1|0.0.0.0)/;
        if (localhost.test(document.URL)) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    });
  </script>






        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.2"></script><script src="/js/motion.js?v=7.4.2"></script>
<script src="/js/schemes/muse.js?v=7.4.2"></script>
<script src="/js/next-boot.js?v=7.4.2"></script>



  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>






  <script src="/js/local-search.js?v=7.4.2"></script>













  

  

  


<script>
NexT.utils.getScript('https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(item => {
    return GUEST.includes(item);
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'EPAXVAVtteh6PmtI0ngHp5h9-gzGzoHsz',
    appKey: 'cY1JjAQtDORFkYcXsbUy8trn',
    placeholder: "Just say something",
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: '' || 'zh-cn',
    path: location.pathname,
    recordIP: false,
    serverURLs: ''
  });
}, window.Valine);
</script>

</body>
</html>
