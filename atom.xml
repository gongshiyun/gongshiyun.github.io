<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>gsyun&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="gongshiyun.top/"/>
  <updated>2019-10-24T16:24:25.709Z</updated>
  <id>gongshiyun.top/</id>
  
  <author>
    <name>龚士云</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis单线程模型</title>
    <link href="gongshiyun.top/2019/10/23/Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%9E%B6%E6%9E%84/"/>
    <id>gongshiyun.top/2019/10/23/Redis为什么是单线程架构/</id>
    <published>2019-10-23T14:43:50.000Z</published>
    <updated>2019-10-24T16:24:25.709Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis单线程模型解析"><a href="#Redis单线程模型解析" class="headerlink" title="Redis单线程模型解析"></a>Redis单线程模型解析</h1><h2 id="什么是Redis"><a href="#什么是Redis" class="headerlink" title="什么是Redis"></a>什么是Redis</h2><p>Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 <a href="http://www.redis.cn/topics/data-types-intro.html#strings" target="_blank" rel="noopener">字符串（strings）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#hashes" target="_blank" rel="noopener">散列（hashes）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#lists" target="_blank" rel="noopener">列表（lists）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#sets" target="_blank" rel="noopener">集合（sets）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#sorted-sets" target="_blank" rel="noopener">有序集合（sorted sets）</a> 与范围查询， <a href="http://www.redis.cn/topics/data-types-intro.html#bitmaps" target="_blank" rel="noopener">bitmaps</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#hyperloglogs" target="_blank" rel="noopener">hyperloglogs</a> 和 <a href="http://www.redis.cn/commands/geoadd.html" target="_blank" rel="noopener">地理空间（geospatial）</a> 索引半径查询。 Redis 内置了 <a href="http://www.redis.cn/topics/replication.html" target="_blank" rel="noopener">复制（replication）</a>，<a href="http://www.redis.cn/commands/eval.html" target="_blank" rel="noopener">LUA脚本（Lua scripting）</a>， <a href="http://www.redis.cn/topics/lru-cache.html" target="_blank" rel="noopener">LRU驱动事件（LRU eviction）</a>，<a href="http://www.redis.cn/topics/transactions.html" target="_blank" rel="noopener">事务（transactions）</a> 和不同级别的 <a href="http://www.redis.cn/topics/persistence.html" target="_blank" rel="noopener">磁盘持久化（persistence）</a>， 并通过 <a href="http://www.redis.cn/topics/sentinel.html" target="_blank" rel="noopener">Redis哨兵（Sentinel）</a>和自动 <a href="http://www.redis.cn/topics/cluster-tutorial.html" target="_blank" rel="noopener">分区（Cluster）</a>提供高可用性（high availability）。</p><a id="more"></a><h2 id="Redis的单线程模型"><a href="#Redis的单线程模型" class="headerlink" title="Redis的单线程模型"></a>Redis的单线程模型</h2><p>Redis的单线程模型采用非阻塞IO多路复用的机制，使用单线程轮训监控与客户端的socket连接，监控socket命令所形成的AE_READABLE。拿到命令不直接执行，而是放入队列中，一个一个执行，不会有并发问题。<br><img src="https://img-blog.csdnimg.cn/20191025002114613.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM5OTc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="单线程的Redis为什么这么快？"><a href="#单线程的Redis为什么这么快？" class="headerlink" title="单线程的Redis为什么这么快？"></a>单线程的Redis为什么这么快？</h2><ul><li>纯内存操作，查找和操作的时间复杂度都是O(1)</li><li>单线程操作，避免了频繁的上下文切换，而多线程切换会涉及到锁以及消耗更多CPU</li><li>采用非阻塞IO多路复用机制：内部采用epoll+自己实现的简单事件框架。在epoll中的读，写，关闭，连接都转化成了事件，然后利用epoll的多路复用机制，绝不在IO上浪费一点时间</li><li>数据结构简单，对数据操作也简单</li><li><h2 id="Redis为什么是单线程的？"><a href="#Redis为什么是单线程的？" class="headerlink" title="Redis为什么是单线程的？"></a>Redis为什么是单线程的？</h2>官方答案：<br>因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。</li></ul><h2 id="如果CPU成为Redis的瓶颈怎么办？"><a href="#如果CPU成为Redis的瓶颈怎么办？" class="headerlink" title="如果CPU成为Redis的瓶颈怎么办？"></a>如果CPU成为Redis的瓶颈怎么办？</h2><p>可以考虑多起几个Redis进程，只要客户端分清楚哪些数据在哪个Redis进程就可以了。使用redis-cluster更好。</p><h2 id="单线程处理的缺点？"><a href="#单线程处理的缺点？" class="headerlink" title="单线程处理的缺点？"></a>单线程处理的缺点？</h2><p>无法发挥CPU的多核性能，不过可以通过在单机开多个Redis实例来完善。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Redis单线程模型解析&quot;&gt;&lt;a href=&quot;#Redis单线程模型解析&quot; class=&quot;headerlink&quot; title=&quot;Redis单线程模型解析&quot;&gt;&lt;/a&gt;Redis单线程模型解析&lt;/h1&gt;&lt;h2 id=&quot;什么是Redis&quot;&gt;&lt;a href=&quot;#什么是Redis&quot; class=&quot;headerlink&quot; title=&quot;什么是Redis&quot;&gt;&lt;/a&gt;什么是Redis&lt;/h2&gt;&lt;p&gt;Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 &lt;a href=&quot;http://www.redis.cn/topics/data-types-intro.html#strings&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;字符串（strings）&lt;/a&gt;， &lt;a href=&quot;http://www.redis.cn/topics/data-types-intro.html#hashes&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;散列（hashes）&lt;/a&gt;， &lt;a href=&quot;http://www.redis.cn/topics/data-types-intro.html#lists&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;列表（lists）&lt;/a&gt;， &lt;a href=&quot;http://www.redis.cn/topics/data-types-intro.html#sets&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;集合（sets）&lt;/a&gt;， &lt;a href=&quot;http://www.redis.cn/topics/data-types-intro.html#sorted-sets&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;有序集合（sorted sets）&lt;/a&gt; 与范围查询， &lt;a href=&quot;http://www.redis.cn/topics/data-types-intro.html#bitmaps&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;bitmaps&lt;/a&gt;， &lt;a href=&quot;http://www.redis.cn/topics/data-types-intro.html#hyperloglogs&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;hyperloglogs&lt;/a&gt; 和 &lt;a href=&quot;http://www.redis.cn/commands/geoadd.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;地理空间（geospatial）&lt;/a&gt; 索引半径查询。 Redis 内置了 &lt;a href=&quot;http://www.redis.cn/topics/replication.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;复制（replication）&lt;/a&gt;，&lt;a href=&quot;http://www.redis.cn/commands/eval.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LUA脚本（Lua scripting）&lt;/a&gt;， &lt;a href=&quot;http://www.redis.cn/topics/lru-cache.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LRU驱动事件（LRU eviction）&lt;/a&gt;，&lt;a href=&quot;http://www.redis.cn/topics/transactions.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;事务（transactions）&lt;/a&gt; 和不同级别的 &lt;a href=&quot;http://www.redis.cn/topics/persistence.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;磁盘持久化（persistence）&lt;/a&gt;， 并通过 &lt;a href=&quot;http://www.redis.cn/topics/sentinel.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Redis哨兵（Sentinel）&lt;/a&gt;和自动 &lt;a href=&quot;http://www.redis.cn/topics/cluster-tutorial.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;分区（Cluster）&lt;/a&gt;提供高可用性（high availability）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="redis" scheme="gongshiyun.top/categories/redis/"/>
    
    
      <category term="redis" scheme="gongshiyun.top/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Kafka学习</title>
    <link href="gongshiyun.top/2019/10/22/Kafka%E5%AD%A6%E4%B9%A0/"/>
    <id>gongshiyun.top/2019/10/22/Kafka学习/</id>
    <published>2019-10-22T11:58:58.000Z</published>
    <updated>2019-10-26T11:22:27.618Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Kafka学习"><a href="#Kafka学习" class="headerlink" title="Kafka学习"></a>Kafka学习</h1><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><table><thead><tr><th>资料名称</th><th>来源地址</th></tr></thead><tbody><tr><td>Kafka官方文档</td><td><a href="http://kafka.apache.org/intro" target="_blank" rel="noopener">http://kafka.apache.org/intro</a></td></tr><tr><td>《Kafka技术内幕》</td><td>图书</td></tr><tr><td>《Kafka、RabbitMQ、RocketMQ等消息中间件的对比 —— 消息发送性能和优势》</td><td><a href="https://yq.aliyun.com/articles/475265?spm=a2c4e.11153940.0.0.26dc794fkRn404" target="_blank" rel="noopener">https://yq.aliyun.com/articles/475265?spm=a2c4e.11153940.0.0.26dc794fkRn404</a></td></tr></tbody></table><a id="more"></a><h2 id="1-Kafka介绍"><a href="#1-Kafka介绍" class="headerlink" title="1. Kafka介绍"></a>1. Kafka介绍</h2><p>Kafka是一种高吞吐量的分布式发布订阅消息系统，也是一个流式数据处理平台，具有高性能、持久化、多副本备份、横向扩展能力。Kafka最初由LinkedIn公司开发的，之后成为Apache项目的一部分。具备下面三个特点：</p><ul><li>类似消息系统，提供事件流的发布和订阅，即具备数据注入功能</li><li>存储时间流数据的节点具有故障容错的特点，即具备数据存储功能</li><li>能够对实时的事件流进行流式的处理和分析，即具备流处理功能</li></ul><h3 id="1-1-基础架构和术语"><a href="#1-1-基础架构和术语" class="headerlink" title="1.1 基础架构和术语"></a>1.1 基础架构和术语</h3><p><img src="https://img-blog.csdnimg.cn/20191026190732259.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM5OTc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>Producer：</strong>发布消息的对象称为生产者</p><p><strong>Consumer：</strong>订阅消息并处理发布的消息的种子的对象称为消费者</p><p><strong>Consumer Group</strong>：我们可以将多个消费者组成一个消费者组，在kafka的设计中同一个分区的数据只能被消费者组中的某一个消费者消费。同一个消费者组的消费者可以消费同一个topic的不同分区的数据，这也是为了提高kafka的吞吐量</p><p><strong>Kafka cluster ：</strong>已发布的消息保存在一组服务器中，称之为Kafka集群</p><p><strong>Broker：</strong>Kafka集群中的每一个服务器都是一个代理(Broker). 消费者可以订阅一个或多个主题（topic），并从Broker拉数据，从而消费这些已发布的消息。</p><p><strong>Topic</strong>：消息的主题，可以理解为消息的分类，kafka的数据就保存在topic。在每个broker上都可以创建多个topic</p><p><strong>Partition：</strong>Topic的分区，每个topic可以有多个分区，分区的作用是做负载，提高kafka的吞吐量。同一个topic在不同的分区数据是不重复的，partition的表现形式就是一个一个的文件夹</p><p><strong>Replication：</strong>每一个分区都有多个副本，副本的作用是做备胎。当主分区（Leader）故障的时候会选择一个备胎（Follower）上位，成为Leader。在kafka中默认副本的最大数量是10个，且副本的数量不能大于Broker的数量，follower和leader绝对是在不同的机器，同一机器对同一个分区也只可能存放一个副本（包括自己）。</p><p><strong>Zookeeper</strong>：kafka集群依赖zookeeper来保存集群的的元信息，来保证系统的可用性</p><p><strong>AR ( Assigned Replicas)：</strong>分区中的所有副本合集</p><p><strong>ISR(In-Sync Replicas)：</strong>所有与leader 副本保持一定程度同步的副本（包括leader 副本在内〕组成 , ISR 集合是AR 集合中的一个子集</p><p><strong>OSR ( Out-of-Sync Replicas )：</strong>与leader 副本同步滞后过多的副本</p><p><strong>ISR = leader + 没有落后太多的副本</strong></p><p><strong>AR = OSR+ ISR;</strong></p><h2 id="2-Kafka三大角色"><a href="#2-Kafka三大角色" class="headerlink" title="2. Kafka三大角色"></a>2. Kafka三大角色</h2><ul><li><p><strong>消息系统</strong></p><p>Kafka和传统的消息系统（也称作消息中间件）都具备系统解耦、冗余存储、流量削峰、缓冲、异步通信、扩展性、可恢复性等功能。与此同时， Kafka 还提供了大多数消息系统难以实现的<strong>消息顺序性保障及回溯消费</strong>的功能。</p></li><li><p><strong>存储系统</strong></p><p>Kafka 把<strong>消息持久化到磁盘</strong>，相比于其他基于内存存储的系统而言，有效地降低了数据丢失的风险。也正是得益于Kafka 的消息持久化功能和多副本机制，我们可以把Kafka 作为长期的数据存储系统来使用，只需要把对应的数据保留策略设置为“永久”或启用主题的日志压缩功能即可。</p></li><li><p><strong>流式处理平台</strong></p><p>Kafka 不仅为每个流行的流式处理框架提供了可靠的数据来源，还提供了一个完整的<strong>流式处理类库</strong>，比如窗口、连接、变换和聚合等各类操作。</p></li></ul><h2 id="3-消息系统"><a href="#3-消息系统" class="headerlink" title="3. 消息系统"></a>3. 消息系统</h2><h3 id="3-1-消费模式"><a href="#3-1-消费模式" class="headerlink" title="3.1 消费模式"></a>3.1 消费模式</h3><ul><li><p><strong>点对点模式</strong></p><p><img src="https://img-blog.csdnimg.cn/20191026190519906.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM5OTc0Ng==,size_16,color_FFFFFF,t_70" alt></p><p>点对点模式通常是基于拉取或者轮询的消息传送模型，这个模型的特点是发送到队列的消息被一个且只有一个消费者进行处理。生产者将消息放入消息队列后，由消费者主动的去拉取消息进行消费。点对点模型的的优点是消费者拉取消息的频率可以由自己控制。但是消息队列是否有消息需要消费，在消费者端无法感知，所以在消费者端需要额外的线程去监控。</p></li><li><p><strong>发布订阅模式</strong></p></li></ul><p><img src="https://img-blog.csdnimg.cn/20191026190624926.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM5OTc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>  在该模式下生产者将消息发送到消息队列后，队列会将消息推送给订阅过该类消息的消费者。由于消费者被动接收推送，所以无需轮询队列是否有待消费的消息。但是consumer1、consumer2、consumer3由于机器性能不一样，所以处理消息的能力也会不一样，但消息队列却无法感知消费者消费的速度，所以推送的速度成了发布订阅模模式的一个问题，假设三个消费者处理速度分别是8M/s、5M/s、2M/s，如果队列推送的速度为5M/s，则consumer3无法承受，如果队列推送的速度为2M/s，则consumer1、consumer2会出现资源的极大浪费。</p><p>  <strong>Kafka同时支持这两种模式</strong>：</p><ul><li>如果所有的消费者都隶属于同一个消费组，那么所有的消息都会被均衡地投递给每一个消费者，即每条消息只会被一个消费者处理，这就相当于点对点模式的应用。</li><li>如果所有的消费者都隶属于不同的消费组，那么所有的消息都会被广播给所有的消费者，即每条消息会被所有的消费者处理，这就相当于发布／订阅模式的应用。</li></ul><h3 id="3-3-消费模型"><a href="#3-3-消费模型" class="headerlink" title="3.3 消费模型"></a>3.3 消费模型</h3><p>消息由生产者发布到Kafka集群后，会被消费者消费。</p><p>这里介绍下两种消费模型：推送（push）模型和拉取（pull）模型。</p><h4 id="3-3-1-推送模型"><a href="#3-3-1-推送模型" class="headerlink" title="3.3.1 推送模型"></a>3.3.1 推送模型</h4><p>基于推送模型的消息系统，由消息代理将消息推送给消费者。消费者的消费状态由代理服务器记录，消息代理服务器将消息发送给消费者后，将这这条消息标记为已消费，但这种方式无法很好报这个消息的处理语义。比如消息发出去后，当消费进程挂掉或者由于网络原因没有收到这条消息时，就有可能造成消息丢失问题（因为消息代理已经把这条消息标记为已消费了，但实际上这条消息并没有被实际处理）。如果要保证消息的处理语义，消息代理发送完消息后，要设置状态为已发送，只有收到消费者的确认请求后才更新为已消费，这就需要消息代理中记录所有消息的消费状态，这种做法也是不可取的。</p><p>####　3.3.2 拉取模型</p><p><strong>Kafka采用拉取模型</strong>。拉取模型中由消费者自己记录消费状态，每个消费者互相独立地顺序读取每个分区的消息，消费进度由消费者自由控制，可以重新处理之前消费过的消息或从当前时刻开始消费。</p><h3 id="3-2-分区模型"><a href="#3-2-分区模型" class="headerlink" title="3.2 分区模型"></a>3.2 分区模型</h3><p>在Kafka中的每一条消息都有一个topic（主题）。一般来说在我们应用中产生不同类型的数据，都可以设置不同的主题。一个主题一般会有多个消息的订阅者，当生产者发布消息到某个主题时，订阅了这个主题的消费者都可以接收到生产者写入的新消息。</p><p>Kafka的消息通过主题进行分类，主题类似于关系型数据库中的表或文件系统的中的文件夹。一个主题可以被分为多个分区，然后每个分区的消息以先进先出的顺序读取。</p><p>分区的目的：</p><ol><li><strong>方便扩展</strong>：因为一个主题可以有多个分区，所以可以通过扩展机器增加分区去轻松应对日益增长的数据量。</li><li><strong>提高并发</strong>：以分区为读写单位，可以多个消费者同时消费数据，提高了消息的处理效率。</li></ol><p><img src="https://img-blog.csdnimg.cn/20191026190810854.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM5OTc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>如上图，每个分区的每条消息都有一个称为offset的顺序ID号，该ID唯一地标识分区中的每个记录。当生产者产生新消息发布到broker时，每条消息追加到分区中，顺序写入磁盘，保证分区内消息顺序。</p><p><img src="https://img-blog.csdnimg.cn/20191026190827171.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM5OTc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>分区消息的读取由消费者控制，通常每个消费者都会保存当前消费的消息的偏移量，在每次消费时将这个偏移量不断增加，所以消费者可以自由控制消息读取的位置，重新处理以前的旧数据或跳到最近的记录开始消费，并且不会对其他消费者产生影响。</p><p>分区中各偏移量位置：</p><p><img src="https://img-blog.csdnimg.cn/20191026190841726.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM5OTc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>HW(High Watermark)</strong>：它标识了一个特定的消息偏移量（ offset ），消费者只能拉取到这个offset 之前的消息</p><p><strong>LEO(Log End Offset)</strong>：它标识当前日志文件中下一条待写入消息的offset，LEO 的大小相当于当前日志分区中最后一条消息的offset值加1 。分区ISR 集合中的每个副本都会维护自身的LEO</p><p><strong>LSO(Log Start Offset)：</strong>它标识当前日志文件起始的offset</p><p>上图表示一个分区的日志文件，当前有8条消息，第一条消息的offset（LogStartOffset）为0，最后一条消息offset为7，用虚线表示的offset为8的消息代表下一条待写入的消息。</p><h3 id="3-3-多副本架构"><a href="#3-3-多副本架构" class="headerlink" title="3.3 多副本架构"></a>3.3 多副本架构</h3><p>Kafka为分区提供了多副本机制，通过副本机制来保证容灾能力。副本的职责就是同步数据：从leader副本中同步消息，其他副本叫follower，之间是一主多从的关系。leader负责处理消息的读和写请求，follower负责同步leader上的消息数据。副本处于不同的Broker中，当leader挂掉，从ISR的follower副本中重新选举新的副本作为leader。Kafka 通过多副本机制实现了<strong>故障的自动转移</strong>，当Kafka 集群中某个broker 失效时仍然能保证服务可用。</p><p>基于多副本架构，下面分析一下ISR集合和HW、LEO关系：</p><p>某分区有三个副本，一个leader和两个follower，HW和LEO都是3，此时生产者发送消息3和消息4后存入leader副本：</p><p><img src="https://img-blog.csdnimg.cn/20191026190953443.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM5OTc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>如上图，此时消息3、消息4写入leader副本，follower1从leader同步了消息3，HW取最小值仍为3，leader的LEO变为5，follower1的LEO为4，follower2的LEO为3。当前消费者可以消费0-2之间的消息。</p><p><img src="https://img-blog.csdnimg.cn/20191026191121203.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM5OTc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>当follower2也同步了消息3，此时HW取最小值4，follower的LEO变为4。消费者可以消费0-3之间的消息。</p><p><img src="https://img-blog.csdnimg.cn/20191026191131945.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM5OTc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>最后follow1和follow2都同步了消息4，LEO和HW都变为5</p><h3 id="3-4-消息分区发送机制"><a href="#3-4-消息分区发送机制" class="headerlink" title="3.4 消息分区发送机制"></a>3.4 消息分区发送机制</h3><p>Kafka的消息由键值对和时间戳组成。</p><p>生产者负责将消息发布到对应的topic，具体是负责将哪个消息发布到主题中的哪个分区，这里生产者可能对请求进行负载，将消息分发到不同的分区：</p><ul><li><p>分区在写入的时候可以指定需要写入的分区，如果有指定，则写入对应的分区</p></li><li><p>如果没有指定分区，但是设置了数据的key，则会根据key的值hash出一个分区</p></li><li><p>如果既没指定分区，又没有设置key，则会轮询选出一个分区</p></li></ul><h3 id="3-5-消息保留机制"><a href="#3-5-消息保留机制" class="headerlink" title="3.5 消息保留机制"></a>3.5 消息保留机制</h3><p>Kafka集群使用可配置的保留期限持久地保留所有已发布的记录（无论是否已使用它们）。例如，如果将保留策略设置为两天，则在发布记录后的两天内，该记录可供使用，之后将被丢弃以释放空间。Kafka的性能相对于数据大小实际上是恒定的，因此长时间存储数据不是问题。</p><h3 id="3-6-消息批量写入机制"><a href="#3-6-消息批量写入机制" class="headerlink" title="3.6 消息批量写入机制"></a>3.6 消息批量写入机制</h3><p>为了提高消息写入效率，消息被分批次写入Kafka中。批次就是一组消息，这些消息属于同一topic下的同一分区。这样减少了网络开销，但是这需要在时间延迟和吞吐量之间作出平衡。批次的数据会被压缩，这样提升了数据的传输和存储能力，但同样做了更多的计算。</p><h3 id="3-7-消息顺序性保证"><a href="#3-7-消息顺序性保证" class="headerlink" title="3.7 消息顺序性保证"></a>3.7 消息顺序性保证</h3><p>传统消息系统在服务端保持消息的顺序，如果有多个消费者消费同一个消息队列，服务端会以消息存储的顺序依次发送给消费者。但由于消息是异步发送给消费者的，所以消息到达消费者的顺序可能是无序的，这就意味着并行消费时传统消息队列无法很好保证消息被顺序处理。虽然可以设置一个专用的消费者只消费一个队列，以此来解决消息顺序问题，但是这就使消费无法并行处理。</p><p>Kafka比传统消息系统有更强的消息顺序性保证，它使用主题分区作为消息处理的并行单元。Kafka以分区作为最小的粒度，将每个分区分配给消费组中不同的而且是唯一的消费者，并确保一个分区只属于一个消费者，即这个消费者就是这个分区下唯一读取线程。那么，只要分区的消息是有序的，消费者处理的消息顺序就有保证。每个主题有多个分区，不同消费者处理不同分区，所以Kafka不仅保证了消息的有序性，也做到了消费者的负载均衡。不过这个消息消费的顺序仅对于分区而言，如果要保证整个主题的消息消费顺序，那么这个主题只能有一个分区并被一个消费者消费才能保证主题内消息的消费顺序。</p><h3 id="3-8-producer向kafka写入消息的机制"><a href="#3-8-producer向kafka写入消息的机制" class="headerlink" title="3.8 producer向kafka写入消息的机制"></a>3.8 producer向kafka写入消息的机制</h3><p>可以通过 request.required.acks参数来设置数据可靠性的级别 ：</p><ul><li><p>0：producer无需等待来自broker的确认而继续发送下一批消息。这种情况下数据传输效率最高，但是数据可靠性确是最低的。 </p></li><li><p>1：这是默认值， producer发送消息，在leader已成功收到数据并得到确认后发送下一条消息。如果leader宕机了，则会丢失数据，因为可能消息还没有同步到其他follower。</p></li><li><p>-1： producer需要等待ISR中的所有follower都确认接收到数据后才算一次发送完成，可靠性最高。但是这样也不能保证数据不丢失，比如只有分区只有一个leader副本的时候，就变成了acks=1情况</p></li></ul><h2 id="4-存储系统"><a href="#4-存储系统" class="headerlink" title="4. 存储系统"></a>4. 存储系统</h2><h3 id="4-1-日志文件相关结构"><a href="#4-1-日志文件相关结构" class="headerlink" title="4.1 日志文件相关结构"></a>4.1 日志文件相关结构</h3><p>每个主题都有一个或多个分区，分区在服务器上表现形式就是一个个的文件夹，每个分区文件夹下会有多组segment文件，每组segment文件又包含.index文件、log文件、timeindex文件，其中log文件就是存储消息的地方，index和timeindex文件为索引文件，用于检索消息。</p><p><img src="https://img-blog.csdnimg.cn/20191026191145207.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM5OTc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>每个log文件大小是一样的，但是存储的消息数量不一定相等，因为消息大小可能不一样。文件的命名由segment最小的offset来命名，如segment1的log文件存储offset为0~368795的消息。</p><h3 id="4-2-日志索引机制"><a href="#4-2-日志索引机制" class="headerlink" title="4.2 日志索引机制"></a>4.2 日志索引机制</h3><p>kafka利用分段+索引的方式来解决查找效率的问题。由于kafka消息数据太大，如果全部建立索引，即占了空间又增加了耗时，所以kafka选择了稀疏索引的方式，这样的话索引可以直接进入内存，加快偏查询速度。</p><p>根据消息的offset368801来查找消息的过程如下：</p><p><img src="https://img-blog.csdnimg.cn/20191026191158558.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM5OTc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>1.根据二分法查找offset为368801的消息所在segment，找到为segment2</p><p>2.找到segment2中的index文件，文件中记录了消息的稀疏索引，存储相对offset及对应消息的物理偏移关系。这里查找的消息368801的相对offset为368801-368796=5，因为5在index中不存在，所以需要找到距离5最近的索引4。</p><p>3.根据索引4，确定相对offset为4的消息物理偏移为388，然后在log文件中根据偏移388找到message368800，一直往下扫描直到查找到offset368801的消息。</p><h3 id="4-3-磁盘读取优化机制"><a href="#4-3-磁盘读取优化机制" class="headerlink" title="4.3 磁盘读取优化机制"></a>4.3 磁盘读取优化机制</h3><p><img src="https://img-blog.csdnimg.cn/20191026191219604.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM5OTc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>数据从文件发送到socket网络连接中的常规传输路径：</p><ul><li>操作系统从磁盘读取数据到内核空间里的页面缓存</li><li>应用程序将数据从内核空间读入用户空间的缓冲区</li><li>应用程序将读到的数据写回内核空间并放入socket缓冲区</li><li>操作系统将数据从socket缓冲区复制到网卡接口，此时数据才能通过网络发送出去</li></ul><p>这个过程包含了4次copy和两个系统上下文切换，性能比较低效。</p><p>结合Kafka的消息有多个订阅者的使用场景，生产者发布的消息一般会被不同的消费者消费多次。Kafka使用“零拷贝”技术只需将磁盘文件的数据复制到页面缓存中一次，然后将数据从页面缓存直接发送到网络中(发送给不同使用者时，都可以重复使用同一个页面缓存)，避免了重复的复制操作。</p><h2 id="5-流式处理平台"><a href="#5-流式处理平台" class="headerlink" title="5. 流式处理平台"></a>5. 流式处理平台</h2><p>略</p><h2 id="6-API"><a href="#6-API" class="headerlink" title="6. API"></a>6. API</h2><p><img src="https://img-blog.csdnimg.cn/20191026191251218.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM5OTc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><a href="https://www.orchome.com/190" target="_blank" rel="noopener">Producer API</a> 允许应用程序发送数据流到kafka集群中的topic。</li><li><a href="https://www.orchome.com/200" target="_blank" rel="noopener">Consumer API</a> 允许应用程序从kafka集群的topic中读取数据流。</li><li><a href="https://www.orchome.com/304" target="_blank" rel="noopener">Streams API</a> 允许从输入topic转换数据流到输出topic。</li><li><a href="https://www.orchome.com/455" target="_blank" rel="noopener">Connect API</a> 通过实现连接器（connector），不断地从一些源系统或应用程序中拉取数据到kafka，或从kafka提交数据到宿系统（sink system）或应用程序。</li></ul><h2 id="7-Kafka使用示例（windows环境）"><a href="#7-Kafka使用示例（windows环境）" class="headerlink" title="7. Kafka使用示例（windows环境）"></a>7. Kafka使用示例（windows环境）</h2><h3 id="7-1-Kafka安装配置"><a href="#7-1-Kafka安装配置" class="headerlink" title="7.1 Kafka安装配置"></a>7.1 Kafka安装配置</h3><p>1.安装JDK</p><p>Kafka2.0.0版本开始不支持JDK7及以下版本，这里演示使用JDK1.8，JDK安装过程略过。</p><p>2.安装Zookeeper</p><p>Zookeeper是安装Kafka集群的必要组件，Kafka通过Zookeeper来实施对元数据信息的管理，包括集群、broker、主题、分区等内容。Kafka的安装包中已经有zookeeper,这里不再去另外下载安装。</p><p>3.下载Kafka安装包并解压：</p><p><a href="https://www.apache.org/dyn/closer.cgi?path=/kafka/2.3.0/kafka_2.12-2.3.0.tgz" target="_blank" rel="noopener">https://www.apache.org/dyn/closer.cgi?path=/kafka/2.3.0/kafka_2.12-2.3.0.tgz</a></p><p>4.进入Kafka目录，查看config目录下的server.properties配置文件，关注以下几个配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># broker的编号，如果集群中有多个broker，则每个broker的编号需要设置的不同</span><br><span class="line">broker.id=0</span><br><span class="line"># broker对外提供的服务入口地址</span><br><span class="line">listeners=PLAINTEXT://172.31.80.151:9092</span><br><span class="line"># 存放消息文件的目录</span><br><span class="line">log.dirs=/tmp/kafka-logs</span><br><span class="line"># Kafka所需的zookeeper集群地址</span><br><span class="line">zookeeper.connect=localhost:2181</span><br></pre></td></tr></table></figure><h3 id="7-2-单机模式"><a href="#7-2-单机模式" class="headerlink" title="7.2 单机模式"></a>7.2 单机模式</h3><p>1.进入Kafka安装目录，启动Zookeeper</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\bin\windows\zookeeper-server-start.bat .\config\zookeeper.properties</span><br></pre></td></tr></table></figure><p>2.启动Kafka server</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\bin\windows\kafka-server-start.bat .\config\server.properties</span><br></pre></td></tr></table></figure><p>3.创建topic “tplink”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\bin\windows\kafka-topics.bat --create --bootstrap-server localhost:9092 --replication-factor 1 --partitions 1 --topic tplink</span><br></pre></td></tr></table></figure><p>4.查看是否创建成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\bin\windows\kafka-topics.bat --list --bootstrap-server localhost:9092</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20191026191314846.png" alt="在这里插入图片描述"></p><p>5.启动生产者发送信息</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\bin\windows\kafka-console-producer.bat --broker-list localhost:<span class="number">9092</span> --topic tplink</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20191026191328655.png" alt="\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ukTixUTT-1572087828524)(Kafka学习.assets/1571295035887.png)\]"></p><p>6.启动消费者消费消息</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\bin\windows\kafka-console-consumer.bat --bootstrap-server localhost:<span class="number">9092</span> --topic tplink --from-beginning</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2019102619134929.png" alt="在这里插入图片描述"></p><p>可以看到生产者发送的消息成功被消费者消费</p><h3 id="7-3-分布式模式"><a href="#7-3-分布式模式" class="headerlink" title="7.3 分布式模式"></a>7.3 分布式模式</h3><p>分布式模式的Kafka集群拥有多个broker，增加两个broker：</p><p>1.复制config/server.properties文件为config/server-1.properties和config/server-2.properties</p><p>2.分别修改server-1.properties和server-2.properties</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">config/server-1.properties:</span><br><span class="line">broker.id=1</span><br><span class="line">listeners=PLAINTEXT://localhost:9093</span><br><span class="line">log.dirs=/tmp/kafka-logs-1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">config/server-2.properties:</span><br><span class="line">broker.id=2</span><br><span class="line">listeners=PLAINTEXT://localhost:9094</span><br><span class="line">log.dirs=/tmp/kafka-logs-2</span><br></pre></td></tr></table></figure><p>3.启动broker1和broker2：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.\bin\windows\kafka-server-start.bat .\config\server-<span class="number">1</span>.properties</span><br><span class="line">.\bin\windows\kafka-server-start.bat .\config\server-<span class="number">2</span>.properties</span><br></pre></td></tr></table></figure><p>4.创建topic，分区数量为1，分区副本数量为3</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\bin\windows\kafka-topics.bat --create --bootstrap-server <span class="number">172.31</span>.<span class="number">80.151</span>:<span class="number">9092</span> --replication-factor <span class="number">3</span> --partitions <span class="number">1</span> --topic tplink-replicated-topic</span><br></pre></td></tr></table></figure><p>5.查看topic</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\bin\windows\kafka-topics.bat --describe --bootstrap-server localhost:<span class="number">9092</span> --topic tplink-replicated-topic</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20191026191409701.png" alt="在这里插入图片描述"></p><p>解释：</p><p>返回的第一个行显示所有partitions的一个总结，以下每一行给出一个partition中的信息，如果我们只有一个partition，则只显示一行。</p><ul><li><p>Partition:0表示当前分区为0</p></li><li><p>Leader:0表示当前leader为broker.id为0的kafka实例</p></li><li><p>Replicas :显示给定partiton所有副本所存储节点的节点列表，不管该节点是否是leader或者是否存活</p></li><li><p>Isr: 副本都已同步的的节点集合，这个集合中的所有节点都是存活状态，并且跟leader同步</p></li></ul><p>6.创建生产者往集群发送消息</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\bin\windows\kafka-console-producer.bat --broker-list localhost:<span class="number">9092</span> --topic tplink-replicated-topic</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20191026191431426.png" alt="在这里插入图片描述"></p><p>7.创建消费者消费消息</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\bin\windows\kafka-console-consumer.bat --bootstrap-server localhost:<span class="number">9092</span> --from-beginning -topic tplink-replicated-topic</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20191026191449414.png" alt="在这里插入图片描述"></p><p>8.杀死分区的leader进程，查看topic状态</p><p>从第5步知道leader是1，查找broker id 为1的实例进程：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic <span class="keyword">process</span> where <span class="string">"caption = 'java.exe' and commandline like '%server.properties%'"</span> get processid</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20191026191501176.png" alt="在这里插入图片描述"></p><p>杀死进程：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskkill /pid <span class="number">36488</span> /f</span><br></pre></td></tr></table></figure><p>查看topic状态：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\bin\windows\kafka-topics.bat --describe --zookeeper localhost:<span class="number">2181</span> --topic tplink-replicated-topic</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20191026191511829.png" alt="在这里插入图片描述"></p><p>此时leader挂掉后，重新选举leader变为broker1，ISR剩下broker1和2</p><h3 id="7-4-docker镜像使用"><a href="#7-4-docker镜像使用" class="headerlink" title="7.4 docker镜像使用"></a>7.4 docker镜像使用</h3><p>1.安装 Docker Desktop on Windows</p><p> <a href="https://docs.docker.com/docker-for-windows/install/" target="_blank" rel="noopener">https://docs.docker.com/docker-for-windows/install/</a> </p><p>2.使用docker hub上的wurstmeister/kafka镜像</p><p> <a href="https://hub.docker.com/r/wurstmeister/kafka" target="_blank" rel="noopener">https://hub.docker.com/r/wurstmeister/kafka</a> </p><p>dock compose是 docker 提供的一个命令行工具，用来定义和运行由多个容器组成的应用。使用 compose，我们可以通过 YAML 文件声明式的定义应用程序的各个服务，并由单个命令完成应用的创建和启动。</p><p>编写docker-compose.yml文件，进行相关配置如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'2'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  zookeeper:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">wurstmeister/zookeeper</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"2181:2181"</span></span><br><span class="line"><span class="attr">  kafka:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">wurstmeister/kafka</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"9092-9095:9092"</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="attr">      KAFKA_ADVERTISED_LISTENERS:</span> <span class="attr">PLAINTEXT://:9092</span></span><br><span class="line"><span class="attr">      KAFKA_ADVERTISED_HOST_NAME:</span> <span class="number">172.31</span><span class="number">.80</span><span class="number">.151</span></span><br><span class="line"><span class="attr">      KAFKA_LISTENERS:</span> <span class="attr">PLAINTEXT://:9092</span></span><br><span class="line"><span class="attr">      KAFKA_ZOOKEEPER_CONNECT:</span> <span class="attr">zookeeper:2181</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line">    <span class="comment"># 使容器内可以执行docker ps、docker port等命令</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">/var/run/docker.sock:/var/run/docker.sock</span></span><br></pre></td></tr></table></figure><ol start="3"><li>创建和启动docker容器</li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><ol start="4"><li>扩展kafka节点为3个</li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose scale kafka=<span class="number">3</span></span><br></pre></td></tr></table></figure><ol start="5"><li>查看docker运行容器</li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20191026191532820.png" alt="在这里插入图片描述"></p><ol start="6"><li>创建topic</li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec kafka_kafka_1 kafka-topics.sh --create --topic tplink --partitions <span class="number">3</span> --zookeeper zookeeper:<span class="number">2181</span> --replication-factor <span class="number">3</span></span><br></pre></td></tr></table></figure><ol start="7"><li>查看当前topic列表</li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec kafka_kafka_1 kafka-topics.sh --list --zookeeper zookeeper:<span class="number">2181</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20191026191550454.png" alt="在这里插入图片描述"></p><ol start="8"><li>查看tplink topic的情况</li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec kafka_kafka_1 kafka-topics.sh --describe --topic tplink --zookeeper zookeeper:<span class="number">2181</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20191026191606107.png" alt="在这里插入图片描述"></p><h2 id="8-Kafka与其他消息队列比较"><a href="#8-Kafka与其他消息队列比较" class="headerlink" title="8. Kafka与其他消息队列比较"></a>8. Kafka与其他消息队列比较</h2><p>与RabbitMQ、RocketMQ比较：</p><ul><li><p>Kafka是LinkedIn开源的分布式发布-订阅消息系统，目前归属于Apache定级项目。Kafka主要特点是基于Pull的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集和传输。0.8版本开始支持复制，不支持事务，对消息的重复、丢失、错误没有严格要求，适合产生大量数据的互联网服务的数据收集业务。</p></li><li><p>RabbitMQ是使用Erlang语言开发的开源消息队列系统，基于AMQP协议来实现。AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。AMQP协议更多用在企业系统内，对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量的要求还在其次。</p></li><li><p>RocketMQ是阿里开源的消息中间件，它是纯Java开发，具有高吞吐量、高可用性、适合大规模分布式系统应用的特点。RocketMQ思路起源于Kafka，但并不是Kafka的一个Copy，它对消息的可靠传输及事务性做了优化，目前在阿里集团被广泛应用于交易、充值、流计算、消息推送、日志流式处理、binglog分发等场景。</p></li></ul><p>测试目的</p><p>对比Kafka、RabbitMQ、RocketMQ发送小消息(124字节)的性能。这次压测我们只关注服务端的性能指标,所以压测的标准是:</p><p>不断增加发送端的压力,直到系统吞吐量不再上升,而响应时间拉长。这时服务端已出现性能瓶颈,可以获得相应的系统最佳吞吐量。</p><p>测试场景</p><p>在同步发送场景中，三个消息中间件的表现区分明显：</p><p>Kafka的吞吐量高达17.3w/s，不愧是高吞吐量消息中间件的行业老大。这主要取决于它的队列模式保证了写磁盘的过程是线性IO。此时broker磁盘IO已达瓶颈。</p><p>RocketMQ也表现不俗，吞吐量在11.6w/s，磁盘IO %util已接近100%。RocketMQ的消息写入内存后即返回ack，由单独的线程专门做刷盘的操作，所有的消息均是顺序写文件。</p><p>RabbitMQ的吞吐量5.95w/s，CPU资源消耗较高。它支持AMQP协议，实现非常重量级，为了保证消息的可靠性在吞吐量上做了取舍。我们还做了RabbitMQ在消息持久化场景下的性能测试，吞吐量在2.6w/s左右。</p><p>性能对比：</p><p><img src="https://img-blog.csdnimg.cn/20191026191627447.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM5OTc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>测试环境</p><p>服务端为单机部署，机器配置如下：</p><p><img src="https://img-blog.csdnimg.cn/20191026191642686.png" alt="在这里插入图片描述"></p><p>应用版本：</p><p><img src="https://img-blog.csdnimg.cn/20191026191650642.png" alt="在这里插入图片描述"></p><p>测试脚本</p><p><img src="https://img-blog.csdnimg.cn/20191026191701530.png" alt="在这里插入图片描述"><br>以上引自 <a href="https://yq.aliyun.com/articles/475265?spm=a2c4e.11153940.0.0.26dc794fkRn404" target="_blank" rel="noopener">https://yq.aliyun.com/articles/475265?spm=a2c4e.11153940.0.0.26dc794fkRn404</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Kafka学习&quot;&gt;&lt;a href=&quot;#Kafka学习&quot; class=&quot;headerlink&quot; title=&quot;Kafka学习&quot;&gt;&lt;/a&gt;Kafka学习&lt;/h1&gt;&lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;资料名称&lt;/th&gt;
&lt;th&gt;来源地址&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Kafka官方文档&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;http://kafka.apache.org/intro&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://kafka.apache.org/intro&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;《Kafka技术内幕》&lt;/td&gt;
&lt;td&gt;图书&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;《Kafka、RabbitMQ、RocketMQ等消息中间件的对比 —— 消息发送性能和优势》&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://yq.aliyun.com/articles/475265?spm=a2c4e.11153940.0.0.26dc794fkRn404&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://yq.aliyun.com/articles/475265?spm=a2c4e.11153940.0.0.26dc794fkRn404&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
    
      <category term="Kafka" scheme="gongshiyun.top/categories/Kafka/"/>
    
    
      <category term="Kafka" scheme="gongshiyun.top/tags/Kafka/"/>
    
      <category term="消息队列" scheme="gongshiyun.top/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>浅析JAVA垃圾回收</title>
    <link href="gongshiyun.top/2019/08/31/%E6%B5%85%E6%9E%90JAVA%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <id>gongshiyun.top/2019/08/31/浅析JAVA垃圾回收/</id>
    <published>2019-08-31T05:41:29.000Z</published>
    <updated>2019-08-31T06:14:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><table><thead><tr><th>资料名称</th><th>来源地址</th></tr></thead><tbody><tr><td>《深入理解JVM&amp;G1 GC》</td><td>图书</td></tr><tr><td>《深入理解Java虚拟机》</td><td>图书</td></tr><tr><td>JAVA 8官方文档</td><td><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/</a></td></tr><tr><td>Github</td><td><a href="https://github.com/CyC2018/CS-Notes" target="_blank" rel="noopener">https://github.com/CyC2018/CS-Notes</a></td></tr></tbody></table><a id="more"></a><h2 id="什么是垃圾回收"><a href="#什么是垃圾回收" class="headerlink" title="什么是垃圾回收"></a>什么是垃圾回收</h2><p>Java一个特点就是引入了垃圾回收机制，Java垃圾回收是指JVM自动对内存中无用对象所占用空间的释放，使Java程序员在编写程序的时候不再需要考虑内存管理，可以有效的防止内存泄露。</p><h2 id="为什么要进行垃圾回收"><a href="#为什么要进行垃圾回收" class="headerlink" title="为什么要进行垃圾回收"></a>为什么要进行垃圾回收</h2><p>JVM运行过程中会为对象分配内存空间，当对象不会再被使用后，垃圾收集器需要对其所占用空间进行回收，否则迟早会导致内存占用越来越大直到内存溢出，程序就会无法运行。就比如家里的垃圾一直不扔，迟早会塞满整个家，人也没有空间在家里生活下去。</p><h2 id="对什么进行回收"><a href="#对什么进行回收" class="headerlink" title="对什么进行回收"></a>对什么进行回收</h2><p>垃圾回收主要针对堆和方法区的对象进行回收。线程私有的程序计数器、虚拟机栈和本地方法栈在线程结束之后就被清除，不参与垃圾回收。</p><h2 id="如何判断一个对象是否可以被回收"><a href="#如何判断一个对象是否可以被回收" class="headerlink" title="如何判断一个对象是否可以被回收"></a>如何判断一个对象是否可以被回收</h2><ul><li><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>为对象添加一个引用计数器，每当有一个地方引用它时，计数器值加一；当引用失效时，计数器减一；任何时刻当计数器值为0时说明该对象不可能再被使用，可以被垃圾回收。</p><p>如下代码，当存在两个对象之间的循环引用时，两者的引用计数永远不为0，导致无法对它们进行回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test a = <span class="keyword">new</span> Test();</span><br><span class="line">        Test b = <span class="keyword">new</span> Test();</span><br><span class="line">        a.instance = b;</span><br><span class="line">        b.instance = a;</span><br><span class="line">        a = <span class="keyword">null</span>;</span><br><span class="line">        b = <span class="keyword">null</span>; </span><br><span class="line">dosomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为循环引用问题难以处理，JAVA虚拟机没有选用引用计数法来管理内存。</p></li><li><h3 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h3><p>在主流的商用语言中如Java、C#的主流实现中都是通过可达性分析来判断对象是存活。这个算法的基本思路就是通过一系列的<strong>GC Roots</strong>对象作为起点，从这些节点开始向下搜索引用的对象，走过的路径称为<strong>引用链</strong>。<strong>当一个对象到GC Roots没有任何引用链相连时，证明此对象是不可用的，所以会被判定为是可回收的对象</strong>。</p><p>在Java中，GC Roots包含以下几种：</p><ul><li><p>虚拟机栈（栈帧中的本地变量表）中引用的对象</p></li><li><p>方法区中类静态属性引用的对象</p></li><li><p>方法区中常量引用的对象</p></li><li><p>本地方法栈中JNI引用的对象</p></li></ul><h3 id="对象的finalize-方法"><a href="#对象的finalize-方法" class="headerlink" title="对象的finalize()方法"></a>对象的finalize()方法</h3><p>在可达性分析中不可达的对象，也不一定会被回收，这里涉及到finalize方法的知识：</p><ul><li><p>finalize()是Object的protected方法，子类可以覆盖该方法以实现资源清理工作，GC在回收对象之前调用该方法，如果对象覆盖了该方法并且在该方法中将自身重新被引用链中任意对象引用， 就能完成自救。</p></li><li><p>finalize()方法最多只能被GC执行一次，第二次被标记回收时不会再执行该方法</p></li><li><p>finalize()方法不被推荐使用，它能做的所有工作，try-finally都能做得更好更及时</p></li></ul></li></ul><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h3><p>该算法首先标记出需要回收的对象,标记完成后统一回收掉所有的被标记对象</p><p>缺点：</p><ul><li><p>效率问题：标记和清除的效率不高</p></li><li><p>空间问题：标记清除后会产生大量不连续的内存碎片，空间碎片太多可能导致以后在程序运行过程中产生大量不连续的内存碎片。空间碎片太多可能会导致以后在程序运行中需要分配大对象时因为无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p></li></ul><h3 id="标记-整理"><a href="#标记-整理" class="headerlink" title="标记-整理"></a>标记-整理</h3><p>该算法的标记过程与标记-整理算法一致，但不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p><p>优点：不会产生内存碎片</p><p>缺点：需要移动大量对象，处理效率较低</p><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p>复制算法将可用内存分为大小相等的两块，每次只使用其中的一块，当这块内存用完了就将还存活的对象复制到另外一块上面，然后再把已使用的内存空间一次清理掉。</p><p>优点：不存在内存碎片问题，实现简单，运行高效。</p><p>缺点：内存缩小为了原来的一半。如果对象存活率高就要进行较多的复制操作，效率会变低。</p><h3 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h3><p>当前的商业虚拟机垃圾收集都使用分代收集算法。该算法思想是根据对象存活周期的不同将内存划分为几块，一般是分为年轻代和老年代，然后根据不同年代的特点采用最合适的收集算法。</p><p>新生代：每次垃圾收集都有大批对象死亡，少量存活，适合选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。</p><p>老年代：对象存活率高，适合使用标记-清理或标记-整理来进行回收。</p><h2 id="内存分配和回收策略"><a href="#内存分配和回收策略" class="headerlink" title="内存分配和回收策略"></a>内存分配和回收策略</h2><h3 id="JAVA堆结构"><a href="#JAVA堆结构" class="headerlink" title="JAVA堆结构"></a>JAVA堆结构</h3><p>在JDK1.8版本之前，JAVA堆被划分为年轻代、老年代和永久代，其中年轻代又被划分为eden、s1、s2。</p><p>在 JDK 1.8 中， HotSpot 已经没有 永久代这个区间了，取而代之的是 Metaspace（元空间）。</p><p>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过参数设置来指定元空间的大小。</p><h3 id="MinorGC-和-Full-GC"><a href="#MinorGC-和-Full-GC" class="headerlink" title="MinorGC 和 Full GC"></a>MinorGC 和 Full GC</h3><p>Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。</p><p>Full GC：回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。</p><h3 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h3><h4 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h4><p>大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。</p><h4 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h4><p>大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。</p><p>经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。</p><p>-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。</p><h4 id="长期存活的对象进入老年代"><a href="#长期存活的对象进入老年代" class="headerlink" title="长期存活的对象进入老年代"></a>长期存活的对象进入老年代</h4><p>为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。</p><p>-XX:MaxTenuringThreshold 用来定义年龄的阈值。</p><h4 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h4><p>虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于<br>Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。</p><h4 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h4><p>在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。</p><p>如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。</p><h4 id="Full-GC的触发条件"><a href="#Full-GC的触发条件" class="headerlink" title="Full GC的触发条件"></a>Full GC的触发条件</h4><p>对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件：</p><ul><li><strong>调用System.gc()</strong></li></ul><p>只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。</p><ul><li><strong>老年代空间不足</strong></li></ul><p>老年代空间不足的常见场景为大对象直接进入老年代、长期存活的对象进入老年代等。</p><p>为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。</p><ul><li><strong>空间分配担保失败</strong></li></ul><p>使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。</p><ul><li><strong>JDK 1.7 及以前的永久代空间不足</strong></li></ul><p>在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。</p><p>当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。</p><p>为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。</p><ul><li><strong>Concurrent Mode Failure</strong></li></ul><p>执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;资料名称&lt;/th&gt;
&lt;th&gt;来源地址&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;《深入理解JVM&amp;amp;G1 GC》&lt;/td&gt;
&lt;td&gt;图书&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;《深入理解Java虚拟机》&lt;/td&gt;
&lt;td&gt;图书&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JAVA 8官方文档&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Github&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://github.com/CyC2018/CS-Notes&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/CyC2018/CS-Notes&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
    
      <category term="JAVA" scheme="gongshiyun.top/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="gongshiyun.top/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>浅析MySQL索引</title>
    <link href="gongshiyun.top/2019/08/31/%E6%B5%85%E6%9E%90MySQL%E7%B4%A2%E5%BC%95/"/>
    <id>gongshiyun.top/2019/08/31/浅析MySQL索引/</id>
    <published>2019-08-31T05:30:14.000Z</published>
    <updated>2019-10-23T14:44:43.505Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><table><thead><tr><th>资料名称</th><th>来源地址</th></tr></thead><tbody><tr><td>《MySQL王者晋级之路》</td><td>图书</td></tr><tr><td>《高性能MySQL》</td><td>图书</td></tr><tr><td>MySQL官方文档</td><td><a href="https://dev.mysql.com/doc/" target="_blank" rel="noopener">https://dev.mysql.com/doc/</a></td></tr><tr><td>《MySQL索引背后的数据结构及算法原理》</td><td><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">http://blog.codinglabs.org/articles/theory-of-mysql-index.html</a></td></tr></tbody></table><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>MySQL的索引是存储引擎用于快速查找记录的一种数据结构。工作原理是先从索引上找到对应值，再根据匹配的索引记录找到对应的数据行。索引的目的在于提高查询效率，可类比字典、书籍的目录等这种形式。</p><h2 id="数据结构介绍"><a href="#数据结构介绍" class="headerlink" title="数据结构介绍"></a>数据结构介绍</h2><p>目前大部分数据库系统及文件系统都采用B-Tree或其变种B+Tree作为索引结构。实际上MySQL的很多存储引擎如最常见的innoDB使用的是B+Tree，即每个叶子节点都包含指向下一个叶子节点的指针，从而方便叶子节点的范围遍历。</p><h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h3><p><img src="https://img-blog.csdnimg.cn/20190819181704873.png" alt="在这里插入图片描述"></p><h3 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h3><p><img src="https://img-blog.csdnimg.cn/20190819181727194.png" alt="在这里插入图片描述"></p><h3 id="为什么要使用这种数据结构"><a href="#为什么要使用这种数据结构" class="headerlink" title="为什么要使用这种数据结构"></a>为什么要使用这种数据结构</h3><p>从理论上讲，二叉树查找速度和比较次数都是最小的，为什么不用二叉树呢？ </p><p>首先索引本质上是一种数据结构，占用空间也很大，不可能全部存储在内存中，一般以索引文件形式存储在磁盘上，所以查找索引时就涉及到从磁盘中读取数据，就会有I/O消耗。相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数，对于树来说，IO次数就是树的高度，而“矮胖”就是b树的特征之一。</p><p>磁盘读取数据时，并不是只读取所需要的数据就行，而是会从读取数据的起始处往后读取一定长度的数据。这就涉及到局部性原理和磁盘的预读机制的概念：</p><h4 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h4><p>当一个数据被用到时，其附近的数据也通常会马上被使用。</p><h4 id="磁盘预读机制"><a href="#磁盘预读机制" class="headerlink" title="磁盘预读机制"></a>磁盘预读机制</h4><p>因为磁盘存取速度比内存慢很多，根据局部性原理，为了提高效率，需要尽量减少磁盘I/O，磁盘每次都要从读取的数据位置顺序向后读取一页数据的整数倍放入内存中。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页的大小通常为4k）。</p><p>B-Tree每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个节点只需一次I/O。</p><p>B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存，h为树的高度），渐进复杂度为$O(h)=O(log_dN)$。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。</p><p>综上所述，用B-Tree作为索引结构效率是非常高的。</p><p>比如红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为$O(h)$，效率明显比B-Tree差很多。</p><h2 id="MySQL索引实现"><a href="#MySQL索引实现" class="headerlink" title="MySQL索引实现"></a>MySQL索引实现</h2><h3 id="MyISAM索引实现"><a href="#MyISAM索引实现" class="headerlink" title="MyISAM索引实现"></a>MyISAM索引实现</h3><p><img src="https://img-blog.csdnimg.cn/20190819181740530.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM5OTc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>MyISAM索引的数据结构是B+Tree结构，在叶子节点处保存的是数据记录的地址</p><p><img src="https://img-blog.csdnimg.cn/20190819181755308.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM5OTc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>辅助索引与主键索引除了主键索引具有唯一性外，其他地方没有任何区别，在叶子节点处仅保存数据记录的地址。搜索数据记录时先使用B+Tree的搜索算法找出数据地址，再根据数据地址找出数据记录。</p><p>MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分。</p><p>###　InnoDB索引实现</p><p><img src="https://img-blog.csdnimg.cn/20190819181808960.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM5OTc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>InnoDB引擎也是使用B+Tree作为索引结构。</p><p>与MyISAM引擎的索引实现方式不同在于InnoDB的数据文件本身就是主键的索引文件。</p><p>由上图可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p><p><img src="https://img-blog.csdnimg.cn/20190819181821472.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM5OTc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。</p><p>所以聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。</p><h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><h3 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h3><p>主键索引就是聚集索引，每张表中有且仅有一个主键，可以由表中一个或多个字段组成。</p><ul><li><p>主键值必须唯一</p></li><li><p>不能包含null值</p></li></ul><p>创建主键索引语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table table_name add primary key(column_list);</span><br></pre></td></tr></table></figure><h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><p>唯一索引是约束条件的一种，就是不允许有重复的值，但是可以允许有null值。表的主键只能有一个，但是唯一索引可以有多个。</p><p>创建唯一索引的语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create unique index index_name on table_name (column_list);</span><br><span class="line">-- 或</span><br><span class="line">alter table table_name add unique (column_list);</span><br></pre></td></tr></table></figure><h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><p>对于BLOB，TEXT或者很长的VARCHAR类型的列，为它们的前n个字符（具体几个由创建索引时指定）建立索引，这样的索引就叫前缀索引。这样建立的索引更小，查询更快。</p><p>创建前缀索引的语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create index index_name on table_name(column_name(prefix_length));</span><br><span class="line">-- 或</span><br><span class="line">alter table table_name add key(column_name(prefix_length));</span><br></pre></td></tr></table></figure><h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><p>联合索引又叫复合索引，是在表中两个或两个以上的列上创建的索引。利用索引的附加列，可以缩小检索的范围，更快搜索到数据。</p><p>创建联合索引的语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create index index_name on table_name (column_list);</span><br><span class="line">-- 或</span><br><span class="line">alter table table_name add index index_name (column_list);</span><br></pre></td></tr></table></figure><p>假设表t有c1，c2两个字段，为它们创建联合索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create index idx_c1_c2 on t (c1, c2);</span><br></pre></td></tr></table></figure><p>联合索引的使用必须满足最左前缀原则。一般把选择性高的列放在前面。一条查询语句可以只使用索引中的一部分，但是必须从最左侧开始。联合idx_c1_c2可以用到c1索引和c1，c2索引，但用不到c2索引。</p><p>以下查询可以用到idx_c1_c2的索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select * from t where c1 = &apos;xxx&apos;;</span><br><span class="line">select * from t where c1 = &apos;xxx&apos; and c2 = &apos;xxxx&apos;;</span><br><span class="line">select * from t where c1 = &apos;xxx&apos; and c2 in (&apos;xxxx&apos;, &apos;xxx&apos;);</span><br><span class="line">select * from t where c1 = (&apos;xxx&apos;, &apos;xxxx&apos;) and c2 = &apos;xxx&apos;;</span><br><span class="line">select * from t order by c1, c2;</span><br><span class="line">select * from t where c1 = &apos;xxx&apos; order by c2;</span><br></pre></td></tr></table></figure><p>用不到idx_c1_c2索引的查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from t where c2 = &apos;xxx&apos;;</span><br><span class="line">select * from t where c2 = &apos;xxx&apos; order by c1;</span><br></pre></td></tr></table></figure><p>另外，使用or关键字也是不能使用到联合索引的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where c1 = &apos;xxx&apos; or c2 = &apos;xxxx&apos;;</span><br></pre></td></tr></table></figure><p>这种情况就要在c1，c2各自建两个单列索引。</p><h3 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h3><p>哈希索引采用哈希算法，将键值换算成哈希值。哈希值只能进行等值查询，不能进行排序、模糊查找、范围查询等。检索时不需要像B+Tree那样从根节点到叶子节点逐级查找，只需一次哈希算法即可立刻定位到相应的位置，查询速度非常快。</p><p>innodb引擎支持哈希索引，称为自适应哈希索引，但是需要通过innodb_adaptive_hash_index参数来启用，默认是启用的。hash索引的创建由InnoDB存储引擎引擎自动优化创建。哈希索引只能用来搜索等值的查询，对于其他查找类型，如范围查找，是不能使用哈希索引的</p><p><img src="https://img-blog.csdnimg.cn/20190819181904638.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM5OTc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><p>全文索引是在基于文本的列（char、varchar或text列）上创建的，有助于提高对这些列中文本的查询速度和DML操作效率。</p><p>InnoDB引擎对全文索引的支持是MySQL5.6新引入的特性，之前只有MyISAM引擎支持全文索引。对于全文索引的内容可以使用MATCH()…AGAINST语法进行查询。MySQL5.6不支持中文全文索引，因为与英文不同，中文的文字是连着一起写的，中间没有MySQL能找到分词的地方。MySQL 5.7开始，MySQL内置了ngram全文检索插件，用来支持中文分词，并且对MyISAM和InnoDB引擎有效。</p><p>添加全文索引:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table table_name add fulltext index index_name(column_list) with parser ngram;</span><br></pre></td></tr></table></figure><p>查询语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MATCH(col1,col2,…) AGAINST (expr[search_modifier])</span><br></pre></td></tr></table></figure><h2 id="索引使用策略和优化技巧"><a href="#索引使用策略和优化技巧" class="headerlink" title="索引使用策略和优化技巧"></a>索引使用策略和优化技巧</h2><p>创建一个员工表用于示例，并导入数据，数据来源：<a href="https://dev.mysql.com/doc/employee/en/" target="_blank" rel="noopener">https://dev.mysql.com/doc/employee/en/</a></p><p>表结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE employees (</span><br><span class="line">    emp_no      INT             NOT NULL,</span><br><span class="line">    birth_date  DATE            NOT NULL,</span><br><span class="line">    first_name  VARCHAR(14)     NOT NULL,</span><br><span class="line">    last_name   VARCHAR(16)     NOT NULL,</span><br><span class="line">    gender      ENUM (&apos;M&apos;,&apos;F&apos;)  NOT NULL,    </span><br><span class="line">    hire_date   DATE            NOT NULL,</span><br><span class="line">    PRIMARY KEY (emp_no)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="全值匹配"><a href="#全值匹配" class="headerlink" title="全值匹配"></a>全值匹配</h3><p>全值匹配是指索引匹配查询条件的所有列</p><p>为字段birth_date, first_name, last_name创建联合索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table employees add index idx_bfl(`birth_date`, `first_name`, `last_name`);</span><br></pre></td></tr></table></figure><p>使用如下语句查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from employees where birth_date = &apos;1953-09-02&apos; and first_name = &apos;Georgi&apos; and last_name = &apos;Facello&apos;;</span><br></pre></td></tr></table></figure><p>执行计划如下，可见该查询使用到了索引：</p><p><img src="https://img-blog.csdnimg.cn/2019081918193058.png" alt="在这里插入图片描述"></p><h3 id="联合索引匹配最左列原则"><a href="#联合索引匹配最左列原则" class="headerlink" title="联合索引匹配最左列原则"></a>联合索引匹配最左列原则</h3><p>对于复合索引来说，不总是匹配所有字段列，但是可以匹配索引中靠左的列</p><p>如果在(a,b,c)三个字段上建立联合索引，那么它能够加快 a | (a,b) | (a,b,c) 三组查询速度。</p><p>查询如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from employees where birth_date = &apos;1953-09-02&apos; and first_name = &apos;Georgi&apos;;</span><br></pre></td></tr></table></figure><p>执行计划：</p><p><img src="https://img-blog.csdnimg.cn/20190819182022353.png" alt="在这里插入图片描述"></p><p>将where中的first_name 改为last_name:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from employees where birth_date = &apos;1953-09-02&apos; and last_name = &apos;Facello&apos;;</span><br></pre></td></tr></table></figure><p>执行计划：</p><p><img src="https://img-blog.csdnimg.cn/20190819182032858.png" alt="在这里插入图片描述"></p><p>可见该查询只用到了复合索引中的一个列。</p><p>联合索引优化技巧：</p><ul><li><p>建联合索引的时候，区分度最高的字段在最左边。</p><blockquote><p>计算一个列的区分度可以使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; select count(distinct(column_name))/count(1) from table; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>计算出来的结果约接近1区分度越好。</p></blockquote></li><li><p>如果建立了(a,b)联合索引，就不必再单独建立 a 索引。同理，如果建立了(a,b,c)联合索引，就不必再单独建立 a、(a,b) 索引。</p></li><li><p>存在非等号和等号混合判断条件时，在建索引时，请把等号条件的列前置。如     where a&gt;? and b=?，那么即使 a 的区分度更高，也必须把 b 放在索引的最前列。</p></li><li><p>最左侧查询需求，并不是指 SQL 语句的 where 顺序要和联合索引一致，where的条件顺序MySQL会进行优化为使用适合的索引。</p></li><li>范围条件有：&lt;、&lt;=、&gt;、&gt;=、between等。范围列可以用到索引（联合索引必须是最左前缀），但是范围列后面的列无法用到索引，索引最多用于一个范围列，如果查询条件中有两个范围列则无法全用到索引。</li></ul><h3 id="使用覆盖索引"><a href="#使用覆盖索引" class="headerlink" title="使用覆盖索引"></a>使用覆盖索引</h3><p>MySQL可以使用索引来直接获取列的数据，这样就不需要再去读取数据行了。如果一个索引包含（或者说覆盖）所有需要查询的数据，就称为“覆盖索引”。</p><p>执行如下查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select birth_date, first_name, last_name from employees where birth_date = &apos;1953-09-02&apos; and first_name = &apos;Georgi&apos;;</span><br></pre></td></tr></table></figure><p>此时查询只获取birth_date, first_name, last_name列，而索引idx_bfl已经包含了这三列字段的数据，所以MySQL无需再通过索引idx_bfl查询到的data域中的主键值去主键索引文件中查询数据记录。</p><p>该查询的执行计划如下：</p><p><img src="https://img-blog.csdnimg.cn/20190819182102664.png" alt="在这里插入图片描述"></p><p>其中Extra为Using index，说明使用了覆盖索引。</p><h3 id="避免强制类型转换"><a href="#避免强制类型转换" class="headerlink" title="避免强制类型转换"></a>避免强制类型转换</h3><p>强制类型转换的查询会导致全表扫描。</p><p>如果 salary字段是 varchar 类型，则下面的 SQL 不能命中索引。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from salaries where salary = 62102;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190819182129436.png" alt="在这里插入图片描述"></p><p>可以优化为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from salaries where salary = &apos;62102&apos;;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190819182149983.png" alt="在这里插入图片描述"></p><h2 id="InnoDB的主键选择与插入优化"><a href="#InnoDB的主键选择与插入优化" class="headerlink" title="InnoDB的主键选择与插入优化"></a>InnoDB的主键选择与插入优化</h2><p>在使用InnoDB存储引擎时，如果没有特别的需要，请永远使用一个与业务无关的自增字段作为主键。</p><p>上文讨论过InnoDB的索引实现，InnoDB使用聚集索引，数据记录本身被存于主索引（一颗B+Tree）的叶子节点上。这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）。</p><p>如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/20190819182200838.png" alt="在这里插入图片描述"></p><p>这样就会形成一个紧凑的索引结构，近似顺序填满。由于每次插入时也不需要移动已有数据，因此效率很高，也不会增加很多开销在维护索引上。</p><p>如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置：</p><p><img src="https://img-blog.csdnimg.cn/20190819182209576.png" alt="在这里插入图片描述"></p><p>此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。</p><p>因此，只要可以，请尽量在InnoDB上采用自增字段做主键。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="只要是查询语句需要，就建上索引？"><a href="#只要是查询语句需要，就建上索引？" class="headerlink" title="只要是查询语句需要，就建上索引？"></a>只要是查询语句需要，就建上索引？</h3><p>不是，因为索引虽然加快了查询速度，但索引也是有代价的。索引文件本身要消耗存储空间，同时索引会加重插入、删除和修改记录时的负担。另外，MySQL 在运行时也要消耗资源维护索引，因此索引并不是越多越好。一般两种情况下不建议建索引。第一种情况是表记录比较少，例如一两千条甚至只有几百条记录的表，没必要建索引，另一种是数据的区分度比较低，可以使用 count(distinct(列名))/count(*) 来计算区分度。</p><h3 id="假如建立联合索引-a-b-c-，下列语句是否可以使用索引，如果可以，使用了那几列？"><a href="#假如建立联合索引-a-b-c-，下列语句是否可以使用索引，如果可以，使用了那几列？" class="headerlink" title="假如建立联合索引(a,b,c)，下列语句是否可以使用索引，如果可以，使用了那几列？"></a>假如建立联合索引(a,b,c)，下列语句是否可以使用索引，如果可以，使用了那几列？</h3><p>where a= 3</p><p>答：是，使用了 a 列。</p><p>where a= 3 and b = 5</p><p>答：是，使用了 a，b 列。</p><p>where a = 3 and c = 4 and b = 5</p><p>答：是，使用了 a，b，c 列。</p><p>where b= 3</p><p>答：否。</p><p>where a= 3 and c = 4</p><p>答：是，使用了 a 列。</p><p>where a = 3 and b &gt; 10 and c = 7</p><p>答：是，使用了 a，b 列。</p><p>where a = 3 and b like ‘xx%’  and c = 7</p><p>答：是，使用了 a，b 列。</p><h2 id="答疑"><a href="#答疑" class="headerlink" title="答疑"></a>答疑</h2><h3 id="关于执行计划的相关列含义"><a href="#关于执行计划的相关列含义" class="headerlink" title="关于执行计划的相关列含义"></a>关于执行计划的相关列含义</h3><ul><li><p>Extra列</p><blockquote><p>Extra列是不适合在其他列显示的额外信息。</p><p>常用值如下：</p><p>Using index：表示使用覆盖索引</p><p>Using where：需要回表查询，使用where来过滤条件</p><p>Using index condition：查找使用了索引，但是需要回表查询数据</p></blockquote></li><li><p>filtered：显示的是针对表里符合where子句或联接条件的记录数的百分比</p></li><li><p>type：访问类型</p><blockquote><p>ALL：全表扫描</p><p>index：也是全表扫描，但是按照索引的次序进行</p><p>range：范围扫描</p><p>ref：索引查找</p></blockquote></li><li><p>possible_keys：查询可以使用哪些索引</p></li><li><p>key：MySQL决定用哪个索引来优化查询</p></li><li><p>key_len：索引使用的字节数。如果MySQL正在使用的只是索引里的某些列，那么就可以用这个值来算出具体是哪些列</p></li><li><p>rows：MySQL为了找到所需的行而要读取的行数</p></li></ul><h3 id="聚集（簇）索引的优势在哪？"><a href="#聚集（簇）索引的优势在哪？" class="headerlink" title="聚集（簇）索引的优势在哪？"></a>聚集（簇）索引的优势在哪？</h3><p>看上去聚簇索引的效率明显要低于非聚簇索引，因为每次使用辅助索引检索都要经过两次B+树查找，那么聚簇索引的优势在哪？</p><ul><li><p>由于行数据和叶子节点存储在一起，这样主键和行数据是一起被载入内存的，找到叶子节点就可以立刻将行数据返回了，如果按照主键Id来组织数据，获得数据更快。</p></li><li><p>辅助索引使用主键作为”指针” 而不是使用行地址值作为指针的好处是，减少了当出现行移动或者数据页分裂时辅助索引的维护工作，使用主键值当作指针会让辅助索引占用更多的空间，换来的好处是InnoDB在移动行时无须更新辅助索引中的这个”指针”，使用聚簇索引可以保证不管这个主键B+树的节点如何变化，辅助索引树都不受影响。<br>原文链接：<a href="https://blog.csdn.net/molashaonian/article/details/83012176" target="_blank" rel="noopener">https://blog.csdn.net/molashaonian/article/details/83012176</a></p></li></ul><h3 id="使用in关键字时联合索引使用情况"><a href="#使用in关键字时联合索引使用情况" class="headerlink" title="使用in关键字时联合索引使用情况"></a>使用in关键字时联合索引使用情况</h3><p>本地测试的MySQL版本为5.7.19。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from employees where birth_date in (&apos;1953-09-02&apos;, &apos;1953-09-05&apos;)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190819182232154.png" alt="在这里插入图片描述"></p><p>由执行计划得知用到了联合索引中的最左列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from employees where birth_date in (&apos;1953-09-02&apos;, &apos;1953-09-05&apos;) and first_name = &apos;Georgi&apos;;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2019081918224125.png" alt="在这里插入图片描述"></p><p>通过key_len可以知道用到了联合索引中的前两个字段（当where条件只有birth_date条件时key_len为3，key_len是指MySQL在索引里使用的字节数）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from employees where birth_date = &apos;1953-09-02&apos; and first_name in (&apos;Georgi&apos;, &apos;xxx&apos;) and last_name = &apos;Facello&apos;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190819182259343.png" alt="在这里插入图片描述"></p><p>通过key_len可以知道用到了联合索引中的所有字段</p><h3 id="使用范围查询时联合索引使用情况"><a href="#使用范围查询时联合索引使用情况" class="headerlink" title="使用范围查询时联合索引使用情况"></a>使用范围查询时联合索引使用情况</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from employees where birth_date = &apos;1953-09-02&apos; and first_name &gt; &apos;Georgi&apos; and last_name = &apos;Facello&apos;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190819182310251.png" alt="在这里插入图片描述"></p><p>由执行计划得知，该查询使用到了联合索引的前两列。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;资料名称&lt;/th&gt;
&lt;th&gt;来源地址&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;《MySQL王者晋级之路》&lt;/td&gt;
&lt;td&gt;图书&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;《高性能MySQL》&lt;/td&gt;
&lt;td&gt;图书&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MySQL官方文档&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://dev.mysql.com/doc/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://dev.mysql.com/doc/&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;《MySQL索引背后的数据结构及算法原理》&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;http://blog.codinglabs.org/articles/theory-of-mysql-index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://blog.codinglabs.org/articles/theory-of-mysql-index.html&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="gongshiyun.top/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="gongshiyun.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>HashMap的四种遍历方式及遍历性能的测试</title>
    <link href="gongshiyun.top/2018/08/18/HashMap%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E5%8F%8A%E9%81%8D%E5%8E%86%E6%80%A7%E8%83%BD%E7%9A%84%E6%B5%8B%E8%AF%95/"/>
    <id>gongshiyun.top/2018/08/18/HashMap的四种遍历方式及遍历性能的测试/</id>
    <published>2018-08-18T13:42:54.000Z</published>
    <updated>2018-08-18T13:55:26.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> gsy.main.collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> gongshiyun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> hashmap 遍历方式练习,以及遍历性能测试</span></span><br><span class="line"><span class="comment"> * 输出:</span></span><br><span class="line"><span class="comment"> * Map 初始化1000000条数据时间: 1040014952</span></span><br><span class="line"><span class="comment"> * 遍历方式1:通过 keySet 进行循环遍历: 52262563</span></span><br><span class="line"><span class="comment"> * 遍历方式2:通过 Map.entrySet 使用 iterator 遍历 key 和 value: 40783708</span></span><br><span class="line"><span class="comment"> * 遍历方式3:通过 Map.entrySet 遍历 key 和 value: 34407489</span></span><br><span class="line"><span class="comment"> * 遍历方式4: 通过 map.keySet().iterator() 遍历: 32135582</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Map 初始化100000条数据时间: 35574972</span></span><br><span class="line"><span class="comment"> * 遍历方式1:通过 keySet 进行循环遍历: 13408674</span></span><br><span class="line"><span class="comment"> * 遍历方式2:通过 Map.entrySet 使用 iterator 遍历 key 和 value: 6436631</span></span><br><span class="line"><span class="comment"> * 遍历方式3:通过 Map.entrySet 遍历 key 和 value: 3298929</span></span><br><span class="line"><span class="comment"> * 遍历方式4: 通过 map.keySet().iterator() 遍历: 4588371</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Map 初始化1000条数据时间: 1227517</span></span><br><span class="line"><span class="comment"> * 遍历方式1:通过 keySet 进行循环遍历: 712118</span></span><br><span class="line"><span class="comment"> * 遍历方式2:通过 Map.entrySet 使用 iterator 遍历 key 和 value: 259776</span></span><br><span class="line"><span class="comment"> * 遍历方式3:通过 Map.entrySet 遍历 key 和 value: 154431</span></span><br><span class="line"><span class="comment"> * 遍历方式4: 通过 map.keySet().iterator() 遍历: 138950</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 总结: 从测试结果来看,遍历方式3和4性能较优</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/8/3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> t1, t2, t3, t4, t5, t6, init, initEnd;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> MAP_INIT_NUM = <span class="number">1000000</span>;</span><br><span class="line">        <span class="comment">// 指定初始值,赋值100000值所需时间21855171</span></span><br><span class="line">        <span class="comment">// 不指定初始值,赋值100000所需时间39124238</span></span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(MAP_INIT_NUM);</span><br><span class="line"></span><br><span class="line">        init = System.nanoTime();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAP_INIT_NUM; i++) &#123;</span><br><span class="line">            map.put(String.valueOf(i), String.valueOf(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        initEnd = System.nanoTime();</span><br><span class="line"></span><br><span class="line">        t1 = System.nanoTime();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 遍历方式1:通过 keySet 进行循环遍历</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(<span class="string">"遍历方式1:通过 keySet 进行循环遍历:"</span>);</span><br><span class="line">        <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">            <span class="comment">//System.out.println("Key: " + key + " Value: " + map.get(key));</span></span><br><span class="line">            map.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//map.keySet().forEach(k -&gt; map.get(k)); //使用forEach耗费时间更多</span></span><br><span class="line"></span><br><span class="line">        t2 = System.nanoTime();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 遍历方式2:通过 Map.entrySet 使用 iterator 遍历 key 和 value</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(<span class="string">"遍历方式2:通过 Map.entrySet 使用 iterator 遍历 key 和 value :"</span>);</span><br><span class="line">        Iterator iterator = map.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Map.Entry&lt;String, String&gt; entry = (Map.Entry&lt;String, String&gt;) iterator.next();</span><br><span class="line">            <span class="comment">//System.out.println("Key: " + entry.getKey() + " Value: " + entry.getValue());</span></span><br><span class="line">            entry.getValue();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        t3 = System.nanoTime();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 遍历方式3:通过 Map.entrySet 遍历 key 和 value</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(<span class="string">"遍历方式3:通过 Map.entrySet 遍历 key 和 value :"</span>);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            <span class="comment">//System.out.println("Key: " + entry.getKey() + " Value: " + entry.getValue());</span></span><br><span class="line">            entry.getValue();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//map.entrySet().forEach(k -&gt; k.getValue());</span></span><br><span class="line"></span><br><span class="line">        t4 = System.nanoTime();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 遍历方式4: 通过 map.keySet().iterator() 遍历</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(<span class="string">"遍历方式4: 通过 map.keySet().iterator() 遍历 :"</span>);</span><br><span class="line">        Iterator keyIt = map.keySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (keyIt.hasNext()) &#123;</span><br><span class="line">            Object key = keyIt.next();</span><br><span class="line">            map.get(key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        t5 = System.nanoTime();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Map 初始化"</span> + MAP_INIT_NUM + <span class="string">"条数据时间: "</span> + (initEnd - init));</span><br><span class="line">        System.out.println(<span class="string">"遍历方式1:通过 keySet 进行循环遍历: "</span> + (t2 - t1));</span><br><span class="line">        System.out.println(<span class="string">"遍历方式2:通过 Map.entrySet 使用 iterator 遍历 key 和 value: "</span> + (t3 - t2));</span><br><span class="line">        System.out.println(<span class="string">"遍历方式3:通过 Map.entrySet 遍历 key 和 value: "</span> + (t4 - t3));</span><br><span class="line">        System.out.println(<span class="string">"遍历方式4: 通过 map.keySet().iterator() 遍历: "</span> + (t5 - t4));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="集合" scheme="gongshiyun.top/categories/%E9%9B%86%E5%90%88/"/>
    
    
      <category term="集合" scheme="gongshiyun.top/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>数值的整数次方</title>
    <link href="gongshiyun.top/2018/07/22/%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/"/>
    <id>gongshiyun.top/2018/07/22/数值的整数次方/</id>
    <published>2018-07-22T08:35:08.000Z</published>
    <updated>2018-07-22T08:38:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。<br><a id="more"></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leetcode.main;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> gongshiyun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 数值的整数次方</span></span><br><span class="line"><span class="comment"> * 给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/7/20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Power</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">solution1</span><span class="params">(<span class="keyword">double</span> base,<span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> result = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> k = Math.abs(exponent);</span><br><span class="line">        <span class="keyword">if</span> (exponent == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result = base;</span><br><span class="line">        <span class="keyword">while</span> (--k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            result *= base;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (exponent &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            result = <span class="number">1</span> / result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。&lt;br&gt;
    
    </summary>
    
    
      <category term="算法" scheme="gongshiyun.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="gongshiyun.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="gongshiyun.top/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>二进制中1的个数</title>
    <link href="gongshiyun.top/2018/07/22/%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <id>gongshiyun.top/2018/07/22/二进制中1的个数/</id>
    <published>2018-07-22T08:34:58.000Z</published>
    <updated>2018-07-22T08:37:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。<br><a id="more"></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leetcode.main;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> gongshiyun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 二进制中1的个数</span></span><br><span class="line"><span class="comment"> * 输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/7/20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberOf1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * n与n-1做与运算,将n二进制最后一位1的位置之后都变为0,</span></span><br><span class="line"><span class="comment">     * 当n最后为0时说明二进制中已经没有1</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solution1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            n &amp;= n - <span class="number">1</span>;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * n与1做与运算，结果为1说明n最后一位为1</span></span><br><span class="line"><span class="comment">     * 然后对n进行无符号右移，循环以上操作，直到n为0</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solution2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            n &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。&lt;br&gt;
    
    </summary>
    
    
      <category term="算法" scheme="gongshiyun.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="gongshiyun.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="gongshiyun.top/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>变态跳台阶</title>
    <link href="gongshiyun.top/2018/07/19/%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6/"/>
    <id>gongshiyun.top/2018/07/19/变态跳台阶/</id>
    <published>2018-07-19T11:45:46.000Z</published>
    <updated>2019-07-22T12:59:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法<br><a id="more"></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leetcode.main;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> gongshiyun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 变态跳台阶</span></span><br><span class="line"><span class="comment"> * 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。</span></span><br><span class="line"><span class="comment"> * 求该青蛙跳上一个n级的台阶总共有多少种跳法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/7/19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JumpFloorII</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 思路：</span></span><br><span class="line"><span class="comment">     * 找规律得出该结论：</span></span><br><span class="line"><span class="comment">     *        | 1  n=0</span></span><br><span class="line"><span class="comment">     * f(n) = | 1  n=1</span></span><br><span class="line"><span class="comment">     *        | 2*f(n-1) n &gt; 1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"参数不能小于0"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; (n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法&lt;br&gt;
    
    </summary>
    
    
      <category term="算法" scheme="gongshiyun.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="gongshiyun.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="gongshiyun.top/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>跳台阶</title>
    <link href="gongshiyun.top/2018/07/19/%E8%B7%B3%E5%8F%B0%E9%98%B6/"/>
    <id>gongshiyun.top/2018/07/19/跳台阶/</id>
    <published>2018-07-19T11:45:35.000Z</published>
    <updated>2018-07-19T11:51:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。<br><a id="more"></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leetcode.main;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> gongshiyun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 跳台阶：</span></span><br><span class="line"><span class="comment"> * 一只青蛙一次可以跳上1级台阶，也可以跳上2级。</span></span><br><span class="line"><span class="comment"> * 求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/7/19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JumpFloor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 思路：有两种跳法，一种跳一阶，另一种跳两阶;</span></span><br><span class="line"><span class="comment">     * 第一次跳如果跳一阶，剩下为f(n-1);</span></span><br><span class="line"><span class="comment">     * 如果跳两阶，剩下为f(n-2);</span></span><br><span class="line"><span class="comment">     * 所以f(n) = f(n-1) + f(n-2)。</span></span><br><span class="line"><span class="comment">     * 可以看出这是一个斐波那契数列。</span></span><br><span class="line"><span class="comment">     * 使用循环法。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jumpFloor</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"参数不能小于0"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> num1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> num2 = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (n-- &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            num2 += num1;</span><br><span class="line">            num1 = num2 - num1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。&lt;br&gt;
    
    </summary>
    
    
      <category term="算法" scheme="gongshiyun.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="gongshiyun.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="gongshiyun.top/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>斐波那契数列</title>
    <link href="gongshiyun.top/2018/07/19/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
    <id>gongshiyun.top/2018/07/19/斐波那契数列/</id>
    <published>2018-07-19T11:45:21.000Z</published>
    <updated>2019-08-31T06:07:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>输入一个整数n，输出斐波那契数列的第n项（从0开始，第0项为0,n&lt;=39)<br><a id="more"></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leetcode.main;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> gongshiyun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。</span></span><br><span class="line"><span class="comment"> * n&lt;=39</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/7/19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fibonacci</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归法：重复计算情况过多</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fibonacciByRecursive</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fibonacciByRecursive(n - <span class="number">1</span>) + fibonacciByRecursive(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用循环</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fibonacciByCycle</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"参数不能为负"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> num1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            num2 += num1;</span><br><span class="line">            num1 = num2 - num1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;输入一个整数n，输出斐波那契数列的第n项（从0开始，第0项为0,n&amp;lt;=39)&lt;br&gt;
    
    </summary>
    
    
      <category term="算法" scheme="gongshiyun.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="gongshiyun.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="gongshiyun.top/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>旋转数组的最小数字</title>
    <link href="gongshiyun.top/2018/07/19/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"/>
    <id>gongshiyun.top/2018/07/19/旋转数组的最小数字/</id>
    <published>2018-07-19T11:45:10.000Z</published>
    <updated>2018-07-19T11:51:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。<br>NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。<br><a id="more"></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.leetcode.main;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> gongshiyun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。</span></span><br><span class="line"><span class="comment"> * 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。</span></span><br><span class="line"><span class="comment"> * 例如数组&#123;3,4,5,1,2&#125;为&#123;1,2,3,4,5&#125;的一个旋转，该数组的最小值为1。</span></span><br><span class="line"><span class="comment"> * NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/7/19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinNumberInRotateArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历数组，找到第一个比数组第一位小的数即为最小值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minInOrder</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> min = array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (min &gt; array[i]) &#123;</span><br><span class="line">                min = array[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用二分查找最小数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray2</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"数组为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (array.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (array[left] &gt;= array[right]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (right - left == <span class="number">1</span>) &#123;</span><br><span class="line">                mid = right;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 数组为非减排序，旋转后可能出现左右中位置的数相等的情况</span></span><br><span class="line">            <span class="comment">// 如非减排序数组[0,1,1,1,1]，旋转后可能为[1,0,1,1,1],[1,1,1,0,1]</span></span><br><span class="line">            <span class="comment">// 这种情况直接遍历数组</span></span><br><span class="line">            <span class="keyword">if</span> (array[left] == array[mid] &amp;&amp; array[mid] == array[right]) &#123;</span><br><span class="line">                <span class="keyword">return</span> minInOrder(array);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (array[mid] &lt;= array[right]) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[mid] &gt;= array[left]) &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[mid];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。&lt;br&gt;NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。&lt;br&gt;
    
    </summary>
    
    
      <category term="算法" scheme="gongshiyun.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="gongshiyun.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="gongshiyun.top/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>用两个栈实现队列</title>
    <link href="gongshiyun.top/2018/07/19/%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>gongshiyun.top/2018/07/19/用两个栈实现队列/</id>
    <published>2018-07-18T19:33:17.000Z</published>
    <updated>2018-07-19T11:52:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。<br>思路:<br>1.stack1作为入队列,stack2作为出队列<br>2.pop:当stack2为空时,stack1全部出栈到stack2,stack2再出栈顶部元素<br><a id="more"></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leetcode.main;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> gongshiyun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</span></span><br><span class="line"><span class="comment"> *              思路:</span></span><br><span class="line"><span class="comment"> *              1.stack1作为入队列,stack2作为出队列</span></span><br><span class="line"><span class="comment"> *              2.pop:当stack2为空时,stack1全部出栈到stack2,stack2再出栈顶部元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/7/19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueByTwoStacks</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * stack1作为入队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * stack2作为出队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 入队列操作,入栈stack1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当stack2为空时,stack1全部出栈到stack2,stack2再出栈顶部元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack1.empty() &amp;&amp; stack2.empty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (stack2.empty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack1.empty())&#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。&lt;br&gt;思路:&lt;br&gt;1.stack1作为入队列,stack2作为出队列&lt;br&gt;2.pop:当stack2为空时,stack1全部出栈到stack2,stack2再出栈顶部元素&lt;br&gt;
    
    </summary>
    
    
      <category term="算法" scheme="gongshiyun.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="gongshiyun.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="gongshiyun.top/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>删除链表的倒数第 n 个节点</title>
    <link href="gongshiyun.top/2018/07/17/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-n-%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <id>gongshiyun.top/2018/07/17/删除链表的倒数第-n-个节点/</id>
    <published>2018-07-17T15:34:12.000Z</published>
    <updated>2018-07-19T11:54:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。<br>示例：<br>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.<br>当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.<br>说明：<br>给定的 n 保证是有效的。<br>进阶：<br>尝试使用一趟扫描实现:快慢指针<br><a id="more"></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leetcode.main;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.leetcode.entity.ListNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 19</span></span><br><span class="line"><span class="comment"> * 给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</span></span><br><span class="line"><span class="comment"> * 示例：</span></span><br><span class="line"><span class="comment"> * 给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.</span></span><br><span class="line"><span class="comment"> * 当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</span></span><br><span class="line"><span class="comment"> * 说明：</span></span><br><span class="line"><span class="comment"> * 给定的 n 保证是有效的。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> gongshiyun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2018/5/3 22:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoveNthFromEnd</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ListNode l1 = <span class="keyword">new</span> ListNode(<span class="number">2</span>);</span><br><span class="line">        ListNode l2 = <span class="keyword">new</span> ListNode(<span class="number">4</span>);</span><br><span class="line">        <span class="comment">//ListNode l3 = new ListNode(3);</span></span><br><span class="line">        <span class="comment">//ListNode l4 = new ListNode(5);</span></span><br><span class="line">        <span class="comment">//ListNode l5 = new ListNode(6);</span></span><br><span class="line"></span><br><span class="line">        l1.setNext(l2);</span><br><span class="line">        <span class="comment">//l2.setNext(l3);</span></span><br><span class="line">        <span class="comment">//l3.setNext(l4);</span></span><br><span class="line">        <span class="comment">//l4.setNext(l5);</span></span><br><span class="line">        ListNode result = removeNthFromEnd(l1,<span class="number">1</span>);</span><br><span class="line">        System.out.print(result.val);</span><br><span class="line">        <span class="keyword">while</span> (result.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(<span class="string">" -&gt; "</span>);</span><br><span class="line">            result = result.next;</span><br><span class="line">            System.out.print(result.val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 思想:使用快慢指针,一个快n步遍历,当快指针到达末尾,慢指针指向要删除的节点</span></span><br><span class="line"><span class="comment">     * head-&gt;a-&gt;b-&gt;c-&gt;d</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode headNode = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        headNode.next = head;</span><br><span class="line">        ListNode fastNode = headNode;</span><br><span class="line">        ListNode slowNode = headNode;</span><br><span class="line">        <span class="keyword">while</span> (fastNode.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            fastNode = fastNode.next;</span><br><span class="line">            <span class="keyword">if</span> (n-- &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                slowNode = slowNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (slowNode.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            slowNode.next = slowNode.next.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> headNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。&lt;br&gt;示例：&lt;br&gt;给定一个链表: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5, 和 n = 2.&lt;br&gt;当删除了倒数第二个节点后，链表变为 1-&amp;gt;2-&amp;gt;3-&amp;gt;5.&lt;br&gt;说明：&lt;br&gt;给定的 n 保证是有效的。&lt;br&gt;进阶：&lt;br&gt;尝试使用一趟扫描实现:快慢指针&lt;br&gt;
    
    </summary>
    
    
      <category term="算法" scheme="gongshiyun.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="gongshiyun.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="gongshiyun.top/tags/LeetCode/"/>
    
      <category term="链表" scheme="gongshiyun.top/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>从尾到头打印链表</title>
    <link href="gongshiyun.top/2018/07/17/%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
    <id>gongshiyun.top/2018/07/17/从尾到头打印链表/</id>
    <published>2018-07-17T15:26:50.000Z</published>
    <updated>2018-07-19T11:54:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>输入一个链表，从尾到头打印链表每个节点的值。<br><a id="more"></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leetcode.main;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.leetcode.entity.ListNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从尾到头打印链表</span></span><br><span class="line"><span class="comment"> * 输入一个链表，从尾到头打印链表每个节点的值。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> gongshiyun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2018/6/26 1:27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReversePrintListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; arr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ListNode l1 = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        ListNode l2 = <span class="keyword">new</span> ListNode(<span class="number">2</span>);</span><br><span class="line">        ListNode l3 = <span class="keyword">new</span> ListNode(<span class="number">3</span>);</span><br><span class="line">        ListNode l4 = <span class="keyword">new</span> ListNode(<span class="number">4</span>);</span><br><span class="line">        ListNode l5 = <span class="keyword">new</span> ListNode(<span class="number">5</span>);</span><br><span class="line">        ListNode l6 = <span class="keyword">new</span> ListNode(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        l1.setNext(l2);</span><br><span class="line">        l2.setNext(l3);</span><br><span class="line">        l3.setNext(l4);</span><br><span class="line">        l4.setNext(l5);</span><br><span class="line">        l5.setNext(l6);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//printListFromTailToHead(l1);</span></span><br><span class="line">        <span class="comment">//ArrayList&lt;Integer&gt; arr = getListFromTailToHead(l1);</span></span><br><span class="line">        ArrayList&lt;Integer&gt; arr = printListFromTailToHeadByStack(l1);</span><br><span class="line">        <span class="keyword">if</span> (arr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> val : arr) &#123;</span><br><span class="line">                System.out.println(val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">getListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; arr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        printListFromTailToHead(listNode, arr);</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用递归方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listNode</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode, ArrayList&lt;Integer&gt; arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (listNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            printListFromTailToHead(listNode.next, arr);</span><br><span class="line">            arr.add(listNode.val);</span><br><span class="line">            <span class="comment">//System.out.println(listNode.val);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用栈</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listNode</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHeadByStack</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (listNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(listNode.val);</span><br><span class="line">            listNode = listNode.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stack.empty()) &#123;</span><br><span class="line">            result.add(stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;输入一个链表，从尾到头打印链表每个节点的值。&lt;br&gt;
    
    </summary>
    
    
      <category term="算法" scheme="gongshiyun.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="gongshiyun.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="gongshiyun.top/tags/LeetCode/"/>
    
      <category term="链表" scheme="gongshiyun.top/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Thread基础知识</title>
    <link href="gongshiyun.top/2018/07/16/Thread%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>gongshiyun.top/2018/07/16/Thread基础知识/</id>
    <published>2018-07-16T10:17:51.000Z</published>
    <updated>2018-07-19T18:58:58.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>java的线程是通过java.lang.Thread类来实现的。</li><li>VM启动时会有一个由主方法所定义的线程。</li><li>可以通过创建Thread的实例来创建新的线程。</li><li>每个线程都是通过某个特定Thread对象所对应的方法run()来完成其操作的，<strong>方法run()称为线程体</strong>。</li><li><strong>通过调用Thread类的start()方法来启动一个线程。</strong></li></ul><hr><a id="more"></a><h3 id="线程的5种状态"><a href="#线程的5种状态" class="headerlink" title="线程的5种状态"></a>线程的5种状态</h3><ul><li><strong>创建</strong>:生成了线程对象,并没有调用该对象的start方法,这是线程处于创建状态。</li><li><strong>就绪</strong>:当调用了线程对象的start方法之后，该线程就进入了就绪状态，但是此时线程调度程序还没有把该线程设置为当前线程，此时处于就绪状态。在线程运行之后，从等待或者睡眠中回来之后，也会处于就绪状态。</li><li><strong>运行</strong>:线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行run函数当中的代码。</li><li><strong>阻塞</strong>:线程正在运行的时候，被暂停，通常是为了等待某个时间的发生(比如说某项资源就绪)之后再继续运行。sleep,suspend，wait等方法都可以导致线程阻塞。</li><li><strong>死亡</strong>:如果一个线程的run方法执行结束或者调用stop方法后，该线程就会死亡。对于已经死亡的线程，无法再使用start方法令其进入就绪。</li></ul><hr><h3 id="实现并启动线程方法"><a href="#实现并启动线程方法" class="headerlink" title="实现并启动线程方法"></a>实现并启动线程方法</h3><ul><li>写一个类继承自Thread类，重写run方法。用start方法启动线程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承Thread类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">　　<span class="comment">//重写run方法</span></span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//创建并启动线程</span></span><br><span class="line">　　　　<span class="keyword">new</span> MyThread().start();</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>写一个类实现Runnable接口，实现run方法。用new Thread(Runnable target).start()方法来启动</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现Runnable接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//重写run方法</span></span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">　　　　<span class="comment">//创建并启动线程</span></span><br><span class="line"></span><br><span class="line">　　　　MyThread2 myThread=<span class="keyword">new</span> MyThread2();</span><br><span class="line"></span><br><span class="line">　　　　Thread thread=<span class="keyword">new</span> Thread(myThread);</span><br><span class="line"></span><br><span class="line">　　　　thread().start();</span><br><span class="line"></span><br><span class="line">　　　　<span class="comment">//或者</span></span><br><span class="line">       <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread2()).start();</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用Callable和Future创建线程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">　　　MyThread3 th=<span class="keyword">new</span> MyThread3();</span><br><span class="line"></span><br><span class="line">　　　<span class="comment">//使用Lambda表达式创建Callable对象</span></span><br><span class="line"></span><br><span class="line">　　  <span class="comment">//使用FutureTask类来包装Callable对象</span></span><br><span class="line"></span><br><span class="line">　　　FutureTask&lt;Integer&gt; future=<span class="keyword">new</span> FutureTask&lt;Integer&gt;(</span><br><span class="line"></span><br><span class="line">　　　　(Callable&lt;Integer&gt;)()-&gt;&#123;</span><br><span class="line"></span><br><span class="line">　　　　　　<span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　  );</span><br><span class="line">      <span class="comment">//实质上还是以Callable对象来创建并启动线程</span></span><br><span class="line">　　　<span class="keyword">new</span> Thread(future,<span class="string">"有返回值的线程"</span>).start();</span><br><span class="line"></span><br><span class="line">　　  <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//get()方法会阻塞，直到子线程执行结束才返回</span></span><br><span class="line">　　　　System.out.println(<span class="string">"子线程的返回值："</span>+future.get());</span><br><span class="line"></span><br><span class="line"> 　　 &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line"></span><br><span class="line">　　　　ex.printStackTrace();</span><br><span class="line"></span><br><span class="line">　　　&#125;</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="三种创建线程方法对比"><a href="#三种创建线程方法对比" class="headerlink" title="三种创建线程方法对比"></a>三种创建线程方法对比</h3><p>实现Runnable和实现Callable接口的方式基本相同，不过是后者执行call()方法有返回值，后者线程执行体run()方法无返回值，因此可以把这两种方式归为一种这种方式与继承Thread类的方法之间的差别如下：</p><ul><li><p>线程只是实现Runnable或实现Callable接口，还可以继承其他类。</p></li><li><p>这种方式下，多个线程可以共享一个target对象，非常适合多线程处理同一份资源的情形。</p></li><li><p>但是编程稍微复杂，如果需要访问当前线程，必须调用Thread.currentThread()方法。</p></li><li><p>继承Thread类的线程类不能再继承其他父类（Java单继承决定）。</p></li></ul><h4 id="注：一般推荐采用实现接口的方式来创建多线程"><a href="#注：一般推荐采用实现接口的方式来创建多线程" class="headerlink" title="注：一般推荐采用实现接口的方式来创建多线程"></a>注：一般推荐采用实现接口的方式来创建多线程</h4><hr><h3 id="start和run方法区别"><a href="#start和run方法区别" class="headerlink" title="start和run方法区别"></a>start和run方法区别</h3><ul><li>start()方法来启动线程，真正实现了多线程运行。这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码；<strong>通过调用Thread类的start()方法来启动一个线程， 这时此线程是处于就绪状态， 并没有运行</strong>。 然后通过此Thread类调用方法run()来完成其运行操作的， 这里方法run()称为线程体，它包含了要执行的这个线程的内容， Run方法运行结束， 此线程终止。然后CPU再调度其它线程。</li><li><strong>run()方法当作普通方法的方式调用</strong>。程序还是要顺序执行，要等待run方法体执行完毕后，才可继续执行下面的代码； 程序中只有主线程——这一个线程， 其程序执行路径还是只有一条， 这样就没有达到写线程的目的。</li></ul><hr><h4 id="多线程就是分时利用CPU，宏观上让所有线程一起执行-，也叫并发"><a href="#多线程就是分时利用CPU，宏观上让所有线程一起执行-，也叫并发" class="headerlink" title="多线程就是分时利用CPU，宏观上让所有线程一起执行 ，也叫并发"></a><strong>多线程就是分时利用CPU，宏观上让所有线程一起执行 ，也叫并发</strong></h4>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;java的线程是通过java.lang.Thread类来实现的。&lt;/li&gt;
&lt;li&gt;VM启动时会有一个由主方法所定义的线程。&lt;/li&gt;
&lt;li&gt;可以通过创建Thread的实例来创建新的线程。&lt;/li&gt;
&lt;li&gt;每个线程都是通过某个特定Thread对象所对应的方法run()来完成其操作的，&lt;strong&gt;方法run()称为线程体&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;通过调用Thread类的start()方法来启动一个线程。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
    
    </summary>
    
    
      <category term="Java基础" scheme="gongshiyun.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java基础" scheme="gongshiyun.top/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="多线程" scheme="gongshiyun.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-单例模式代码示例</title>
    <link href="gongshiyun.top/2018/07/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B/"/>
    <id>gongshiyun.top/2018/07/13/设计模式-单例模式代码示例/</id>
    <published>2018-07-13T02:58:01.000Z</published>
    <updated>2019-08-31T06:19:26.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="饿汉"><a href="#饿汉" class="headerlink" title="饿汉"></a>饿汉</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 单例模式-饿汉</span></span><br><span class="line"><span class="comment"> *  优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。</span></span><br><span class="line"><span class="comment"> *  缺点：在类装载的时候就完成实例化，没有达到Lazy Loading的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> gongshiyun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/07/05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类装载时实例化静态常量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HungrySingleton INSTANCE = <span class="keyword">new</span> HungrySingleton();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态代码块模式</span></span><br><span class="line"><span class="comment">     * 类实例化的过程放在了静态代码块中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/*static &#123;</span></span><br><span class="line"><span class="comment">        INSTANCE = new HungrySingleton();</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="懒汉-线程不安全"><a href="#懒汉-线程不安全" class="headerlink" title="懒汉(线程不安全)"></a>懒汉(线程不安全)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 单例模式-懒汉(线程不安全)</span></span><br><span class="line"><span class="comment"> * 这种写法起到了Lazy Loading的效果，但是只能在单线程下使用。</span></span><br><span class="line"><span class="comment"> * 如果在多线程下，一个线程进入了if (singleton == null)判断语句块，</span></span><br><span class="line"><span class="comment"> * 还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。</span></span><br><span class="line"><span class="comment"> * 所以在多线程环境下不可使用这种方式。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> gongshiyun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/7/5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="懒汉-线程安全-同步方法"><a href="#懒汉-线程安全-同步方法" class="headerlink" title="懒汉(线程安全,同步方法)"></a>懒汉(线程安全,同步方法)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> gongshiyun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> SafeLazySingleton</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 单例模式-懒汉(线程安全,同步方法)</span></span><br><span class="line"><span class="comment"> * 缺点：效率低，每个线程获取类的实例都需要进行同步</span></span><br><span class="line"><span class="comment"> * 而其实这个方法只执行一次实例化代码就够了，后面的想</span></span><br><span class="line"><span class="comment"> * 获得该类实例，直接return就行了。方法进行同步效率太低要改进。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/7/5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeLazySingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SafeLazySingleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SafeLazySingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SafeLazySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SafeLazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="双重检查"><a href="#双重检查" class="headerlink" title="双重检查"></a>双重检查</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> gongshiyun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> DbCheckSingleton</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 双重检查</span></span><br><span class="line"><span class="comment"> * 优点：线程安全；延迟加载；效率较高。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/7/5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DbCheckSingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> DbCheckSingleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DbCheckSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DbCheckSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (DbCheckSingleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> DbCheckSingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> gongshiyun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> Singleton</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 静态内部类[推荐用]</span></span><br><span class="line"><span class="comment"> * 这种方式跟饿汉式方式采用的机制类似，但又有不同。</span></span><br><span class="line"><span class="comment"> * 两者都是采用了类装载的机制来保证初始化实例时只有一个线程。</span></span><br><span class="line"><span class="comment"> * 不同的地方在饿汉式方式是只要Singleton类被装载就会实例化，</span></span><br><span class="line"><span class="comment"> * 没有Lazy-Loading的作用，而静态内部类方式在Singleton类</span></span><br><span class="line"><span class="comment"> * 被装载时并不会立即实例化，而是在需要实例化时，调用getInstance方法，</span></span><br><span class="line"><span class="comment"> * 才会装载SingletonInstance类，从而完成Singleton的实例化。</span></span><br><span class="line"><span class="comment"> * 类的静态属性只会在第一次加载类的时候初始化，所以在这里，</span></span><br><span class="line"><span class="comment"> * JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。</span></span><br><span class="line"><span class="comment"> * 优点：避免了线程不安全，延迟加载，效率高。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/7/5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInstance</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonInstance.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> gongshiyun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> EnumSingleton</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 枚举实现单例模式</span></span><br><span class="line"><span class="comment"> * 不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/7/5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EnumSingleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;饿汉&quot;&gt;&lt;a href=&quot;#饿汉&quot; class=&quot;headerlink&quot; title=&quot;饿汉&quot;&gt;&lt;/a&gt;饿汉&lt;/h4&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@Description&lt;/span&gt; 单例模式-饿汉&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *  优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *  缺点：在类装载的时候就完成实例化，没有达到Lazy Loading的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@author&lt;/span&gt; gongshiyun&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@date&lt;/span&gt; 2018/07/05&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;HungrySingleton&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * 类装载时实例化静态常量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; HungrySingleton INSTANCE = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; HungrySingleton();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * 私有构造函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;HungrySingleton&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * 静态代码块模式&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * 类实例化的过程放在了静态代码块中&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/*static &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;        INSTANCE = new HungrySingleton();&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    &amp;#125;*/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; HungrySingleton &lt;span class=&quot;title&quot;&gt;getInstance&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; INSTANCE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="gongshiyun.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java基础" scheme="gongshiyun.top/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="设计模式" scheme="gongshiyun.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
